前面我们讲的所有的数据结构都是线性表结构，栈、队列等等。现在我们来讲一种非线性表结构——树。

树这种数据结构比线性表的数据结构要复杂得多，内容也比较多，其应用也十分的广泛。

在正式的内容开始之前，我想先问大家一个问题：我们为什么需要二叉树？带着这个问题，我们就来学习今天的内容吧！

### 1\. 为什么需要树这种数据结构

客观世界中许多事务存在层次关系，比如说社会组织结构以及信息管理等，这种分层次的组织被证实有着更高的效率。而将这种分层次的结构抽象到数据结构世界中，我们就得到了树这种数据结构。

我们知道，数据管理最基本的操作之一就是查找，那么，就是让我们以查找作为引子，引出树这种数据结构。查找分为静态查找和动态查找，其中静态查找是指要查找的数据是固定不变的，而动态查找是指要查找的数据是不断变化的。

#### **1.1 从二分查找到二叉树**

提到静态查找，我们最容易能想到的就是顺序查找，这种查找方法效率较低，其时间复杂度为：O(n)。

相比较于顺序查找，二分查找的效率要高很多，而且二分查找是一个基础且经典的查找算法，下面让我们来走进二分查找。

二分查找需要待处理得数据是排好序的，其基本步骤如下：

  1. 给出要查找的元素 key，将第一个元素置为 low，下标为 0；最后一个元素置为 high，下标为 length-1。
  2. mid=(low+high)/2 将 key 与序列中下标为 mid 的元素进行比较。
  3. 若 key 的值与下标为 mid 值相等，返回 mid
  4. 如果 key 的值大于下标为 mid 的值，则 low=mid+1；若果 key 的值小于下标的值，则 high=mid-1。
  5. 再将 key 与 mid 的值比较，重复 3、4 步骤，直至找出与 key 相等的元素的下标。
  6. 如果序列中不存在这样一个元素与 key 的值相等，则返回 -1。

过程如下图所示：

![](https://images.gitbook.cn/2020-07-27-015805.png)

    
    
        int binarySearch(int arr[], int left, int right, int x) {
            if(right>=left) {
                int middle = left + (right - left) / 2;
                if (arr[middle] == x) {
                    return middle;
                }
                else if (arr[middle] > x){
                    return binarySearch(arr, left, middle - 1, x);
                }
                else {
                    return binarySearch(arr, middle + 1, right, x);
                }
            }
            return -1;
        }
    

其迭代实现为：

    
    
    int binarySearch(int arr[], int left, int right, int x) {
        while(right>=left) {
            int middle =left + (right - left) / 2;
            if (arr[middle] == x) {
                return middle;
            }
            else if (arr[middle] > x){
                right = middle - 1;
            }
            else {
                left = middle + 1;
            }
        }
        return -1;
    }
    

下面让我们来分析一下二分查找的时间复杂度：待查找的总共有 n 个值，每次查找的区间大小就是 $n,n/2,n/4,...,n/(2^k)$，其中 k
就是循环的次数。

可知 $2^k=n$，所以最终计算出循环次数为 log2(n)，所以时间复杂度可以表示为：O(log(n))。

可以看到，二分查找的时间复杂度相比较于顺序查找有了极大的提升。尤其是对于量很大的数据的查找，其效果尤为显著。比如说，对个数为 100
万的数据进行查找分析，顺序查找平均需要 50 万次，而二分查找只需要大概 20 次就可以了。

对于二分查找来说，我们事先将待查找的数据进行了排序，通过排序使得数据有序化，从而使得查找的过程更高效。而这样的一个查找过程我们可以构造出一个树的形式来表述。

![](https://images.gitbook.cn/2020-07-27-015809.png)

查找树在效率上和二分查找是一样的，但其最大的优点是在树里面新增和删除元素要比操作数组要方便的多，所以说，树这种结构不仅查找效率高，而且可以很好的实现动态查找。

从查找这个方面来看，我们有必要去使用树这种数据结构，当然，树的应用不仅仅局限于查找，其在计算机世界应用十分广泛。下面就让我们来走进树这种数据结构吧。

### 2\. 树的定义

上面我们从二分查找引出了二叉树这种数据结构，实际上，二叉树是树这种数据结构的一种形式（也可以说是最常用的）。说到树这种数据结构，其定义如下：树是由
n（n>0）个有限节点组成一个具有层次关系的集合。之所以取名为“树”是因为这种数据结构看起来像一棵倒过来的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

  * 每个节点都只有有限个子节点或无子节点；
  * 没有父节点的节点称为根节点；
  * 每一个非根节点有且只有一个父节点；
  * 除了根节点外，每个子节点可以分为多个不相交的子树；
  * 树里面没有任何的环路。

对于任意一个概念，都会有很多的术语以及定义，对于树这种数据结构也不例外。下面我们就通过一个实例来介绍一下树的一些常用的术语。

![](https://images.gitbook.cn/2020-07-27-015810.png)

### 3\. 二叉树定义

二叉树是最常用的一种树的特殊形式形式，其不管是在实际应用和面试考察中，都占有重要的比重。在讲解其他复杂的树，如红黑树之前，先让我们走进二叉树吧。

二叉树是每个节点最多只有两棵子树的树结构，所以二叉树中不存在度大于 2
的节点。注意，二叉树不是只有两颗子树，而是最多有。在二叉树中，没有父节点的节点称为根节点（root），如图中红色节点所示，如果一个节点没有子树，那么我们称其为叶子节点（leaf
node），如图中蓝色节点所示。

![](https://images.gitbook.cn/2020-07-27-015811.png)

如果一颗二叉树，其所有的分支节点都有左子树和右子树，并且所有的叶子节点都在同一层上。这样的二叉树称之为满二叉树。

#### **3.1 完全二叉树**

完全二叉树是由满二叉树引出来的。对于深度为 K 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 K 的满二叉树中编号从 1 至 n
的结点一一对应时称之为完全二叉树。完全二叉树具备的这个特点有什么意义呢？我们为什么要单独赋予这类二叉树一个新的名词呢？下面的“二叉树的存储结构”一小结将会解决你的这个疑问。

### 4\. 二叉树的存储结构

本节我们讨论的是二叉树是如何存储于内存中的。一般来说，二叉树的存储结构有两种，顺序存储结构和链式存储结构。

#### **4.1 顺序存储结构**

如果一棵树不是二叉树，那么想要用数组来存储是很困难的。但是，如果一棵树是二叉树，并且这一棵树是完全二叉树的时候，我们很容易就可以用数组来存储它。如下图所示，我们可以很容易的把一颗树放入数组中去。

![](https://images.gitbook.cn/2020-07-27-015813.png)

我们从图中可以看出，对于节点 B，其存储位置下标为 2，其父节点存储位置下标为 1，其左孩子和右孩子存储位置下标为 4 和
5；同样，经过归纳总结，我们可以得到下面的结论：

  * 非根结点（序号 i>1）的父结点的序号是 $i/2$（向下取整）；
  * 结点（序号为 i）的左孩子结点的序号是 $2_i$（$2_i ≤ n$）；
  * 结点（序号为 i）的右孩子结点的序号是 $2_i+1$（ $2_i +1 ≤ n$）。

完全二叉树可以用数组较好的实现，那么一般的二叉树呢？

其实，一般的二叉树也可以采用这种结构，如下图所示

![](https://images.gitbook.cn/2020-07-27-015814.png)

#### **4.2 链式存储结构**

我们可以将二叉树的节点定义为如下形式：

    
    
    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }
    

![](https://images.gitbook.cn/2020-07-27-015816.png)

但是，如果某棵二叉树是一棵完全二叉树，情况就不同了。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拿出来说的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。用数组存储完全二叉树比链式存储好的地方就在于其节省内存。

下面我们给出的最近几年各大公司的关于二叉树的笔试面试题，我们会给出一些简单的讲解，帮助大家更好的理解二叉树这一知识。

### 5\. 小试牛刀

#### **5.1 小米 2020 年校招:完全二叉树的节点数**

**题目**

> 高度为 7 的完全二叉树的节点总数不可能是：（）
>
>   1. 128
>   2. 192
>   3. 255
>   4. 256
>

**题解**

这题考察了完全二叉树的概念，因为完全二叉树的高度为 7，所以其节点个数必然会大于 127（1+2+4+8+16+32+64），节点总数小于等于
255（1+2+4+8+16+32+64+128）；高度为 7 的完全二叉树的节点总数不可能为 256。

#### **5.2 美团 2019 年校招：什么样的二叉树适合用数组来存储**

**题目**

> 什么样的二叉树适合用数组来存储？

**题解**

如果某棵二叉树是一棵完全二叉树，那用对其用数组来存储无疑是最节省内存且最优的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是完全二叉树要求最后一层的子节点都靠左的原因。

#### **5.3 滴滴 2019 年校招：构建多少种二叉树**

**题目**

> 给定一个数组，比如 1，2，3，4，5。可以构建出多少种不同的二叉树？

**题解**

既然二叉树的数据可以放在数组里面，那么问题可以简化为数组内的元素有多少种组合方式，这样的话，就是 n!

#### **5.4 阿里 2019 年校招：二叉树深度**

**题目**

> 求出一个二叉树的深度。

**题解**

首先我们必须明确二叉树的深度的定义，理解了这一定义我们很容易可以写出递归的形式的代码。

    
    
    public int GetTreeDepth(TreeNode root)
    {
        if (root == null)
        {
            return 0;
        }
    
        int left = GetTreeDepth(root.LeftChild);
        int right = GetTreeDepth(root.RightChild);
    
        return left >= right ? left + 1 : right + 1;
    }
    

#### **5.5 百度 2020 年校招：编程求完全二叉树节点**

**题目**

> 给出一个完全二叉树，求出其节点个数。

**题解**

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最后一层的节点全部靠向左边。

所以，我们可以将问题简化为计算完全二叉树最后一层有多少个节点。

    
    
    class Solution {
      public int computeDepth(TreeNode node) {
        int d = 0;
        while (node.left != null) {
          node = node.left;
          ++d;
        }
        return d;
      }
      public boolean exists(int idx, int d, TreeNode node) {
        int left = 0, right = (int)Math.pow(2, d) - 1;
        int pivot;
        for(int i = 0; i < d; ++i) {
          pivot = left + (right - left) / 2;
          if (idx <= pivot) {
            node = node.left;
            right = pivot;
          }
          else {
            node = node.right;
            left = pivot + 1;
          }
        }
        return node != null;
      }
    
      public int countNodes(TreeNode root) {
    
        if (root == null) return 0;
    
        int d = computeDepth(root);
    
        if (d == 0) return 1;
        int left = 1, right = (int)Math.pow(2, d) - 1;
        int pivot;
        while (left <= right) {
          pivot = left + (right - left) / 2;
          if (exists(pivot, d, root)) left = pivot + 1;
          else right = pivot - 1;
        }
    
        return (int)Math.pow(2, d) - 1 + left;
      }
    }
    

### **6\. 小结**

  * 二分查找
  * 从二分查找引出二叉树：从一个侧面讲述我们为什么设计出树这种数据结构
  * 树以及二叉树的定义
  * 二叉树的存储结构：数组和链表存储

### 7\. 课后思考

今天我讲了二叉树的一些理论以及存储方法。可以看到，本文通过完全二叉树这个特殊的二叉树串联起来了二叉树的理论和存储结构这两个部分，那么，你知道如何通过编程，来判断一棵树是不是完全二叉树呢？

欢迎留言和我分享，我会第一时间给你反馈。

