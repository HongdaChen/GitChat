### 1\. 每一种数据结构都有它的使命

正如链表可以构成缓存容器实现数据的暂时存放，B+、B- 树更多的被用来作为数据库搜索引擎的索引提高读取效率，例如：MySQL 的 InnonDB 用 B+
树结构做索引；MySQL 的 MyISAM 引擎以及 MongoDB 用 B- 树作为索引。

#### **1.1 为什么在数据库中使用索引？**

假设您需要在文件中存储数字列表，然后在该列表中搜索给定的数字。最简单的解决方案是将数据存储在数组中，并在出现新值时附加值。但是，如果需要检查数组中是否存在给定值，则需要一个接一个地搜索所有数组元素，并检查给定值是否存在。如果足够幸运，您可以在第一个元素中找到给定的值。在最坏的情况下，该值可以是数组中的最后一个元素。我们可以将这种最坏情况表示为
O(n) 的渐近符号。这意味着，如果您的数组大小最大为“n”，则需要进行“n”次搜索才能在数组中找到给定值。

那如果是您，您会如何改善？最简单的解决方案是对数组进行排序，然后使用二进制搜索来找到值。每当您将值插入数组时，它都应保持顺序。从数组中间选择一个值开始搜索。然后将所选值与搜索值进行比较。如果所选值大于搜索值，则忽略数组的左侧，并在右侧搜索值，反之亦然。

![](https://images.gitbook.cn/5d2d9760-ed35-11ea-8951-073e8ef6665a)

在这里，我们尝试从数组 2、6、34、45、56、79 和 99 中中搜索
56，该键已按排序顺序。如果您进行常规搜索，则搜索将花费五个时间单位，因为该元素位于第五位置。但是在二进制搜索中，只需要进行三个搜索。

是不是看起来很熟悉？这其实就是一棵二叉树，这是 B
树的最简单形式。对于二叉树，我们可以使用指针而不是将数据保留在已排序的数组中。从数学上讲，我们可以证明二叉树的最坏情况搜索时间是
O(log(n))。数据库的索引就是利用了这一原理，大大的加速了数据查询的速度。

### 2\. B+ 树在数据库中的应用

B+ 树目前在工业上主要用于 MySQL 的 InnoDB 引擎索引。

当 B+ 树作为数据库索引时，此数据结构不仅具有键，而且具有与该键关联的值，因此变得有点复杂。该值是对实际数据记录的引用。键和值一起称为有效负载。

我们举个例子：

![](https://images.gitbook.cn/9a7b8fa0-ed35-11ea-b07d-070a5bf07ad2)

首先，数据库为每个给定记录创建唯一的随机索引（或主键），并将相关行转换为字节流。然后，它将每个密钥存储在 B+
树上并记录字节流。这里，随机索引用作索引的键。密钥和记录字节流统称为有效负载。产生的 B+ 树可以表示如下：

![](https://images.gitbook.cn/ed356310-ed35-11ea-a8b1-85fbc69c1761)

图中的 p 节点为指向子节点的指针。图中的每个节点称为页，页就是我们经常说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合
MySQL 中索引的底层数据结构。

在这里，您可以看到所有记录都存储在 B+ 树的叶节点中，索引用作创建 B+
树的键。没有记录存储在非叶子节点上。每个叶节点都引用树中的下一条记录。数据库可以使用索引执行二进制搜索，也可以通过仅遍历叶节点来搜索每个元素来进行顺序搜索。如果不使用索引，则数据库将读取每个记录以查找给定记录。

B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B- 树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，InnoDB
中页的默认大小是 16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的
IO 次数又会再次减少，数据查询的效率也会更快。

另外，B+ 树的阶数是等于键值的数量的，如果我们的 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储
1000×1000×1000=10 亿个数据。一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。

### 3\. B- 树在数据库中的应用

目前 B- 树主要在 MongoDB 中使用较为广泛。MongoDB 是一种 NoSQL，也存储在磁盘上，被设计用在 数据模型简单，性能要求高的场合。

B+ 树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 logn。而 B- 树查询时间复杂度不固定，与 key
在树中的位置有关，最好为 O(1)，而尽可能少的磁盘 IO 是提高性能的有效手段。MongoDB 是聚合型数据库，而 B- 树恰好 key 和 data
域聚合在一起。

我们来看下 B- 树对应图一中的表数据展示出的数据结构如何：

![](https://images.gitbook.cn/3bdb5f20-ed3a-11ea-816b-87f82de6664d)

可以看到每个节点下面都存储了对应的数据，这样就可以直接在当前节点取出数据，不用像 B+ 树一样必须要找根节点，才能找到对应的数据。

B- 树有如下特点：

  * 所有键值分布在整颗树中；
  * 任何一个关键字出现且只出现在一个结点中；
  * 搜索有可能在非叶子结点结束；
  * 在关键字全集内做一次查找，性能逼近二分查找。

### 4\. 为什么数据库不用红黑树结构作为索引？

总的来说，B/B+ 树是为了磁盘或其它存储设备而设计的一种平衡多路查找树（相对于二叉，B 树每个内节点有多个分支），与红黑树相比，在相同数据情况下，一棵
B/B+ 树的高度远远小于红黑树的高度，这样在磁盘查找数据时，磁臂定位次数也就越少，查询效率越高。B/B+ 树上操作的时间通常由存取磁盘的时间和 CPU
计算时间这两部分构成，而 CPU 的速度非常快，所以 B 树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下 B 树的高度越小，磁盘 I/O
所花的时间越少。

### 5\. 为什么数据库不用 Hash 表作为索引？

有的人会说 Hash 存储，它的索引是 O(1)，速度不是比 B 树更快吗，为什么不用 Hash 存储？

其实这个问题很简单，我们需要从业务和性能两点进行考虑：

  * 如果单次查询只查询一条数据，的确是 Hash 存储来的更快，但是往往业务中更多的是区间查询，甚至批量的查询，这时 B+树的优势就体现出来，因为它的叶节点有链表结构，支持区间查询，效率会比 Hash 查询效率更高。
  * 从内存上说，如果一张表有几千万的数据，是不能一次性将所有 Hash 值导入内存的，但是 B 树可以分批加载。

### 6\. B+ 树中，将叶子节点串起来的链表，是单链表还是双向链表？为什么？

对于 B+ tree 叶子节点，是用双向链表还是用单链表，得从具体的场景思考。我想，大部分同学
在开发中遇到的数据库查询，都遇到过升序或降序问题，即类似这样的 SQL：

    
    
    select name,age, ... from w here uid > startValue and uid < endValue order by uid asc（或者 desc）
    

此时，数据底层实现有两种做法：

  * 保证查出来的数据就是用户想要的顺序
  * 不保证查出来的数据的有序性，查出来之后再排序

以上两种方案，不加思考，肯定选第一种，因为第二种做法浪费了时间（如果选用内存排序，还是考虑
数据的量级）。那如何能保证查询出来的数据就是有序的呢?单链表肯定做不到，只能从头往后遍历， 再想想，只能选择双向链表了。

此时，可能有的同学又问了：双向链表，多出来了一倍的指针，不是会
多占用空间嘛？答案是肯定的。可是，我们再细想下，数据库索引本身都已经在磁盘中了，对于磁盘来说，这点空间已经微不足道了，用这点空间换来时间肯定划算呀。

顺便提一下：在实际工程应用中，双向链表应用的场景非常广泛，毕竟能大量减少链表的遍历时间。

### 7\. 小结

  * B+ 树
  * B- 树
  * 为什么数据库不用红黑树结构作为索引？
  * 为什么数据库不用 Hash 表作为索引？

### 8\. 课后思考

是否可以无限增加 B 树的路数以降低树的高度来获得更高的效率呢？欢迎留言和我分享，我会第一时间给你反馈。

