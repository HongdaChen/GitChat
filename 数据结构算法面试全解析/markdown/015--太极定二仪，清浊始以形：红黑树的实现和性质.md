我们在前面的章节中讲述了平衡二叉查找树，也就是叶节点高度差的绝对值不超过 1，并且左右两个子树都是一颗平衡树。最早被发明的是平衡二叉查找树是 AVL
树，后面红黑树才被发明。

AVL 树在每次的插入和删除时都要进行调整，会比较耗时。所以 AVL 树就不适合应用于频繁插入、删除的数据集。至于红黑树，在这方面相较于 AVL
树会有一些优势，其在插入、删除、查找等各种操作的性能都比较稳定。对于工程应用，需要面对各种异常情况，为了支撑工业级的应用，我们会更加倾向于使用性能更为稳定的红黑树。

红黑树之所以会被叫做这个名称，是因为其在每个结点上增加了一个存储位表示结点的颜色，可以是 RED 或者
BLACK。通过对任何一条从根到叶子的路径上各个着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。所以，红黑树能保证在最坏情况下，基本操作的运行时间为
O(logN)。在实际场景中，Java 的 HashMap、TreeMap、TreeSet 等均使用了红黑树进行数据的存储的。

红黑树在实际工程中应用如此广泛，那么为什么红黑树会有这样的优势呢，接下来由我给大家一一道来。

### 1\. 红黑树的性质

红黑树也叫做 R-B Tree（Red-Black
Tree），是一种不怎么严格的平衡二叉查找树。为了防止有些同学对平衡二叉查找树的定义有些遗忘，我们再回顾一下平衡二叉查找树。

> 平衡二叉查找树：二叉树中任意一个节点的左右子树高度相差不能大于 1。

红黑树除了了二叉查找树的一般要求之外，还拥有一些特殊的 R-B Tree 额外限定：

  * 每个节点是红色或者黑色
  * 根节点是黑色的
  * 父节点，子节点之间不能出现连续两个的红节点
  * 任何一个节点向下遍历到叶子节点，所经过的黑节点个数必须相等
  * 空节点被认为是黑色

我相信大家看到这些约束性质都很头大，这都什么跟什么？！

这五条限制的加入，强制了红黑树的关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长！

这样的关键性质就导致了红黑树大致是平衡的。因为查找、插入、删除某个节点的最坏情况时间都要求与树的高度成比例。

请大家记住上面的这些定义，因为我们在下面的查找、插入、删除等操作中会反复涉及到这些概念。

我相信我们的读者朋友中有很大一部分是准备找工作、或者找新工作的朋友们，所以我们在这里准备了太长不看系列，想快速记忆红黑树与其他树的区别，请大家记忆下面的表格：

树的类别 | 概念 | 查找代价 | 插入代价 | 删除代价 | 效率总结  
---|---|---|---|---|---  
二叉查找树-BST | 二叉查找树又称为二叉搜索树： | O(N) | O(logN) | O(logN) | 查找最好时间复杂度
O(logN)，最坏时间复杂度 O(N)。插入删除操作算法简单，时间复杂度与查找差不多。  
平衡二叉查找树-AVL | AVL 树是将不平衡的二叉查找树改为平衡的二叉查找树得到的 | O(logN) | O(logN) | O(2logN) |
查找的时间复杂度维持在 O(logN)，不会出现最差的情况，AVL 树在执行每个插入操作时最多需要 1 次旋转，其时间复杂度在 O(logN)左右。AVL
树在执行删除时代价比较大，执行每个删除操作的时间复杂度需要 O(2logN)  
红黑树-R-B Tree |  | O(logN) | O(logN) | O(logN) | 查找效率最好情况下时间复杂度为
O(logN)，但是在最坏情况下比 AVL 稍微差一点，但是也远远比 BST 好。插入和删除操作改变树的平衡性的概率要远远小于 AVL（RBT
不是高度平衡的。）因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个节点最多只需要旋转 2 次，删除最多只需要旋转 3 次（小于 AVL
的删除操作所需要的旋转次数）。虽然变色操作的时间复杂度在 O(logN)，但是实际上，这种操作由于简单所需要的代价很小。  
  
### 2\. 红黑树及其操作的实现

接下来我们将从红黑树的查找、插入、删除等基本操作将 Java 的具体实现教给大家。在实现具体操作之前，我们需要先对红黑树的节点进行定义。

红黑树节点定义：

    
    
    class  Node<T>{
       public  T value;
       public   Node<T> parent;
       public   boolean isRed;
       public   Node<T> left;
       public   Node<T> right;
    }
    

从上面的定义可以看出，红黑树节点的关键信息，我们都给出了：左节点，右节点、父节点、颜色属性、节点的值。

接下来开始介绍红黑树的基本操作。红黑树的三个基本操作是由红黑树的左旋，右旋组成，所以现在先介绍左旋，右旋操作。同时我们在介绍这些操作时，顺带编了一些顺口溜，方便大家记忆。

旋转操作的目的是使树的颜色符合定义，使其保持平衡。所谓的左旋、右旋。

**左旋** ：待旋转的节点从右边上升到父节点。

![左旋.png](https://images.gitbook.cn/9cd507a0-e37f-11ea-9fb8-5b88ea51156d)

**右旋** ：待旋转的节点从左边上升到父节点。

![右旋.png](https://images.gitbook.cn/b17c3340-e37f-11ea-b721-5144ef2004ae)

#### **2.1 查找操作**

顺口溜：相等即当、小于即右。大于即左。

当进行查找操作时，先与当前节点进行比较：

  * 如果相等的话就返回当前节点
  * 如果小当前节点的话就继续查找当前节点的左节点
  * 如果大于当前节点的话就继续查找当前节点的右节点

直到当前节点指针为空或者找到对应的节点，程序查找结束。

    
    
    T  key = a search key
    Node root = point to the root of a R-B Tree
    
    
    while(true){
        if(root==null){
            break;
        }
        if(root.value.equals(key)){
            return root;
        }
        else if(key.compareTo(root.value)<0){
            root = root.left;
        }
        else{
            root = root.right;
        }
    }
    return null;
    

#### **2.2 插入操作**

红黑树面临新节点的插入操作，需要注意两个问题：树的平衡、颜色要求。新的的节点插入之后需要按照红黑树的性质需要对树进行旋转操作以及颜色的修正。新插入的节点是红色的，插入调整颜色的操作如果遇到父节点的颜色是黑色的，那么修复就结束了。只有在父节点为红色节点的时候需要插入修复操作。

顺口溜：

  * 不变色是父暗
  * 父红，叔不空，叔祖与父换
  * 父红，右叔空，右旋，祖与父换
  * 叔空，不在一线，旋一线，按 3 换

插入修复操作分为以下三种情况，而且要求新插入的节点的父节点也是红色的。

**情形 1：叔叔节点是红色**

这种情况下插入新的节点，具体操作是将父节点，叔叔节点与祖父节点的颜色互换。这样就会符合红黑树的定义了（保持了高度的平衡，同时树的颜色也满足红黑树的第三，第四点的定义），在下面的操作中，操作完成之后节点
A 变成了新的节点。如果节点 A 的父节点还不是黑色的话，就重复前面的操作。

![插入 1.png](https://images.gitbook.cn/e38fb820-e37f-11ea-988c-5bdd79e3c26c)

**情形 2：叔叔节点为空，同时祖父节点、父节点和新节点处于一条斜线上**

将节点 B 进行右旋，并且和父节点 A 互换颜色。通过这个调整操作。红黑树的高度和颜色就会符合红黑树的定义了。如果节点 B 和节点 C
都是右节点的话，只要将操作变成左旋就可以了。

![插入 2.png](https://images.gitbook.cn/f577c3c0-e37f-11ea-a768-6778261f8e2b)

**情形 3：叔叔节点为空，同时祖父节点、父节点和新节点不处于一条斜线上**

将节点 C 进行左旋，这样就从上面 **情形 3** 变成了 **情形 2** ，然后针对情形 2
进行操作处理就行了。如果树的结构是下面的镜像结构，只要将对应的左旋变成右旋，右旋变成左旋就可以了。

![插入 3.png](https://images.gitbook.cn/078a3ac0-e380-11ea-9224-c50b0cd8920a)

相信大家经过我上面这一番讲解，大家都懵逼了，这什么鬼，什么左旋右旋，完全记不住啊。OK，接下来请大家再回过头来看我在这一章开头写给大家的顺口溜，这是我给大家一些速记的技巧，相信大家只要掌握这些记忆技巧，一定会对这些问题，应对自如。

    
    
    Node node = create a new node with specify value
    Node root = point the root node of a BST
    Node parent = null;
    
    //find the parent node to append the new node
    while(true){
       if(root==null)break;
       parent = root;
       if(node.value.compareTo(root.value)<=0){
          root = root.left;  
       }else{
          root = root.right;
       } 
    }
    if(parent!=null){
       if(node.value.compareTo(parent.value)<=0){//append to left
          parent.left = node;
       }else{//append to right
          parent.right = node;
       }
    }
    

插入后对颜色进行调整是向根节点回溯的操作，只要涉及到的节点都符合红黑树的定义，颜色调整的操作就结束了。由于在情形 1
中会将父节点，叔叔节点和祖父节点调换颜色，有可能会导致祖父节点不平衡（具体参考红黑树的第三个定义）。这个时候需要将祖父节点作为起点进行调节，即向上回溯。

祖父节点调节之后如果还是遇到祖父节点的祖父节点的颜色问题，颜色调整操作会继续向上进行回溯。直到根节点为止。由于根节点按照定义来说必须是黑色的。在向上回溯的过程中，针对插入的第
3 个情形进行调节，直到符合红黑树的定义为止。直到涉及的节点都符合红黑树的定义，颜色调整操作结束。

如果上面插入第 3 个情形如果对应的操作是右子树上，做对应的镜像操作就行了。

#### **2.3 删除操作**

删除操作需要先按照平衡二叉树的方式进行删除，删除操作会删除对应的节点，如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除的节点为止。删除后就需要做删除修复操作，使得树符合红黑树的定义，符合定义的红黑树高度是平衡的。在删除操作中，颜色调整操作在遇到被删除的节点是红色节点或者回溯到根节点时，颜色调整操作完毕。

在删除操作中是针对删除黑色节点才有的，当黑色节点被删除之后，会让整个树都不符合红黑树的第四个定义。需要做的处理是从兄弟节点上借调黑色节点过来，如果兄弟节点没有黑色节点可以借调的话，就只能往上回溯了，将每一级的黑色节点点数减去一个，使得整个树符合红黑树的定义。

![删除流程图.png](https://images.gitbook.cn/21d1fb70-e380-11ea-988c-5bdd79e3c26c)

由此可以看出删除操作的总体思路就是从兄弟节点那儿借调黑色节点使得整个树保持局部的平衡，如果局部的平衡达到了，然后再看整体的树是否平衡，如果不平衡就接着向上回溯进行调整。

顺口溜：

  * 兄红，兄升，借调孩子
  * 兄黑，兄子黑，兄变色
  * 兄黑，兄左子黑，兄变色，兄树右旋
  * 兄黑，右子红，删除，左旋

我们可以将红黑树的删除颜色调整操作可以分为四种情况（删除黑色节点之后）：

  * 待删除的节点的兄弟节点是红色的节点
  * 待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的
  * 待调整颜色的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。
  * 待调整颜色的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则就是对应的就是左节点是红色的。

**情形 1：待删除的节点的兄弟节点是红色的节点**

由于兄弟节点是红色节点的时候，无法借调黑色节点，所以需要将兄弟节点提升到父亲节点，由于兄弟节点是红色的，根据红黑树定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。

情形 1 这样转换之后，就会变成后面情形 2，情形 3 或者情形 4 进行处理了。上升操作需要对 C
节点进行左旋操作，如果是镜像结构的树，只需要做对应的右旋操作就行了。

之所以做情形 1 的操作是因为兄弟节点是红色的，无法借到一个黑色节点来填补删除的黑色节点。

![删除 1.png](https://images.gitbook.cn/3ffebe80-e380-11ea-9198-d76e451843ac)

**情形 2：待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的**

情形 2
的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点的子节点都是黑色的，所以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父亲节点
A 变成新的的节点，继续向上回溯，调整颜色，直到整个树的颜色符合红黑树的定义为止。

情形 2
这种情况之所以要将兄弟节点变成红色，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合红黑树的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变成红色之后，达到了局部平衡，但是对于祖父节点来说是不符合红黑树第
4 个定义的。这样就需要回溯父亲节点，接着进行颜色调整操作。

![删除 2.png](https://images.gitbook.cn/5217ec40-e380-11ea-91d9-89a6127f3a5c)

**情形 3：待调整颜色的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的**

情形 3 的删除操作是一个中间步骤，它的目的是将左边的红色节点借调过来，这样就可以转换为情形 4 的状态了，在情形 4 状态下降 D，E
节点都借调过来，通过将两个节点都变成黑色来保证红黑树的整体平衡。

之所以说情形 3 是一个中间状态，是因为根据红黑树的定义来说，下图不是平衡的，它是通过情形 2 操作完之后向上回溯出现的状态。之所以会出现情形 3
和后面的情形 4，是因为可以通过借助侄子节点的红色，变成黑色来符合红黑树的第 4 个定义。

![删除 3.png](https://images.gitbook.cn/7d888740-e380-11ea-9198-d76e451843ac)

**情形 4：待调整颜色的节点的兄弟节点是黑色的节点，且右子节点是红色的**

情形 4
的操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑节点的目的，这样的话，整个树还是符合红黑树的定义的。

情形 4 这种情况的发生只有在待删除的节点的兄弟节点为黑色，且子节点不全部为黑色，才有可能借调到两个节点来做黑色节点使用，从而保持整个树都符合红黑树的定义。

![删除 4.png](https://images.gitbook.cn/72640ce0-e380-11ea-9224-c50b0cd8920a)

接下来总结一下红黑树的删除操作，红黑树的删除操作是最复杂的操作，复杂就复杂在当删除黑色节点的时候，如何从兄弟节点去借调节点，从而保持树的颜色符合定义。由于红色的兄弟节点是无法借调出黑色节点的，这样只能通过选择操作让他上升到父亲节点，而由于是红色节点，所以子节点就是黑色的，可以借调。

对于兄弟节点是黑色节点的可以分成三种情况来处理。当所有的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变成红色，这样局部的红黑树颜色就符合红黑树的定义了，但是整个树不一定是符合红黑树定义的，需要往上回溯继续调整。

对于兄弟节点的子节点为左边红色右边黑色、全部为红色、右边红色左边黑色这些情况，可以将前面的情况通过选择转换为后一种情况，在后面一种情况下，因为兄弟节点为黑色，兄弟节点的右节点为红色，可以借调出两个节点出来做黑色节点，这样可以保证删除了黑色节点，整个树还是符合红黑树定义的，因为黑色节点的个数没有改变。

红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到根节点，这时删除的颜色调整操作结束。

红黑树完整的代码实现还是特别多的，本文仅仅给出了红黑树的左旋和右旋实现，其余的比如说删除等操作在这里不给出了，大家可以自己尝试写一下。

    
    
        private void rotateLeft(RBTreeNode<T> node){
            RBTreeNode<T> right = node.getRight();
            if(right==null){
                throw new java.lang.IllegalStateException("right node is null");
            }
            RBTreeNode<T> parent = node.getParent();
            node.setRight(right.getLeft());
            setParent(right.getLeft(),node);
    
            right.setLeft(node);
            setParent(node,right);
            if(parent==null){
                root.setLeft(right);
                setParent(right,null);
            }else{
                if(parent.getLeft()==node){
                    parent.setLeft(right);
                }else{
                    parent.setRight(right);
                }
                setParent(right,parent);
            }
        }
    
        private void rotateRight(RBTreeNode<T> node){
            RBTreeNode<T> left = node.getLeft();
            if(left==null){
                throw new java.lang.IllegalStateException("left node is null");
            }
            RBTreeNode<T> parent = node.getParent();
            node.setLeft(left.getRight());
            setParent(left.getRight(),node);
    
            left.setRight(node);
            setParent(node,left);
    
            if(parent==null){
                root.setLeft(left);
                setParent(left,null);
            }else{
                if(parent.getLeft()==node){
                    parent.setLeft(left);
                }else{
                    parent.setRight(left);
                }
                setParent(left,parent);
            }
        }
    

### 3\. 大厂面试题

学习了上面的这些内容，接下来我们通过几道大厂真题，带你真正掌握这些知识。

#### **3.1 哔哩哔哩 2019 秋招技术岗（前端、运维、后端、移动端）第一套笔试题**

问：以下哪个数据结构底层是用红黑树实现的？（ ）

A. vector  
B. list  
C. map  
D. deque

答：map 是红黑树实现的。vector 是顺序表，表示的是一块连续的内存。list 是双向链表，在内存中不一定连续。deque
也是顺序表，但是在内存空间中是双开口的内存存储机制。

#### **3.2 快手 2020 年软件工程师笔试题**

问：采用插入方式构建一颗大小为 n 的红黑树的时间复杂度是多少？

A. O(log(n))  
B. O(n)  
C. O(n*log(n))  
D. O(n^2)

答：由前面学习到的知识可以知道，插入一个元素到红黑树的时间为 log(n)，其中 n 为当前红黑树的元素个数；因此，采用插入方式构建元素个数为 n
的红黑树的时间复杂度为 nlog(n)。

#### **3.3 腾讯 2016 研发工程师笔试题（三）**

问：关于红黑树和 AVL 树，以下哪种说法不正确？

A. 两者都属于自平衡二叉树  
B. 两者查找、插入、删除的时间复杂度相同  
C. 包含 n 个内部节点的红黑树的高度是 O(log(n))  
D. JDK 的 TreeMap 是一个 AVL 的实现

答：红黑树和 AVL 树都属于自平衡二叉树；两者查找、插入、删除的时间复杂度相同；包含 n 个内部结点的红黑树的高度是 log(n)；TreeMap
是一个红黑树的实现，能保证插入的值保证排序。

### 4\. 小结

这一章结束了，我们再回顾下涉及到的知识点，敲黑板，后面是要考到的哦。

红黑树的五个性质：

  * 每个节点是红色或者黑色
  * 根节点是黑色的
  * 父节点，子节点之间不能出现连续两个的红节点
  * 任何一个节点向下遍历到叶子节点，所经过的黑节点个数必须相等
  * 空节点被认为是黑色

红黑树的三种操作：查找、插入、删除。

红黑树查找顺口溜：

> 相等即当、小即右。大即左。

红黑树插入顺口溜：

  * 不变色是父暗
  * 父红，叔不空，叔祖与父换
  * 父红，右叔空，右旋，祖与父换
  * 叔空，不在一线，旋一线，按 3 换

红黑树删除顺口溜：

  * 兄红，兄升，借调孩子
  * 兄黑，兄子黑，兄变色
  * 兄黑，兄左子黑，兄变色，兄树右旋
  * 兄黑，右子红，删除，左旋

### 5\. 课后总结

本章涉及到的知识点主要是红黑树的基本性质以及三大基本操作。证明红黑树的高度最多为 2logN，并证明这个界实质上不能再降低。

欢迎留言和我分享，我会第一时间给你反馈。

