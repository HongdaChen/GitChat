在数据库系统的使用过程当中，数据的查询是使用最频繁的一种数据操作。基本的查询算法当然是顺序查找（linear
search），遍历表然后逐行匹配行值是否等于待查找的关键字，其时间复杂度为 O(n)。但时间复杂度为 O(n)
的算法规模小的表，负载轻的数据库，也能有好的性能。 但是数据增大的时候，时间复杂度为 O(n) 的算法显然是糟糕的，性能就很快下降了。

那么，应用在数据库中的查找是什么呢？我们所熟悉的二分查找，二叉树查找等都有自身的特点只能应用于特定数据结构场景下的查找，二分查找要求数据有序，二叉树查找只能应用于二叉查找树。而数据库系统，则是使用了一个叫索引的数据结构来进行查找，那么索引的底层原理是什么呢？下面将详细讲解，新的知识点
B- 树和 B+ 树。

B-tree 树即 B 树，B 即 Balanced，平衡的意思。在正式介绍 B-树之前，先介绍下二叉搜索树。

### 1\. 平衡二叉树

**概念**

平衡二叉树是基于二分法的一种查找速度很快的二叉树结构。

  * 所有非叶子结点至多拥有两个子节点（Left 和 Right）；
  * 所有结点存储一个关键字；
  * 非叶子结点的左指针指向小于其当前节点的子树，右指针指向大于其当前节点的子树。

如：

![enter image description
here](https://images.gitbook.cn/aeed9250-e8d3-11ea-8115-8d7d715b7847)

二叉搜索树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左子节点；如果比结点关键字大，就进入右子节点；如果左子节点或右子节点的指针为空，则报告找不到相应的关键字。

如果二叉搜索树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么 B
树的搜索性能逼近二分查找。但它比连续内存空间的二分查找的优点是，改变二叉搜索树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销。

如：

![enter image description here](https://images.gitbook.cn/e1abd620-e8d3-11ea-
ba73-438fd3ade139)

但二叉搜索树在经过多次插入与删除后，有可能导致不同的结构：

![enter image description
here](https://images.gitbook.cn/c60441e0-e8d4-11ea-8e73-7936a03296ed)

右边也是一个二叉搜索树，但它的搜索性能已经是线性的了，同样的关键字集合有可能导致不同的树结构索引。所以，使用二叉搜索树还要考虑尽可能让 B
树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题。

实际使用的二叉搜索树都是在原二叉搜索树的基础上加上平衡算法，即“平衡二叉树”。如何保持 B
树结点分布均匀的平衡算法是平衡二叉树的关键，平衡算法是一种在二叉搜索树中插入和删除结点的策略。

总结下来平衡二叉树的特点：

  * 非叶子节点最多拥有两个子节点
  * 非叶子节值大于左边子节点、小于右边子节点
  * 树的左右两边的层级数相差不会大于 1
  * 没有值相等重复的节点

### 2\. B 树（B- 树）

**概念**

是一种多路搜索树（并不是二叉的），属于多叉树又名平衡多路查找树（查找的路径不止两个）。

**规则**

  * 定义任意非叶子结点最多只有 M 个子节点；且 M>2（M=2 则是二叉树，M=3 则是三叉树）；
  * 根结点的儿子数为 [2, M]；
  * 除根结点以外的非叶子结点的子树节点为 [M/2, M]；
  * 每个结点存放至少 M/2-1（取上整）和至多 M-1 个关键字；（至少 2 个关键字）
  * 非叶子结点的关键字个数=指向子节点的指针个数-1；
  * 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且 K[i] < K[i+1]；
  * 非叶子结点的指针：P[1], P[2], …, P[M]；其中 P[1] 指向关键字小于 K[1] 的子树，P[M]指向关键字大于 K[M-1] 的子树，其它 P[i] 指向关键字属于 (K[i-1], K[i]) 的子树；
  * 所有叶子结点位于同一层。

如：（M=3）

![enter image description
here](https://images.gitbook.cn/10d27ed0-e8d5-11ea-b7b2-7fafe63b7d58)

**B- 树的搜索**

从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的子节点指针为空，或已经是叶子结点。

**B- 树的插入节点流程**

B- 树的特性：

  * 关键字集合分布在整颗树中
  * 任何一个关键字出现且只出现在一个结点中
  * 搜索有可能在非叶子结点结束
  * 其搜索性能等价于在关键字全集内做一次二分查找
  * 自动层次控制

由于限制了除根结点以外的非叶子结点，至少含有 M/2 个儿子，确保了结点的至少利用率，其最底搜索性能为：

![enter image description
here](https://images.gitbook.cn/412abf20-e8d5-11ea-8115-8d7d715b7847)

其中：

  * M 为设定的非叶子结点最多子树个数，N 为关键字总数；
  * 所以 B- 树的性能总是等价于二分查找（与 M 值无关），也就没有 B 树平衡的问题；
  * 由于 M/2 的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占 M/2 的结点；删除结点时，需将两个不足 M/2 的兄弟结点合并。

### 3\. B+ 树

**概念**

B+ 树是 B- 树的变体，也是一种多路搜索树， 更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。

**规则**

  * B+ 跟 B 树不同 B+ 树的 **非叶子** 节点不保存关键字记录的指针，只进行数据索引，这样使得 B+ 树每个 **非叶子** 节点所能保存的关键字大大增加。
  * B+ 树 **叶子** 节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样。
  * B+ 树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。
  * 非叶子节点的子节点数=关键字数。

如：（M=3）

![enter image description
here](https://images.gitbook.cn/66901c60-e8d5-11ea-8f5e-eb452c9cbf03)

B+ 的搜索与 B- 树也基本相同，区别是 B+ 树只有达到叶子结点才命中（B- 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找。

B+ 的特性：

  * **B+ 树的层级更少** ：相较于 B 树，B+ 每个 **非叶子** 节点存储的关键字数更多，树的层级更少所以查询数据更快。
  * **B+ 树查询速度更稳定** ：B+ 所有关键字数据地址都存在 **叶子** 节点上，所以每次查找的次数都相同所以查询速度要比 B 树更稳定。
  * **B+ 树天然具备排序功能** ：B+ 树所有的 **叶子** 节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比 B 树高。
  * **B+ 树全节点遍历更快** ：B+ 树遍历整棵树只需要遍历所有的 **叶子** 节点即可，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

B 树相对于 B+ 树的优点是，如果经常访问的数据离根节点很近，而 B 树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比 B+ 树快。

### 4\. 小结

  * 二叉搜索树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点。
  * B（B-）树：多路搜索树，每个结点存储 M/2 到 M 个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中。
  * B+ 树：在 B- 树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+ 树总是到叶子结点才命中。

下一章将着重讲解关于 B- 树和 B+ 树的应用。

