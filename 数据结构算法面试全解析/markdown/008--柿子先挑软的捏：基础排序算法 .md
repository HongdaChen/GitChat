笔者在写到这一部分的时候，就在思考怎么去讲解才最大化读者的需要。从面试的经验来看，对于排序算法只需要掌握比较重要的几种，但是对于知识面的拓展上来说又不得不了对所有的排序算法有所了解。排序应用于开发中，我们的业务无时无刻不跟排序有关，往往处理数据的时候第一步就是排序，下面将对排序进行详细的介绍。

### 1\. 选择排序

概念：对于给定的一组记录，经过第一轮之后得到最小的元素，然后将该记录与第一个记录的位置进行交换。然后在剩下的元素中找到最小元素，将它与数组的第二个元素进行交换。如此重复执行，一直到整个元素排好序。就是不断地选择剩下记录中最小的元素。

算法代码实现 1-1 所示：

    
    
    // 交换数组里的两个元素的位置算法
    public static void swap(int[] arr, int i, int j) {
      int temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
    }
    public void selectSort(int[] TCool) {
      if (TCool == null || TCool.length() < 2) { // 简单判断
        retun;
      }
      for(int i = 0;i < TCool.length-1;i++) {
        int minIndex = i;
        for( int j = minIndex+1 ;j < TCool.length; j++ ) {
          minIndex = TCool[minIndex] > TCool[j] ? j:minIndex; 
        }
        swap(TCool,minIndex,i); 
      }
    }
    

算法代码实现的思路是双层嵌套，定义了一个 minIndex
变量记录每轮排序的最小值的下标，第一次嵌套是将完成每次排序最小值的交换，第二层嵌套使用三目运算符比较排序算法，将较小的下标值赋值给定义好的
minIndex。

试着将算法图示展示：

![选择排序
849589-20171015224719590-1433219824.gif](https://images.gitbook.cn/2020-07-27-015641.gif)

从外层循环可以看出每次排序循环下来只交换一次元素，因此，交换的总次数是 N，所以算法的时间效率取决于比较的次数；比较的次数取决于第二次嵌套循环，第一次比较
N-1 次，第二次比较 N-2，以此类推总的比较次数是 (N-1)+ (N-2) + … + 2 + 1 = N(N-1)/2 ~ N^2/2。

选择排序的特点十分鲜明，数据移动是最小的，总的移动一次是 N；运行时间与输入无关，每次循环不会为下一次循环带来什么信息，执行的次数和时间都是相同的。

### 2\. 插入排序

插入排序类似于我们传统意义上的玩扑克，将扑克一张一张的插入到有序的牌的适当位置。对于给定的一组记录，初始时假设第一个数是一个有序序列，其余后面的数是无序序列。然后从第二个数开始，依次按照大小将数插入到前一个有序序列中，直到最后一个数插入到有序序列中。

下面以数组 [38,65,97,76,13,27,49] 为例。

  * 第一个数 38 自成为一个有序序列 [38]，65,97,76,13,27,49；
  * 第二个数 65 按照大小插入到有序序列中[38,65]，97,76,13,27,49；
  * 第三个数 97 按照大小插入到有序序列中[38,65,97]，76,13,27,49。

如下图所示：

![插入排序
849589-20171015225645277-1151100000.gif](https://images.gitbook.cn/2020-07-27-015644.gif)

依次类推。

算法代码见 2-1：

    
    
    public static void insertSort(int[] TCool) {
      if (TCool == null || TCool.length <2) {
        return;
      }
      for(int i = 1;i < TCool.length ; i++) {
        for(int j = i-1; TCool[j] > TCool[j+1] && j > 0 ; j--) {
          swap(TCool,j,j+1);// 交换元素
        }    
      }
    }
    

如算法所示，从下标为 1 开始为一个无序序列，依次开始与有序序列进行比较，完成插入排序的操作。

从算法代码可以看出，插入排序所需的时间取决于输入中元素的初始顺序，比如刚好所有的元素都是有序的，那么内层嵌套不需要进行移动和插入的操作，就减少了极多的交换和比较的次数；相反如果完全乱序移动次数是
N-1 次。平均情况下插入排序需要 N2/4 交换，最坏情况下，需要 N2/2 交换，最好的情况下需要 N-1 次比较和 0 次交换。

插入排序在实际应用中常用于某些类型的非随机数组很有效，就比如对于相对有序的数组，进行插入排序，可以尽可能的减少元素移动的。

### 3\. 冒泡排序

基本思想：类似于水中的泡泡，大的泡泡自动往上冒；对于给定的 n
个记录，从第一个记录开始，依次对第一个记录进行比较，当前面的记录大于后面的记录时，交换位置，进行一轮比较和换位后，n 个记录中最大的值交换到最后一个 n
位置，然后从新开始比较第 0 个到第 n-1 个，以此类推，每一轮找到最大的元素排列到后排位置。

简单描述：冒泡排序与之前讲解到的选择排序恰恰相反，每一次遍历，将最大的元素移动序列末尾。

算法描述如下图：

![冒泡
9916080-f0605d250bd43468.gif](https://images.gitbook.cn/2020-07-27-015646.gif)

代码实现：

    
    
     public static void bubbleSort(int[] TCool) {
      if (TCool == null || TCool.length <2){
        return;
      }
      for(int i = TCool.length-1 ; i>0 ;i--) {
        for (int j = 0 ;j < i;j++) {
          if (TCool[j]>TCool[j+1]) {
            swap(TCool,j,j+1);
          }
        }
      }
    }
    

复杂度：

  * 时间复杂度 $O(n^2)$
  * 空间复杂度 $O(1)$

说到这里，我们已经对基本的排序算法有所了解，而面试一般的要求是对这些算法有一定的了解，涉及到的网红算法大概也就是冒泡排序了，冒泡排序我们只要顾名思义，像冒泡泡一样，将每一次遍历之后的最大值移到最右边的有序序列；选择选择排序与冒泡相反，则将每次遍历之后的最小值移动到最左边的有序序列；插入排序让我们联系到抓扑克牌，默认左边序列是有序的，将每次遍历的最大值插入到左边的有序序列中。

### 4\. 小试牛刀

#### **4.1 2019 年浩鲸云笔试真题**

编写 Java 代码，实现冒泡排序算法：

**题解：** 较单纯的面试手写题，可直接手撸冒泡排序算法，代码如下：

    
    
    public static void bubbleSort(int[] TCool) {
      if (TCool == null || TCool.length <2){
        return;
      }
      for(int i = TCool.length-1 ; i>0 ;i--) {
        for (int j = 0 ;j < i;j++) {
          if (TCool[j]>TCool[j+1]) {
            swap(TCool,j,j+1);
          }
        }
      }
    }
    

#### **4.2 2018 年奇安信笔试真题**

> 若用冒泡排序对关键字序列 {10,8,6,4,2}，进行从小到大的排序，所需进行的关键字比较总次数是（ A ）
>
> A 10  
>  B 20  
>  C 25  
>  D 15

**题解：** 冒泡排序基本思路，依次遍历，大的数往后移动，具体步骤如下：

    
    
    10 8 6 4 2 --> 8 6 4 2 10 ---->4
    
    8 6 4 2 10 ---> 6 4 2 8 10 ---->3
    
    6 4 2 8 10 ---> 4 2 6 8 10 ----->2
    
    4 2 6 8 10 ----> 2 4 6 8 10 ----->1
    

答案：A。

### 5\. 小结

到此主要讲解了选择、插入还有熟悉的冒泡排序，其中涉及到的复杂度知识点可以参考第一部分说讲到的内容。对于选择排序，我们可以简单的认为每次遍历选择出最小的数进行排序；插入排序则类似于扑克牌，维护一个有序的数组，遍历数组插入到有序数组中；冒泡排序则相反，每次遍历之后，大的数往后移动。

### 6\. 课后思考

本章没有详细介绍这三个算法的时间与空间复杂度，小伙伴能自行推导吗？

欢迎留言和我分享，我会第一时间给你反馈。

