上一篇重点讨论了 Zab 协议，讲清楚了 Zookeeper 的整个架构和运作流程，而且也提到了 Zookeeper
具有一些数据库不具备的特性，支撑这它可以实现比较复杂的场景，这里我们从应用出发，看看 Zookeeper 到底有哪些特性，以及这些特性有哪些丰富的应用场景。

**本篇面试内容划重点：特性、watch、节点类型、分布式锁。**

### Zookeeper 的特性

这里的特性可以说是对上一篇内容的一个总结。 **有序性：**
因为每个事务请求都会有一个事务编号，所以从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。 **原子性：**
所有事务请求的处理结果最终在整个集群中所有机器上的应用情况是一致的，即一个事务要么所有节点都执行了要么所有节点都没执行。 **单一系统映像 ：**
客户端连任意一个 Zookeeper 集群的 Server，获取到的数据都是一致的。（数据同步延迟的特殊情况在上一篇也说过了，是可以通过
sync()方法来做到完全一致的） **可靠性：** 一旦一次事务请求被 Commit，那么该请求就会被大部分节点持久化，直到被下一次更改覆盖。且 Zab
协议保证了一般以上节点存活集群就能正常运行。

接下来的内容包括，数据结构，Watch 机制，节点类型，Session，这些就是 Zookeeper
具有丰富使用场景的一个基本保证，所以此处便是“兵家必争之地”，要打起精神，好好掌握了。

#### 1\. 数据结构

![image.png](https://images.gitbook.cn/2020-06-11-070034.png) 如图，Zookeeper
的数据模型是采用树形层次结构的，我们把树中的每个节点称为 Znode。Znode 可以作为 **路径标识** 的一部分，同时维护着
**数据、元信息、ACL、时间戳** 等数据结构。 每个 Znode 由 3 部分组成:

  * **stat 状态信息** ：描述该 Znode 的版本, 权限等信息。Znode 中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据。每一个节点都拥有自己的 ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。
  * **data** ：与该 Znode 关联的数据(配置文件信息、状态信息、汇集位置)，数据大小至多 1M。
  * **children** ：每个 Znode 下可以有子节点，需要注意的是 EPHEMERAL 类型的目录节点没有子节点。

#### 2\. Watch 机制

ZooKeeper 可以为所有的读操作设置 watch（事件监听），包括： **exists()、getChildren()及 getData()**
。当节点状态发生改变时包括增（create）、删（delete）、改（setData）的行为，都会触发 watch 所对应的操作。该机制是
Zookeeper 实现分布式协调服务的重要特性。当 watch 被触发时，ZooKeeper 将会向客户端发送一条通知，注意 watch 只能被触发一次。

  * Watcher 监听的对应数据节点被创建，Exists 触发
  * Watcher 监听的对应数据节点被删除 Exists, GetData, and GetChildren 触发
  * Watcher 监听的数据节点的数据内容和数据版本号发生变化，Exists and GetData 触发
  * Watcher 监听的数据节点的子节点列表发生变化，GetChildren 触发，注意子节点内容变化不会触发

#### 3\. 节点类型

ZooKeeper 中的节点有两种，分别为临时节点和永久节点(还可再分为有序无序)。节点的类型在创建时即被确定，并且不能改变。

  * **永久节点（persistent）：** 该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，它们才能被删除。
  * **永久有序节点：** 创建永久有序节点时，父节点会维护一份时序，用于记录子节点创建的先后顺序。在创建节点过程中，ZK 会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。
  * **临时节点（ephemeral）：** 该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的 Znode 都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，ZooKeeper 的临时节点不允许拥有子节点。
  * **临时有序节点：** 和永久有序节点类似，就不赘述了，临时有序节点可以用来实现分布式锁，下面会有分布式锁的详细说明。

#### 4\. Session 会话

**Session 的作用**

  * ZK Server 执行任何请求之前，都需要 Client 与 Server 先建立 Session。
  * Client 提交给 Server 的任何请求，都必须关联在 Session 上，命令根据 Session 的连接顺序来执行。
  * 临时节点的生命周期，Session 终止时，关联在 Session 上的临时数据节点都会自动消失。
  * Watcher 通知机制也要基于 Session 来实现。

**Session 连接中断的处理流程**

  * Client 在未收到任何消息的情况下，每 t/3（t 为会话超时时间）向 server 发送一次心跳。
  * Server 若 t 秒后仍然没有收到心跳则判定会话超时。
  * Client 经过 2t/3 后，会尝试连接其他 Server 节点。
  * Client 尝试连接其他 Server 时，要保证新的 Server 能看到的最新事务比之前的连接的 Server 要新；若不符合条件，则尝试连接到另一个 Server。

### Zookeeper 的实际应用？

看了那么多特性，接下来结合实际的使用场景来融会贯通。 **集群管理与 Master 高可用** ZooKeeper 的以下两个特性是实现 HA 的关键

  * **临时有序节点** ：每个 Master 的备选节点都会创建一个临时有序节点，集群会选择序号最小的节点为 Master，若 session 断开，节点删除。
  * **Watcher 机制** ：集群会在 master 的节点上注册一个 Watcher，那么如果 master 节点发生变化，会重新选择序号最小的节点

Zookeeper 用于 HA 的场景非常多，很多大数据组件都依赖它来实现 Master 和 Backup 节点的异常切换，比如
Yarn，HBase，HDFS 等，HA 实现的本质其实就是 Zookeeper 分布式锁的实现，具体的实现下面有个实例说明。

**分布式通知/协调** 关键仍然是 ZooKeeper 的 **Watch 机制** ，它能够很好的承担 **分布式环境下不同系统之间的通知与协调**
工作，实现对数据变更的实时处理。比如心跳检测机制：两个节点不直接通信而是通过 zookeeper 来关联，大大减少系统耦合。 下面看两个实例

  * 如果 HBase 集群有 RegionServer 宕机，Master 需要重新分配 Region，会把任务放在 Zookeeper 的节点下，等其他健康 RegionServer 来获取。
  * Kafka 的各个节点必须维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的存活情况，客户端通过 Zookeeper 得知 Kafka 的节点健康状态。

**命名服务** 命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来
**获取资源、服务的地址、提供者** 等信息。被命名的实体通常可以是 **集群中的机器、提供的服务地址、远程对象** 等等。比如 HBase 会把
.META. 的地址信息存储在 Zookeeper，Client 会根据地址找到对应的 .META. 位置再定位到操作数据具体所在的
RegionServer 来进行数据的操作。

**负载均衡** 比如 Kafka 中发布者和订阅者的负载均衡

  * **生产者负载均衡** ：首先 Kafka 会把所有的分区信息发不到 Zookeeper 上有序排列，发送消息的时候，生产者会按照 brokerId 和 partition 的顺序排列组织成一个有序的分区列表，然后从头到尾循环往复地选择一个分区来发送消息。
  * **消费负载均衡** ：在消费过程中同一个 group，一个消费者会消费一个或多个分区中的消息，但是一个分区只会由的一个消费者来消费。在某个消费者故障或者重启等情况下，其他消费者通过 Watch 机制会知道这个变化，然后重新进行负载均衡，保证所有的分区都有消费者进行消费。

### 基于 ZK 的分布式锁实现？

![image.png](https://images.gitbook.cn/2020-06-11-70035.png)分布式锁是 Zookeeper
提供的核心服务，具体的实现可以由开发者自己开发，也可以使用开源的工具 curator 。另外简单提一下，curator 非常友好地封装了 Zookeeper
客户端的各种方法，解决了一些非常底层的问题，包括连接重连、反复注册 Watcher 和 NodeExistsException 异常等等。

如图所示，这里我们举个例子，看看 Zookeeper 是如何实现分布式锁的。

  1. 首先客户端 A 在 **永久节点 lock** 下创建 **临时有序节点** lock-0000001。
  2. 客户端 A 获取 zookeeper 锁目录下的所有节点列表（有序），并判断自己创建的节点是否 **位于第一** 。
  3. 客户端 A 对应的 **锁 ID（lock-0000001）是最小的** ，所以获取锁成功
  4. 执行开发人员编写的业务逻辑
  5. 此时客户端 B 在创建锁后也尝试获取锁，但是锁已经被 A 占用，所以判断得知自己的节点并不是位于第一。
  6. 然后监控（ **watch** ）当前节点的上一个节点是否存在，此处就是监控 lock-0000001 节点。
  7. 一段时间过后，客户端 A 业务逻辑处理完成，释放锁，A 对应的 **临时有序节点被删除。**
  8. 客户端 B 监控到上一个节点（lock-0000001）被删除的这个行为。
  9. 客户端 B 再次尝试获取锁。
  10. 这一次自己创建的节点（lock-0000002）是在第一位了，所以获取锁成功，接下来的操作和客户端 A 的类似。

