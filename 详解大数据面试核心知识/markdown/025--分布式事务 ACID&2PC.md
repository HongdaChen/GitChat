单机场景的事务大家可能都比较了解，对于事务的实现来说，分布式场景相比单机场景要考虑的东西更多一些，比如复杂的网络环境，这也是分布式系统最大的挑战之一，如何确认各个节点的状态，保证一致性等问题都是我们要考虑的。对于分布式事务原理，我们在工作中可能不会经常去使用它，但是它几乎存在于每一个我们接触的分布式系统中，重要性显而易见。

**本篇面试内容划重点：分布式 ACID、2PC 的优缺点，3PC 解决的问题。**

### 事务的四大特性 ACID

回顾一下我们熟悉的事务的四个特性（ACID），分布式的场景下，这四个特性依旧成立，只是实现的方式会与单机的场景有所不同。

**Atomic（原子性）**

事务必须是一个原子的操作序列单元，事务中包含的各项操作在一次执行过程中，要么全部执行成功，要么全部不执行，任何一项失败，整个事务回滚，只有全部都执行成功，整个事务才算成功。在分布式的场景下，为保证原子性，有了
2PC 和 3PC 等协议的出现。

**Consistency（一致性）**

事务的执行不能破坏数据库数据的完整性和一致性，事务在执行之前和之后，数据库都必须处于一致性状态。这个一致性和 CAP
中的一致性不同，强调状态的一致性，CAP 中的一致是共识问题（consensu），之前的章节也说过了。

**Isolation（隔离性）**

在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。即不同的事务并发操纵相同的数据时，每个事务都有各自完整的数据空间，即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。分布式场景下，经常会使用
MVCC（Multi-Version Concurrency Control ）多版本并发机制，来提高系统的并发性能。这种机制保证的是读已提交（READ
COMMITTD）、可重复读（REPEATABLE READ）这两种隔离级别的事务。

**Durability（持久性）**

一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的，即使发生系统崩溃或机器宕机，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。

### 两阶段提交（2PC）

上面提到了 2PC
解决的是原子性问题，即“要么全部成功，要么全部失败”，在单机场景中，每个节点很容易知道自己的操作是成功还是失败，但是分布式场景下，需要知道所有节点的操作状态，因此需要引入一个协调者来统一协调所有节点（参与者）的操作结果并最终告知这些节点是否要把操作结果进行真正的提交。所以
2PC
协议规定了上述的两种角色，“协调者”、“参与者”。事务协调者负责事务的发起，参与者负责事务的执行。简单地说整个流程就是：协调者发起事务操作，参与者将事务操作结果告知协调者，再由协调者根据所有参与者的响应决定各参与者是否要提交操作还是中止操作。

![image.png](https://images.gitbook.cn/4b6c7f70-fe72-11ea-88e2-5b6eea40ccd6)

#### **第一阶段：提交执行事务阶段**

第一阶段的事务处理流程如下：

  1. 首先协调者向所有参与者节点发送事务请求（Prepare），然后等待参与者的响应。
  2. 参与者接收到协调者事务请求后，执行具体的事务操作，同时将 Undo 和 Redo 信息记录事务日志中。
  3. 参与者如果成功执行了事务并写入 Undo 和 Redo 信息，则向协调者返回正常响应，否则返回异常响应或者不响应（宕机）。

#### **第二阶段：确认阶段（Commit）**

第一阶段的最后提到了参与者会有两种响应，正常和异常，所以根据不同的响应类型，第二阶段就分化出了两种场景，提交（commit）和回退（rollback）。

**1\. 正常提交事务场景（Commit）**

  * 协调者在第一阶段收到正常的响应之后，会向所有参与者发送 Commit 请求。
  * 参与者收到 Commit 请求后，执行事务提交，提交完成后释放事务执行期占用的所有资源。
  * 参与者执行事务提交后向协调者发送 Ack 响应。协调者在接收到所有参与者的 Ack 响应后，完成事务提交。

**2\. 中断事务场景（Rollback）**

在执行 Prepare
步骤过程中也提到了，在参与者返回异常响应或者不响应的场景的，比如执行事务失败、网络中断、服务器宕机等问题，系统需要保证数据的一致性，所以会执行回滚操作，对事务进行回滚，具体流程如下。

  * 协调者向所有参与者发送 Rollback 请求。
  * 参与者收到 Rollback 后，使用 Prepare 阶段的 Undo 日志执行事务回滚，完成后释放事务执行期占用的所有资源。
  * 参与者执行事务回滚后向协调者发送 Ack 响应。接收到所有参与者的 Ack 响应后，完成事务中断。

#### **2PC 的缺点**

首先 2PC 的优点很明显，原理简单，实现方便，所以在分布式系统中还是比较常用的，但是同样存在比较明显的问题，特别是在网络不稳定的场景下。

  * **同步阻塞问题：** 在第二阶段参与者在等待协调者响应时，无法进行其他操作，阻塞了运行。 如果参与者与协调者之间网络异常导致参与者一直收不到协调者信息，阻塞会一致持续直到超时。
  * **协调者的单点问题：** 协调者是事务的发起点，也是第二阶段事务确认的关键节点，如果宕机，同样会发生上面阻塞的问题。因此需要做一些工作来保证协调者的高可用，以及主备用之间的信息同步，这又是一块非常麻烦的工作。
  * **数据一致性问题：** 在第二阶段协调者发送 Commit 请求/Rollback 请求的过程中，可能会由于网络原因参与者没有收到消息，导致没有收到消息的参与者与收到消息的参与者数据不一致，没有收到消息的参与者会阻塞。

### 三阶段提交（3PC）

三阶段提交协议的出现是为了解决上述 2pc 的问题，相对于二级段提交协议，最大的优点就是降低了参与者的阻塞的范围，并且能够在出现单点故障后继续达成一致。

![image.png](https://images.gitbook.cn/57b29670-fe72-11ea-9bca-53594cb3b0db)

#### **第一阶段：确认阶段（CanCommit）**

  1. 协调者向所有参与者发送事务 canCommit 请求，请求中包含事务内容，询问是否可以执行事务提交操作，并开始等待响应。
  2. 参与者收到 canCommit 请求后，分析事务内容，判断自身是否可以执行事务，如果可以，则返回正常响应，但是此时还不会正式执行事务，否则返回异常响应。

#### 第二阶段：预提交阶段（PreCommit）

PreCommit 阶段根据第一阶段各参与者返回的响应种类，决定下一步动作。如果收到了所有参与者的正常响应，则执行事务预提交，否则执行事务中断。

**1\. 事务预提交**

  1. 协调者发送 PreCommit 请求，等待响应。
  2. 参与者收到 PreCommit 请求后，执行事务操作，并将 Undo 和 Redo 信息记录事务日志中。
  3. 如果参与者成功执行了事务并写入 Undo 和 Redo 信息，那么反馈 Ack 给协调者，并等待下一步指令。

**2\. 事务中断**

如果上一个阶段的响应异常则协调者不是发送 PreCommit 请求，而是 Abort 请求。

  1. 协调者向所有参与者发送 Abort 请求。
  2. 参与者收到 Abort 请求后，会触发事务中断。如果参与者在等待协调者指令超时，会自己触发事务中断，不阻塞。另外，因为第一阶段没有执行事务，所以在第二阶段（PreCommit 阶段）执行事务中断，是不需要事务回滚的，也不需要反馈结果，直接中断事务即可。

#### **第三阶段：执行提交阶段（doCommit）**

第三阶段协调者也是根据第二阶段的响应决定最终操作，如果协调者收到了所有参与者在 PreCommit 阶段的 Ack
响应，那么会进入执行事务提交阶段，否则也是执行事务中断。

**1\. 事务提交**

  1. 协调者收到所有参与者在 PreCommit 阶段返回的 Ack 响应后，向所有参与者发送 doCommit 请求，并进入提交状态。
  2. 参与者收到 Commit 请求后，执行事务提交，提交完成后释放事务执行期占用的所有资源。
  3. 参与者完成事务提交之后，向协调者返回 Ack 响应，协调者收到所有参与者的 Ack 响应后，完成事务。

**2\. 事务中断**

  1. 协调者向所有参与者发送 Abort 请求。
  2. 参与者收到 Abort 请求后，会使用第二阶段记录的 Undo 信息进行事务回滚，并在完成回滚后释放所有事务资源。
  3. 参与者执行事务回滚后向协调者发送 Ack 响应。 协调者接收到所有参与者反馈的 Ack 响应后，完成事务中断。

总的来说，3PC 解决了上述 2PC 的两个问题，阻塞和单点故障问题。

**阻塞问题方面** ，参与者在返回第一和第二阶段的 CanCommit/PreCommit 请求的响应后，等待指令，若等待超时，则自动
Abort/Commit，降低了阻塞，有效降低阻塞。

**单点故障问题的思路相似** ，参与者在返回第一和第二阶段的 CanCommit/PreCommit 请求的响应后，若协调者宕机也没关系，等待超时后自动
Abort 或者 Commit 即可。

但是仍然存在数据 **不一致的问题** ，比如第三阶段协调者发出了 Abort 请求，然后有些参与者没有收到 Abort，那么就会自动
Commit，造成数据不一致。

