上一篇我们说了我们可以把 Elasticsearch 看作是一个数据库，但是它被更多人知道和记住是因为它的全文检索能力，这几乎成了 ES
的代名词，全文检索的原理就是我们这一篇需要重点讲解的“倒排索引”，面试中只要出现 ES 相关的内容，那么倒排索引的问题就是必不可少的，

**本篇面试内容划重点：倒排索引、设计上的优化、选主** 。

### 倒排索引

全文检索有什么用？举个例子，我们平时去图书馆找书会用检索系统来根据条件找自己需要的书籍。这是很平常的需求，再苛刻一些，我们需要找到一段文字出自于哪本书。ES
可以做到这些，它会把每一本书的内容开分成一个一个词语（分词），然后让分出来的词指向这本书，如果另一本书也有相同的词，那么这个词会指向两本书。ES
做好了这些工作后，当我们检索一段文字时，它 会去库中匹配之前分的词，然后按照相似度排列，把词指向的书名返回，这样我们就知道这段文字最可能来自于哪本书了。
![](https://images.gitbook.cn/2020-06-11-070036.png) （图片来自官网）
再正式地介绍一下，倒排索引是用于快速全文检索的一种索引结构，一个倒排索引由 **文档中所有不重复词的列表构成** ，对于其中每个单词，
**都对应了一个包含它的文档列表** 。所以当用户搜索某个词时，ES能够快速找到这个词对应的文档列表并返回。看一下下面这些概念

  * **Term（单词）** ：文本经过分词器分词后生成一连串的单词。
  * **Term Dictionary（单词字典）** ：把Term按字典序排列，然后用二分法查找Term（存在磁盘）
  * **Term Index（单词索引）** ：是 Term Dictionary 的索引，存 Term 的前缀，和与该前缀对应的Term Dictionary中的第一个Term的block的位置，找到这个第一个Term后会再往后顺序查找，直到找到目标Term。（存在内存）
  * **Posting List（倒排列表）** ：倒排列表记录了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。

### 倒排索引在设计上做的优化

#### Term Index 的压缩

上面提到了 Term Index 是 Term Dictionary 的索引，存 Term 的前缀，所以理论上Term Index的数据结构是：Map
，但是 Term Index 是存在内存中的，所以 Term 量大的情况下是会把内存撑爆的。于是有了基于 FST 的压缩技术。 **Finite State
Transducers（FST）** ：有穷状态转换器，Term Index采用的压缩技术。

**举个例子， Term Index 里需要存储的数据如下：** `Map[“cat”&nbsp;&nbsp;- > 5, “deep” - > 10,
“do” - > 15, “dog” - > 2, “dogs” - > 8&nbsp;]`

**对应这些数据，FST 会生成如下的结构：**
![image.png](https://images.gitbook.cn/2020-06-11-070037.png)

  * 如图， **每条边** 有两条属性：
  * **label** 为 entry 中的 key 按字节拆开后分布在每一条边上的值，如图所示很容易理解，“c”“a”“t”分别分布在三条边上。
  * **out** 为与 entry 的 value 值相关的一个数值，具体如何计算见下文分析。
  * **每个节点也** 有两个属性，Final=true/false（当有key在这个节点结束时则为true）；Final为true时，还有个FinalOut，FinalOut = （entry的value值）-（该路径out值之和）。

**举个例子** ：8号节点，对应的entry的key是“do”，value是“15”，而该路径out值之和是2（2+0），所以FinalOut =
15-2 = 13。

**out值怎么计算的？**

  * 当只有一条数据写入时（比如cat），则 **第一个字节** （即“c”）的out值就等于该 entry 的 value 值（即“5”）；
  * 当 “deep” 写入时因为后面“d”开头的数据还没写，所以“d”的 out 值就是“10”；
  * 当 “do” 写入时，因为“d”=“10”，所以“o”=“15”-“10”=“5”
  * 当 “dog” 写入时，因为“d”=“10”，“o”=“5”，已经超过了dog的值“2”，此时，会把“d”设为“2”，“o”设为“0”，这样才能满足 dog=“2” 的情况。
  * 但是，这样 deep 和 do 的 out 值就要重新分配了
  * deep 的整条路径和为“10”，已知“d”=“2”，所以“e”承包剩下的“8”。
  * do 的整条路径和为“15”，已经“d”=“2”，“o”=“0”，没有label了，所以 FinalOut=15-2-0=13。

由上所述，不难得出，FST 查询的复杂度时O(1)，能快速定位到目的 Term 前缀的 Block 位置。

#### Posting List的压缩

##### **增量存储**

通过增量存储的方式，仅存储增量值，可以将原来的大数变成小数，如下图所示，原本需要存储的Posting List为 **[1, 4, 8, 15,
25]，** 经过编码之后变成了 **[1, 3, 4, 7, 10]**
，即后一个元素与前一个元素的差值作为新List的元素。可见新List的数值变小了，此举是为后面Bitmap的存储节省空间。
![image.png](https://images.gitbook.cn/2020-06-11-070038.png)

##### **Bitmap**

bitmap用0/1表示某个值是否存在，比如10这个值就对应第10位，对应的 bit 值是1，这样用一个 byte
字节就可以代表8个文档id。如图举个例子，posting list：[1,3,4,7,10]，对应的 bitmap 就是：
[1,0,1,1,0,0,1,0,0,1]。
旧版本(5.0之前)的Lucene就是用这样的方式来压缩的，但是仔细想想这样的压缩方式其实是并不高效的，因为假设有1亿个文档，那么我们就需要有
100000000 ÷ 8 ÷ 1000000 = 12.5(MB)
的存储空间，而且这只是一个索引字段。Bitmap的缺点很明显，就是存储空间会随着文档个数而线性增长。
![image.png](https://images.gitbook.cn/2020-06-11-070040.png)

##### **Roaring Bitmaps**

![](https://images.gitbook.cn/2020-06-11-080125.png)  
Roaring Bitmaps 的方式会将posting
list按照65535为界限分块，即第一块所包含的文档id范围在0~65535之间，第二块的id范围是65536~131071，以此类推。然后用的组合表示每一块的id，这样每块的id范围都在0~65535内了，接下来就是每个块内部的存储空间优化了，首先看几个概念：

  * short[] 占的空间：2bytes（65535 = 2^16-1 是2bytes 能表示的最大数）
  * bitmap 占的空间: 65536/8 = 8192bytes 当block块里元素个数不超过4096，用short[]存储，因为4096个short[]才等于 8192bytes；而一个bitmap就等于8192bytes了，虽然它能存65536个元素。 

#### 联合索引

联合索引通俗地说就是找到满足多个搜索条件的文档，即多个搜索结果的交集。ES中做联合索引的方式有两种

  * 第一种是上面提到的BitMap
  * 第二种是跳表（Skip List）

![image.png](https://images.gitbook.cn/2020-06-11-070043.png)

举个例子：有3个检索条件，即需要求如图三个 Posting List 的交集， 每个list都是有序的。首先看 Posting List 1
的31这个元素，它有两个指针，一个指向List1的61，一个指向List2的31，这样就跳过了List2的13这个元素的检索，同样List2的31也会指向List3的31，则又跳过了List3的14、15这两个元素。

### 选主机制

ES的选主机制在 ES 7.X 版本迎来了重大的升级，考虑到大部分公司仍然使用的是老版本，所以以下内容基于 ES
6.X。关于角色上面已经详细提过了，我们知道 Elasticsearch 的任意一个节点都可以设置 node.master 和 node.data
属性，而只有配置了 node.master:true 即 Master Eligible Node 节点才会真正地参与选举。

**首先要知道的是几个投票的依据**

  * **clusterStateVersion** ，即集群meta的版本。Commit 数据，meta 版本会递增。所以我们可以得出的结论是，当clusterStateVersion越大，则说明数据越新，选举过程也会用最大clusterStateVersion保证数据的最新。
  * **节点Id** ，这个 Id 是节点首次启动时生成的随机字符串。只有在通过 clusterStateVersion 确定不了Master的情况下，才会判断节点Id然后选出最小的Id的节点，这么设计是为了让选举过程尽快收敛，不要出现无法确定Master的情况。

**下面来看选举过程**

  1. 寻找 clusterStateVersion 比自己高的 Master Eligible Node，向其发送选票。
  2. clusterStatrVersion 相同，则计算自己能找到的 Master Eligible Node（包括自己）中节点id最小的一个节点，向该节点发送选举投票。
  3. 如果一个节点收到的投票达到阈值（ minimum _master_ nodes ），那么该节点成为 Master 开始发布集群状态。

**选举怎么保证不脑裂？** 当前版本的ES使用的是多数派（Quorum）的策略，只有得到多数节点的投票认可，才能成为主节点，确保了Master的唯一。
ES 6.X
中没有投票轮次的概念，所以存在同一个节点投票多次的情况，但是投票过程是两阶段的，在第一阶段，可能有两个节点获得了同样多的选票（有节点投了两次），但是在Commit阶段，其中的一个节点是无法再次获得半数以上选票的，所以这个节点会退回候选人状态，Master节点确定。

**主节点宕机后是如何容错的？**

  * 从现存的 Master Eligible Node 中选出新的 Master 节点，具体选举流程看上面的描述。
  * 被选出来的新的 Master 会把挂掉的 Primary Shard 对应的 Replica shard 中的其中一个提升为 Primary Shard。此时虽然已经恢复了数据的正常读写但是shard的备份数仍然是缺少的。
  * 宕机的服务器重启后，新 Master 会把所有缺失的副本都复制一份到该节点上，并同步宕机后部分发生的修改，此时集群恢复正常，所有的 primary shard 和 replica shard 都是 Avtive Status。

