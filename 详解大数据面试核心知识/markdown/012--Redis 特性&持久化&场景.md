非关系型数据库在大数据领域的应用非常广泛，比如之前说到的 HBase ，他能适用于很多的场景，解决各种大数据的难题，但是它不是万能的，磁盘 IO
是他的主要瓶颈，在实时性要求更高的场景下，内存数据库 Redis 就显现出了它的优势了，做过 web 开发的同学对 Redis
肯定不陌生，它丰富的数据结构和优秀的读写性能同样征服了大数据领域的开发者们。

**本篇面试内容划重点：数据结构、持久化、高性能**

**你为什么选择 Redis？** 开篇先来个灵魂发问，这个问题可以从两个方面回答， **数据结构丰富** 和 **高并发高性能**
，所以场景丰富。这两个方面也是本篇内容讲解的重点，详细答案就在文中。

### 数据结构

数据结构这块，主要考察大家对结构的了解和应用场景，更深层次的会涉及到 BitMap、BloomFilter、Hyperloglog
等相关的内容，概念型的问题考察的是基础，应用型的问题考察的是你的实战能力。

#### 基础数据类型？

**字符串（String）：底层是动态字符串(Simple Dynamic String 简称 SDS)结构。**
它的内部维护着一个字节数组，并且在其内部预分配了一定的空间，以减少内存的频繁分配。最大长度为 512MB。 **列表（List）：底层是用了 ZipList
压缩列表和 LinkedList 双端链表结构。** 插入和删除操作非常快，时间复杂度为
0(1)。但是链表的前后指针会占用较多的内存浪费空间，而且会加重内存的碎片化。 **集合（Set）：底层是用了 Intset 整数集合和 Hashtable
哈希表结构。** 集合内部的值是无序且唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是 NULL。 **有序集合（Sorted
Set）：底层是用了 Skiplist 跳跃链表和 Ziplist 压缩列表结构。** 首先它是个 set ，所以内部的值是唯一的，另方面它可以给每个
value 赋予一个 score，代表这个 value 的排序权重。SkipList 结构通过在每个节点维持多个指向其他节点的指针来达到快速访问节点的目的。
**散列（Hash）：底层用了 Hashtable 哈希表和 Skiplist 跳跃链表的结构。** 当发生 hash
碰撞时将会把元素追加到链表上，Hash 的 value 只能是字符串。 **基数（Hyperloglog）**
：根据输入元素来计算基数，不会储存输入元素本身，所以 HyperLogLog 不能像集合那样返回输入的各个元素值。

#### 高级用法？

**BitMap 位图** ：通过一个 bit 位来表示某个元素对应的值或者状态,其中的 key 就是对应元素本身。8 个 bit 可以组成一个
Byte，所以 bitmap 本身会极大的节省储存空间。 **BloomFilter 布隆过滤器** ：一个二进制向量和一系列随机映射函数实现。
可以用于检索一个元素是否在一个集合中。 **GeoHash**
：将二维的经纬度数据映射到一维的整数，这样所有的元素都将挂载到一条线上，距离靠近的二维坐标映射到一维后的点之间距离会很接近。（可应用于找附近的人）
**Pub/Sub** ：发布与订阅。 **Stream** ：支持多播的可持久化的消息队列，和 Kafka 类似。**

#### 应用场景？

**缓存，** 高并发，高性能场景。 **分布式锁** ，解决分布式系统的资源调用和协调问题。 **排行榜场景** ，Redis 有序集合的应用。
**社交网络场景** ，GeoHash 附近的人。 **最新列表场景** ，LPUSH 在 List 头部插入最新数据，LTRIM 限制列表的数量。
**消息系统** ，Pub/Sub 和 Stream 的应用场景。

### Redis 持久化方式？

#### 1\. RDB 方式

RDB 方式是指在 **指定的时间间隔内将内存中的数据集快照写入磁盘的过程** ，实际的操作过程是 fork
一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储（binlog）。

**RDB 持久化的优点？**

  1. **便于备份和文件恢复** ，RDB 是一个压缩过的独立文件，保存着某个时间段的数据集，备份时间段频次都可以配置，且可以 RDB 文件可以随意复制到任何位置用于 redis 实例恢复。
  2. bgsave 的方式会 fork 出子进程进行持久化的工作， **不影响主进程提供服务** 。
  3. 在 Redis 重启后加载文件进行数据恢复时，RDB 文件的加载效率比 AOF 高。

**RDB 持久化的缺点？**

  1. 资源消耗多，特别是当数据集较大时，fork 的子进程要完成快照会会比较耗费资源和时间。
  2. **安全性差** ，上面提到 RDB 持久化的过程是比较耗费资源的，一般配置的持久化的时间间隔会比较长，因此如果服务器宕机，那么这段间隔的时间内的数据就有会丢失无法恢复。

#### 2\. AOF 方式

AOF 持久化以 **日志的形式** 记录服务器所处理的每一个写、删除操作（读操作不用记录），以 **文本方式保存** ，可以打开此文件看到详细的操作过程。

**重写 BGREWRITEAOF**

为什么要重写 AOF？

Redis 服务执行的命令肯定是越来越多的，记录写日志的 AOF 文件也会越来越大；AOF
太大会影响服务器的正常运行，数据恢复也会花费更多的时间。重写的过程是将 Redis 内的数据转化为写命令，同步到新的 AOF
文件中，相比记录每一条写操作的旧 AOF 文件，新文件会小很多。重写的过程不会操作旧 AOF
文件，所以数据仍然是可以正常写入的，但是子进程的重写操作对服务器的性能还是会有一定影响的，因此建议重写操作在 Redis 没有那么繁忙的时候手动触发。

![image.png](https://images.gitbook.cn/2020-06-11-070122.png)

  1. 主进程执行 BGREWRITEAOF，fork() 出子进程重写 AOF，此过程主进程阻塞。
  2. 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，并和原来一样正常将数据写入 AOF 缓冲区，按策略同步到磁盘，保证重写时宕机数据不丢失。
  3. 另外，fork 操作用的写时复制技术让子进程没法共享到 fork 操作之后的数据，所以如图，需要有个 AOF 重写缓冲区来保存这部分数据，防止新 AOF 文件生成期间丢失这部分数据。 **即这段时间主进程会写两份数据。**
  4. 子进程根据内存快照，按照合并规则将数据写入到新的 AOF 文件，完成后向主进程发信息，主进程得到信息后把 AOF 重写缓冲区的数据追加写入到新的 AOF 文件，保证了新 AOF 文件所保存的数据为最新数据。
  5. 最后使用新的 AOF 文件替换老文件，完成 AOF 重写。

**AOF 持久化的优点？**

  1. **数据安全性高** 。有 3 种同步策略（fsync），
  2. 每秒同步，redis 宕机最多丢失一秒内的数据。
  3. 每修改同步，基本完全同步，每次发生的数据变化都会被立即记录到磁盘中（但是单条数据写到一半宕机那么这条数据也会丢失，redis-check-aof 会把不完整的数据删除）。
  4. 不同步。
  5. 如果 AOF 写的日志过大，Redis 可以自动启用 BGREWRITE 机制来重写日志文件， **减小日志文件的大小** 。
  6. AOF 记录的是一个 **格式清晰且可读的日志文件** ，可以监控开发人员的误操作，并通过日志文件找到操作行为进行紧急恢复。

##### **AOF 持久化的** 缺点？

  1. **数据恢复效率低** ，相同数量的数据集，AOF 文件大小大于 RDB 文件且 RDB 文件恢复的速度比 AOF 要快得多。
  2. 从上述的 fsync 策略可知，AOF 机制的数据写磁盘更频繁，因此在 **运行效率上会慢于 RDB** 。

# Redis 为什么那么快？

  1. Redis **完全基于内存实现** ，数据全量存储在内存中，增删改查都是直接对内存数据操作，非常快速。这个大家都知道。
  2. **针对数据结构有专门的优化设计** 。比如：底层使用压缩列表（ziplist）节约内存，使用跳跃表降低维持结构平衡的成本。
  3. **单线程响应请求** ，不会过量消耗 CPU 资源，避免了不必要的上下文切换和竞争条件，不用去考虑多进程场景下的锁问题，加锁，释放锁，死锁等。
  4. **多路 I/O 复用模型（非阻塞 IO）** ， 多个网络连接复用同一个线程。可以让单个线程不阻塞地高效处理多个连接请求，减少网络 IO 的时间消耗。
  5. **Redis 自己构建了 VM （虚拟内存）机制** ，可用于数据量太大情况下的冷数据落盘，相比 OS 提供的 swap 机制，redis 实现的机制存储粒度更小，可以将交换到磁盘的对象进行压缩，swap 会阻塞线程，Redis 可配置工作线程来操作，主线程仍可以继续处理 client 请求。

**为什么 redis 选择用单线程？** 因为 CPU 不是 Redis 的瓶颈。Redis
的瓶颈最有可能是服务器内存或者网络带宽，且单线程实现的结构相对简单，可维护性更高。单线程响应请求，避免了不必要的上下文切换和竞争条件，不用去考虑多进程场景下的锁问题，加锁，释放锁，死锁等。

### Redis 使用过程中的注意事项

  1. **redis 的库的概念是个坑** ，存在 **不可自由命名、数量有限、cluster 模式只有一个库** 等问题，如果要区分业务或者库表的情况，可以直接通过给 key 加前缀来区分。
  2. 对于不同的业务可以用不同的 redis 实例来存储， **避免慢操作的互相影响和资源的竞争。**
  3. **对集群的健康状态和慢日志做监控** ，保证集群的正常高效运行。
  4. redis 中 **只存常用的热点数据** ，不要存全量数据。
  5. 最好为所有 key 都配置 **过期时间** ，另外过期时间过于集中会导致系统出现卡顿，最好给过期时间加个随机值把时间分散开。
  6. Master 调用 **BGREWRITEAOF** 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象，可以在 **业务不繁忙的时候手动触发** BGREWRITEAOF 操作。
  7. 主从复制一般情况一主一从即可， **一主多从会加大主节点的负担** ，尽量避免在压力较大的主库上增加从库。
  8. 避免 keys 操作，因为 keys 会 **导致线程阻塞一段时间** ，线上服务会停顿，直到指令执行完毕，服务才能恢复，如果需要扫描全表可以用 scan。

**补充一个 Redis 的数据淘汰策略**

  * **volatile-lru** : 从已设置过期的数据集中挑选最近最少使用的淘汰
  * **volatile-ttr** : 从已设置过期的数据集中挑选将要过期的数据淘汰
  * **volatile-random** : 从已设置过期的数据集中任意挑选数据淘汰
  * **allkeys-lru** : 从数据集中挑选最近最少使用的数据淘汰
  * **allkeys-random** : 从数据集中任意挑选数据淘汰
  * **noenviction** : 禁止淘汰数据

