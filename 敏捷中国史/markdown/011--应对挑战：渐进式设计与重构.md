以 CMM
为代表的传统软件工程准确地指出了需求管理、项目管理、配置管理、质量管理四大挑战，却没有给中国软件业提供切实有效的解决办法。一批年轻的从业者转而从强调实践的极限编程方法那里寻找答案。对于“如何做好的软件设计”这个问题，他们发现重构可能是更靠谱的解法。

* * *

“这是怎么回事啊？为什么年检功能又坏掉了？我下午测试过的呀，有人改过吗？”何晓东着急地嚷嚷着，嗓门比平时又提高了两分。

2003
年岁末将至，淅淅沥沥的小雨在杭州已经下了几天，只等下一波寒潮带来降雪。北大青鸟杭州公司的一支项目实施团队在项目经理何晓东的带领下，正在杭州市工商局信息处的一间大会议室里加班加点完成系统上线前的最后工作。这时的杭州北大青鸟，除了与
APTECH 合作的认证培训之外，也承接政府和银行信息化系统实施业务。何晓东负责的这个项目，目标是在元旦之前上线杭州市企业网上注册和年检系统，1 月 4
号就要开始接受上万家企业在线办理业务。现在交付“死线”日近，各种 Bug 还在层出不穷，也难怪他着急上火。

“没道理呀……哎唷，可能是我这儿的问题……”沈瑜一边看着面前的电脑屏幕一边挠头，几天没洗的头发有点起油，被他这么一抓，愈发乱成了一个鸟窝。

“你干了什么？你不是在搞注册吗？怎么会把年检给弄坏的？”

“哎呀~我这不是看表单组件的代码质量不太好嘛，就想重构一下，谁想到重构一下就给搞坏了呢……在注册这边是好好的呀，我就忘了年检也用了这个组件，你看这事闹的……”沈瑜懊恼地嘟囔道。

“你说你，好好的搞什么重构呢，我们系统马上就要上线了呀，这个时候千万不能出新问题最要紧呀。”何晓东皱着眉头对沈瑜说。

“我也是想把质量做好一点嘛……上次石一楹给我们培训不是还讲，代码质量很重要，看到坏味道要马上重构，你看这个代码，坏味道很明显……”沈瑜有点不服气地回答。

“石一楹还讲要做单元测试呢。你的代码有多少单元测试覆盖呀？单元测试还能通过不啦？一改就出错，石一楹讲的重构不是这样吧？”

沈瑜被何晓东呛得还不上口，只好尴尬地笑笑，继续埋头解决问题。窗外的城市，已是一片灯火夜色。

![](https://images.gitbook.cn/678df680-1327-11e9-bc0e-79d07a81907b)

* * *

### 软件质量：模式还是重构？

**重构** （Refactoring）这个概念最初是在 1990 年由 William Opdyke 在一篇会议论文中正式提出的1。当时 Opdyke
就读于伊利诺伊大学，他的导师是 Ralph Johnson。要了解重构的来龙去脉，还得从他这位导师这儿说起。

作为面向对象领域的顶尖专家学者，Ralph Johnson 的集大成之作当属 1995 年出版的 **《设计模式》**
。由于这本书的影响力太大，在计算机行业提到“四人帮”（Gang of Four，GoF）时，指的一定是包含 Johnson 在内的合著此书的四位作者。

在《设计模式》一书中，四位作者以 **23 个模式**
的形式记录了一批面向对象软件的设计经验，每个模式系统地命名、解释和评价了面向对象系统中一个重要而常见的设计。作者们期望设计模式帮助人们更加简单方便地复用成功的设计，从而更快更好地完成系统设计，并且得到的设计能够更好地适应新需求和已有需求的变化、使系统在变化发生时具有健壮性2。一言以蔽之，
**设计模式的目标是提高软件设计的质量** 。

**然而软件行业的迅速发展给模式社群带来了巨大的挑战。**

一方面，在社群的共同努力下，新的模式不断被总结提炼出来，已知的模式数量飞速增加。世界各地的研究者与实践者用模式语言的形式归纳自己在软件设计中的经验，以会议演讲和文章的形式发表，并集结出版。

从 1995 年到 2006 年间，仅“程序模式语言”（Pattern Language of Program，PLoP）一个国际会议，就出版了 5
卷大部头的模式集。其他机构和个人发表的模式文献更是汗牛充栋。

另一方面，随着软件开发技术的更新换代，很多模式也随着旧的技术而过时。尤其是《设计模式》一书中列举的 23 个设计模式，有很多被批评是为了迎合 C++
落后的语言特性。

早在 1998 年就有人指出，如果使用 LISP 或 Dylan 等动态语言实现，这 23 个模式中有 16 个可以被大幅简化甚至完全不需要3。2002 年
OOPSLA 会议的一篇论文认为，如果采用 Java 和 AspectJ 实现，23 个模式中有 17 个可以大幅简化或去除4。考虑到 Java
在企业应用、尤其是 Web 应用中逐渐占据主流位置，AspectJ
也是应用颇为广泛的开源框架，可以认为此时《设计模式》中列举的具体模式内容已经基本上过时了。

一边是新的模式如潮水般不断涌现，另一边是“经典的”模式在短短几年内就变得过时，这种快速变化的状态使得 **模式在实际软件开发中的有效应用变得非常困难**
：软件开发者必须了解数量爆炸式增长的模式、记住它们的适用场景和约束条件，才有可能在相同的场景出现时做出正确的选择——用或者不用某个模式。

而这些知识中最著名、最广为人知的部分还正在逐渐变得过时。因为这些困难，即使在设计模式最受关注的几年，行业中实际出现得更多的是两个极端情况：大部分人很少使用设计模式；少数人热衷于使用设计模式，但又经常因为不恰当的误用或滥用，不但没有达到提高软件设计质量的效果，反而使软件设计更加复杂、脆弱、不易维护、不易修改。

快速涌现的设计模式文献，让软件开发者们看到了良好设计可能呈现的形态，但其中大多数人并不清楚应该如何到达这一状态。

![](https://images.gitbook.cn/dd000890-1327-11e9-abc2-a9701a61d30b)

模式社群的先驱们很早就认识到， **重构可以作为获得高质量面向对象设计的路径**
。“四人帮”认为，如果没有在设计初期识别并使用恰当的模式，在系统建成之后，仍然可以通过重构来逐渐演进软件的设计，此时设计模式则可以为重构提供目标5。然而《设计模式》的读者大多忽视了这段发生在全书末尾处的讨论，直到几年后
Martin Fowler 正式把 **重构** 的概念带到世人面前。

### 重构原理简介

在他 1999 年出版的《重构》一书中，Martin Fowler 如是定义“重构”这个概念6：

> 重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
>
> 重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

这个定义包含两个重点。首先是重构的目的：Fowler
认为重构是为了“提高[软件代码的]可理解性，降低其修改成本”，或者用“四人帮”的说法，“使系统在变化发生时具有健壮性”。

区别于《设计模式》在“健壮性”话题上较为笼统的讨论，Fowler 非常具体地列举了 22
种有可能导致代码不易理解、不易修改、面对变化不健壮的情形，将它们称为“坏味道”7。

这些“坏味道”大多有非常明确的特征（例如“重复代码”、“过长函数”、“过大的类”等），并且其危害也大多能得到广泛认同。于是，通过明确列举 **坏味道**
，Fowler 把 **代码质量** 这个抽象且多有争议的概念转化为清晰、有共识、可度量的指标： **坏味道的数量或密度** 。而重构的目的也就由此明确：
**消除代码中的坏味道** 。

![](https://images.gitbook.cn/42bd1ba0-1328-11e9-b788-6d43e14d3bb3)

重构的定义中包含的另一部分信息，与重构的目的同等甚至更加重要，那就是 **重构的方法** ：Fowler
指出重构应该“在不改变软件可观察行为的前提下”进行，或者用 Opdyke
的说法，重构应该是“行为保持”的。为了最大限度地减少调整软件设计过程中引入错误的几率，必须采用“一种经千锤百炼形成的有条不紊的程序整理方法”；而不采用这类严谨的程序整理方法、不特别考虑行为保持而进行的设计调整，则是“胡砍乱劈的随性行为”。

William Opdyke 在他的博士论文8中讨论了一个 **看似简单实则意义深远的问题**
：对程序代码做哪些修改，不会改变软件可观察的行为？他给出了一些平白得近乎幼稚的答案，例如“增加一个不被调用的函数，软件的行为不会改变”。类似这样的修改手法，他列举出了
5 大类、26 种。

随后他又指出，由多个行为保持的修改手法组合而成的修改手法也是行为保持的。前面列举的简单修改手法，加上这显而易见的论断， **构成了重构理论的基础**
：理论上，所有重构手法都应该是已知行为保持的修改手法的组合；如果你只使用这些手法修改代码，那么你的修改必定是行为保持的。

我们可以通过一个例子来认识 **严谨的重构与“胡砍乱劈”之间的差异**
。假设一名程序员想给一个函数改名，直觉的方式可能是直接动手修改这个函数的名字，然后找到所有使用该函数的地方，逐一修改这些调用点。然而这个看似简单的修改动作就有可能给程序员带来麻烦：一旦修改了函数的名字，所有调用该函数的代码都将处于失败状态（取决于编程语言和系统设计的不同，有可能是编译失败，也可能是运行时失败）。

为了避免留下一个处于失败状态的系统，这名程序员必须一次性完成所有调用点的修改——在一些时候，这可能涉及跨多个工程的成百上千个调用点。更糟糕的是，他可能在修改到一半时发现其中一些调用点无法修改（例如他可能无权向另一个工程提交修改），这时他就会发现自己处于一个尴尬的两难境地：即使要放弃这次修改，把函数名字改回原状，他也必须再次找出自己已经修改过的所有调用点，逐个撤销所有的修改。

这个过程中犯错误的几率丝毫不小于起初的修改过程，疲劳与沮丧则会让他更容易犯错误。就连“给函数改个名字”这么简单的事都可能带来这么多麻烦，程序员普遍不愿意在功能完成后调整和优化软件设计也就不足为怪了。

同样是“给函数改名”这件任务，Fowler 给出的做法要 **繁复得多** ：

>   1. 声明一个新函数，将它命名为你想要的新名称。将旧函数的代码复制到新函数中，并进行适当调整。
>   2. 编译。
>   3. 修改旧函数，令它将调用转发给新函数。
>   4. 编译，测试。
>   5. 找出旧函数的所有被引用点，修改它们，令它们改而引用新函数。每次修改后，编译并测试。
>   6. 删除旧函数。
>   7. 编译，测试。
>

这个做法的关键在于，在修改函数的调用点、令其使用新名字调用该函数时（步骤 5），修改的步伐是 **小而可控**
的：可以只修改一部分调用点，可以把整个修改过程分拆到几天、几个人来完成。在整个修改过程中，不论修改的进度完成多少，软件始终处于可用的状态。通过类似这样“有条不紊的程序整理方法”，调整软件设计的风险得以降低，从而使软件设计的持续演进成为可能。

![](https://images.gitbook.cn/c9ad53f0-1328-11e9-abc2-a9701a61d30b)

但是应该注意，对于编译型语言（尤其是 C++ 和 Java），Opdyke
列举的行为保持的修改动作中，有一些只需要编译就能确认修改正确，另一些修改动作仅靠编译还不足以确认正确。例如在上面的例子中，步骤
3（将旧函数的调用转发给新函数）和步骤 5（修改调用点使之调用新函数）在 Opdyke
的论文中属于“语义等价”的修改。换言之，如果这些修改出错，编译器并不保证能捕捉到错误。所以，执行完这些步骤之后，整个软件可观察的行为是否仍然保持不变，只能通过
**测试** 来判断9。

### 参考文献

1 Opdyke, W.F., 1992. Refactoring object-oriented frameworks.  
￼2 （美）Erich Gamma等著,李英军等译.设计模式 可复用面向对象软件的基础[M].机械工业出版社,2000:16.  
3 [Peter Norvig.Design Patterns in Dynamic
Languages](http://www.norvig.com/design-patterns/)[EB/OL].  
4 Hannemann, J. and Kiczales, G., 2002, November. Design pattern
implementation in Java and AspectJ. In ACM Sigplan Notices (Vol. 37, No. 11,
pp. 161-173). ACM.  
5 （美）Erich Gamma等著,李英军等译.设计模式 可复用面向对象软件的基础[M].机械工业出版社,2000:233.  
6 ￼[美]马丁•福勒（Martin Fowler).重构[M].人民邮电出版社,2015:53.  
7 ￼ibid,75.  
8 Opdyke, W.F., 1992. Refactoring object-oriented frameworks.  
9 虽然步骤6的后面也紧跟着“编译，测试”的步骤，但步骤6（删除不被调用的函数）本身是行为保持的。步骤7应该被视为对整个重构手法的最终检查

### 畅聊技术历史与人生

我们希望订阅课程的朋友们可以一起把酒言敏捷，分享技术世界的一切趣事，畅聊各自的技术人生。《敏捷中国史》是普通 IT
人形塑历史的故事，也是永远不会完结的技术旅程。你可以将自己的想法发表在评论区，也可以加入《敏捷中国史》交流群，小到我们一起完善这部作品，大到共同创造未来更好的
IT 世界。（入群请加 GitChat 小助手伽利略的微信，ID 为 GitChatty6，回复关键字「246」。）

![](https://images.gitbook.cn/988f0fe0-3527-11e9-8370-c7c9194e82b8)

分享上面的《敏捷中国史》阅读卡片，跟朋友一起了解中国软件开发方法的进化和一代程序员自我突破的故事。

