本章我们来讲二分查找的原理和流程图。

在此，因为我们讲的是通用算法的原理，因此，我们的算法要查找的序列虽然是有序的，但未必是等差数列，其中数字范围也不一定就是从1到1000——千万不要把自己局限在前面那个猜数游戏里。

因此，在本章中，我们还是将所有的待查数字都放在一个整型List中，让其中的每个元素保存一个待查数字。

### 二分查找原理

**二分查找** （binary search）是一种 **在有序数列中查找某一特定元素** （目标数）的查找算法。

  * 最初的待查数列和目标数由用户定义；

  * 查找过程是一个迭代（循环）过程：

    * 待查数列不为空时进入循环，否则查找 **失败** ——查找过程结束

    * 每次循环从待查数列的中心元素（位于正中间那个元素）开始：

      * 如果中心元素正好等于目标数，则查找 **成功** ——查找过程结束

      * 如果目标数大于或者小于中心元素，则在数列大于或者小于中心元素的那一半成为新的待查数列

这种查找算法每次将待查区域平分成两份（二分），并排除掉其中的一份，每次循环要查找的区域都只有上一次循环的一半！

下图就是一个例子：

![enter image description
here](https://images.gitbook.cn/e7b87980-9bc5-11e9-ac54-13ea42b6afc0)

#### 结构化的自然语言描述——流程图

原理说起来简单，但是怎么转化成代码呢？

不着急，我们先来画流程图——作者推荐各位读者在编写这类经典算法代码之前，先画出清晰的流程图，这样做，不是刻板教条，而是理清思路！

按照上面的描述，我们首先绘制出自然语言描述的流程图：

![enter image description
here](https://images.gitbook.cn/32cc7530-9bca-11e9-af01-8b81818e8a9b)

用这副图来对比一下上面的原理，看看是不是已经全都结构化表达了？

上图有一点需要说明的就是右下角这个两级嵌套的条件结构（粉色圈内）：

![enter image description
here](https://images.gitbook.cn/3eb725c0-9bca-11e9-af01-8b81818e8a9b)

因为在将中心元素和目标数对比的时候，实际上存在三种情况：

1.两者相等 2.目标数大于中心元素 3.目标数小于中心元素

我们的控制流程中，条件结构只能二分，而不能三分、四分……，所以，当我们要表达多于两种的分支路径的时候，就需要条件结构的嵌套。

可能有的同学会觉得，为什么条件流程只支持Yes和No两个路径啊，这样多不灵活。直接支持1，2，3，4……n个分支多方便啊？

这里恰恰是控制流程的 **精髓** 所在：用最简单、最少量的固定基础结构去组合复杂的状况，而不是将基础结构变得复杂多样。

惟其如此，才具备易检查，不易错的特性，也才有在数学层面被严格证明的可能。

### 形式化描述第一步——变量和赋值

之前我们学过，如果流程图的每个框里都填写的是代码，那么我们就可以对照不同结构的映射关系，直接将流程图转换成程序了。可是上面的流程图的矩形框、菱形框里，都是自然语言啊，怎么转化成程序呢？

其实，到现在为止，我们学过的编程语言相关的内容并不多，除了关键字，也就是变量和赋值了。

我们要用关键字来在程序中描述控制结构。那么控制结构之外的部分，能用变量和赋值来表达吗？

我们先来试试看——

#### 待查数列和目标数

首先，我们这个算法要处理一个数列，在这个数列里寻找一个目标数，那么至少，这个数列和这个目标数需要有变量来指代之。

我们用列表类型的变量arr来指代数列，而用整型的tn来指代目标数。

第一步：“初始化待查找数列和目标数”就变成了——初始化arr和tn。

如何初始化呢？当然就是给它们赋值，比如：

    
    
    arr=[3，5，8，12，15，21，36，47，58，62，74，103]
    tn = 5 
    

当然这里的arr和tn是任何值都可以，因此，我们可以先笼统地写成：

    
    
    arr = […]
    tn = ..
    

#### 限定查找区域

正式开始查找过程，就要进入循环了。

循环的进入条件是：“当前查找区域存在”。

且不论怎么判断查找区域是不是存在（这一点我们后面再说），先想想：我们怎么表示查找区域呢？

要知道，我们要查找的数列存放在List型变量arr中，因此，每次的查找区域一定是arr的一个部分（最开始是全部，第二次是全部的一半，第三次是全部一半的一半……）。

之前我们讲过List型数据（也包括它所表达的逻辑上的数组数据结构），有一个特点：每一个元素都有一个下标，而且这个下标是从0开始，连续逐次递增1。既然如此，用arr中任意两个元素的下标就可以划分出一个区域了。

比如下面这样：

![enter image description
here](https://images.gitbook.cn/556719b0-9bca-11e9-af01-8b81818e8a9b)

我们选中其中两个下标作为起止位置，则它们框定的从下标为5到下标为7的区间内的元素就形成了一个 **子数列** ，也就是一个 **区域** 。

为了区分一个区域的起始和终止，我们把划分区域的两个下标中数值小的那个叫low，大的那个叫high。比如上例中，low 值为5，而high值为7.

回到二分查找的被查找数列arr，我们可以用这两个变量：low和high来界定每次循环的查找区域。

第一次的查找区域是整个数列，因此在循环开始前有：

    
    
    low = 0 #数列第一个元素下标
    high = len(arr) – 1 #数列最后一个元素下标
    

虽然上面的自然语言流程图里没什么low和high，但是要转化成代码，就要加入它们，于是，我们的形式化流程图的第一个矩形框就变成了：

![enter image description
here](https://images.gitbook.cn/6e9fdb60-9bca-11e9-af01-8b81818e8a9b)

#### 获得查找区域的中心元素值

有了low和high，我们就可以标识出当前的查找区域，而其“中心元素”就是当前区域正中间的那个元素。

我们有了区域开头和结尾的下标，要取中间的还不容易嘛。这里，我们用一个新的变量——m，来表示中心元素的下标，于是：

    
    
    m = （low + high）/2
    

但是等一等，如果low + high的结果是个奇数怎么办？那样，它们的和除以二的结果就是小数了，而数组下标必须得是整数，这可怎么办呢？

我们可以规定，一旦遇到这种情况，就用（low + high）/2 之后数字下取整的结果，作为m的值。

在Python中，有一个内置函数int（），可以达到下取整的效果，于是：

    
    
    m = int((low + high)/2)
    

这里有一件事需要注意，之前我们讲过，在大多数编程语言中，整型值的取值是有限定范畴的。上面的式子里有“low +
high”，如果low和high都是很大很大的整数，它们的和很可能就超越了整型数据能够容纳数据值的上界。一旦如此，还没来得及除以二，就会出现溢出错误。

为了避免这个问题，我们一般将此处的取中心下标公式改为：

    
    
    m= int((high – low)/2) + low
    

这样，high和low不会直接相加，避免了溢出错误。

虽然Python3对整型数据做了特殊处理，我们可以认为不会发生溢出了，但是保留好的编程习惯有利于我们以后改写其他语言的程序。因此，这里我们还是沿用传统写法。

中心元素下表m有了取值之后，要拿到中心元素的值就太容易了，直接就是：arr[m]。

至此，所有需要形式化表达的实体都已经有了对应的变量和赋值过程。下一步就是对这些变量进行比较、判断和对整体进行流程控制了。请看下一章。

