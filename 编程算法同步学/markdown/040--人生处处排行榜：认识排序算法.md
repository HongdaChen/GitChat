从本章开始，我们要接触到一类新的算法：排序！

### 什么是排序（Sorting）

排序完全可以按照字面意义来理解，也就是：排列顺序。

排序算法做得事情，其实就是将一串数据按照某种特定的方式进行排列。

排序算法接受的输入是一个数据列表（此处的列表并不是Python中的list数据类型，而是指一系列虽然“连在一起“，但前后之间并没有顺序关系的元素）；输出是一个序列，与输入对应的元素集合是一样的，不过经历了排列的过程，而拥有了顺序。

说得更准确一点：

1.排序算法的输出是输入的一种排列或者重组；

2.排序算法的输出按照递增（或者递减）的顺序进行排列，排列结果为升序（或降序）序列。

> **小贴士**
> ：无论升序还是降序，排序算法其实是一致的，只不过是把较大的放后面还是把较小的放后面的区别而已。既然如此，此后在本课中如果没有特殊说明，我们所说的排序都指升序排序。

![enter image description
here](https://images.gitbook.cn/1b2ca910-a488-11e9-95c1-ebe16335a5d6)

### 无处不在的排行榜

排序是一个操作过程，而这个过程的结果叫做排名（Ranking）。有些时候，排名又会特别被称为：排行榜！

#### 显性排行榜

排名（排行榜）在我们的生活中无处不在，比如：

  * 集体行动时按大小个排队
  * 考试成绩排名
  * 展示富豪财富的福布斯排行
  * 综述高校实力的大学排行榜
  * ……

![enter image description
here](https://images.gitbook.cn/2c524f10-a488-11e9-95c1-ebe16335a5d6)

这些还只是显性的排行榜，另有许多隐性排序过程及结果，每天都在影响我们的生活。

#### 隐性排行榜

比如那个宇宙经典问题：

![enter image description
here](https://images.gitbook.cn/34094100-a488-11e9-8efd-09cc8f7db509)

表面上看起来，好像这只是一个口味好恶的问题，但实际上，却是一个排序问题——

> 临近午饭时间，写字楼里工作的小白开始考虑“今天中午吃什么”。
>
> 这时，小白实际上是根据——
>
> 食物种类（米饭炒菜、饺子、米粉、三明治、火锅、牛肉丸……）； 可得性（公司食堂、周围餐厅、外卖……）；
> 以及其他因素（天气如何？是否适合外出？身体的慵懒程度……）
>
> 对头脑中预置的就餐候选列表中的个体做了一轮综合打分，然后进行排序，得到了一个Ranking的结果，然后选取了其中的top1作为实际解决午饭地方。
>
> 如果是要和同事一起进餐，可能还要把各自的Ranking结果再做一次归并排序（Merge Sorting），然后选择双方都可接受的名列前茅的候选就餐地。

#### 搜索引擎中的隐性排序

我们日常用的搜索引擎，乍看起来是在做查找的工作——找到和我们的输入相关的在线资料的过程。

![enter image description
here](https://images.gitbook.cn/613f80d0-a488-11e9-95c1-ebe16335a5d6)

然而实际上，它做的是一个排序的工作：

  * 首先，将用户输入的搜索语句与自己从网络中获取的千百万份数字文档进行比较，确定搜索语句与各个文档数据的相关性（Relevance，通常这个相关性用一个分数来表示）；
  * 然后，将这些文档相关性分数进行顺序排列；
  * 最后，将相关性最高的若干文档显示给用户。

![enter image description
here](https://images.gitbook.cn/458a2660-a488-11e9-95c1-ebe16335a5d6)

当然，实际运行中除了相关性还会考虑一些其他因素比如文档及其来源的质量等等，不过相关性肯定是核心因素。

#### 排序算法的江湖地位

排序算法在所有计算机算法中，乃至在整个计算机科学中，都占据着非常重要的地位。基础算法是软件的核心，而查找和排序算法则是计算机基础算法的核心！

从计算机出现开始，排序问题就已经被大量研究。早在1956年，冒泡排序就被分析过了。

经过了几十年的发展，虽然如今大部分人认为排序是一个已解决的问题，无需再进一步投入研究。但仍然不断有新的排序算法被发明出来，比如2002年的Timsort排序，和2006年发明的图书馆排序等。

#### 排序算法的分类

从不同的角度，可以对各种排序算法进行不同标准的分类，比如：

  * 按照算法的时间复杂度进行分类
  * 按照空间复杂度（内存使用量）进行分类
  * 按照实现排序的方式（插入、交换、选择、合并等）进行分类

如上这些分类方法都有用得到的地方。不过，现在我们先把关注点放在排序过程的操作上。

**按照排序的操作方法，排序可以被分为两大类：i）比较排序和ii）非比较排序。**

### 比较排序

#### 比较排序的定义

**比较排序（Comparison Sorting）** 指通过比较操作来确定两个元素中哪个应该放在序列前面的排序算法。

在比较排序中，数据之间根据特定的原则进行 **比较** ， **任意两个数据相比都会有大于、等于、小于三种之一的结果**
，然后再根据比较结果确定两者的相对位置。

#### 全序集

比较排序要求被排序的数据具备两个性质：

  * 传递性：如果$a \leqslant b, b \leqslant c$ 则必有 $a \leqslant c$
  * 完全性：对于任意两个元素$a$和$b$，要么 $a \leqslant b$, 要么 $a \geqslant b$，没有第三种情况。

拥有这两个性质的集合叫做 **全序数据集合** ，简称 **全序集** 。

#### 比较排序的局限

全序集的模糊代数结构决定了，每次对其中的元素进行比较操作所获得的信息都是有限的。而这种信息获得的有限性导致了比较排序性能上的根本限制——在最差情况下，任何一种比较排序的时间复杂度都至少是
$O(n \log {n})$ 比较。

而与比较排序相对应的非比较排序（具体包括基数排序、计数排序、桶排序等算法），则有可能达到$O(n)$的时间复杂度。可以说非比较排序在某些情况下更具有性能优势。

#### 比较排序的优势

比较排序也有着它的天然优势：

  1. 它可以控制比较原则，因此可以对任何类型的数据进行排序。

数据比较原则多种多样，其中有一些信手拈来约定俗成的，比如对数字排序时按照数值大小，对文字（词、短语等）进行排序时按照字典顺序等等。

  2. 它还可以更好第控制如何排序。

比如将更大的数据放在后面是升序排列，反过来将更小的放在后面就成了降序排列。

  3. 对数据进行比较这一点，也与现实当中的许多问题契合。

大多数情况下，当我们对现实事物进行排序的时候，原本就已经对它们区分高下了。那么将这种高下之分直接转换为比较原则，则是顺理成章。

而且，非别叫排序的使用限制比较多，适用面相对窄。因此比较排序算法成为了排序的主流。

> **小贴士** : 在本课中，我们讲的所有排序算法都是前一种： **比较排序** 。在没有特殊说明的情况下，我们下面说的“排序”，就是“比较排序”。

