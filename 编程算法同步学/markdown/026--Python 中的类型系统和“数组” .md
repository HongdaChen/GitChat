### 编程语言的类型系统

#### 变量的数据类型和声明

程序中的每一个变量都有它的数据类型。

![enter image description
here](https://images.gitbook.cn/a4cd17a0-934d-11e9-b9bd-69ad1684fc56)

在大多数编程语言里，一个变量是什么数据类型，是需要被声明的。

在Java里，我们要用一个变量来存储整型值，那么我们需要在第一次写出这个变量的时候，写上它的数据类型。比如下面这个Java语句：

    
    
    int age = 20;
    

上面这行代码其实同时做了两件事情：

    
    
    1. 声明我们创建了一个变量：age，它的类型是整型（int）；
    2. 给这个整型变量赋值为20。
    

![enter image description
here](https://images.gitbook.cn/45696ce0-934e-11e9-b9bd-69ad1684fc56)

后面的Java程序再用到这个变量的时候，就不必再声明它的类型了，而可以直接使用，例如再次赋值：

    
    
    age = 30；// 声明后再赋值，代码中就不必出现“int”字样了
    

这是Java的处理方式，C以及其他很多语言都类似，当一个变量第一次出现的时候，都要特地显性地写出来它的数据类型是什么。

### 无须声明变量类型的Python

但Python却很不同， **Python中的变量不需要专门声明数据类型**
，而是通过第一次赋值，使得被赋值变量在被赋予了一个数据值的同时，拥有了和赋值变量、常量或字面量一致的数据类型。

例如下面这个Python赋值语句：

    
    
    age = 20
    

这个语句是age变量第一次在程序中出现的语句，通过这一句，age已经被设定为了整型变量，且当前值为20，而 **不必用一个数据类型关键字进行声明** 。

### 类型系统的特征

![enter image description
here](https://images.gitbook.cn/a1488f50-934e-11e9-b9bd-69ad1684fc56)

#### 静态类型 vs 动态类型

为了防止在代码中出现无意义的操作，编程语言的实现必须提供对操作数据的事先 **类型检查** 。也就是检验一下一个变量被赋值的类型和它被声明的类型是不是一致。

检查是必须做的，不过具体检查的时机，可以各语言自由选择。于是，有些语言在编译时进行，有些语言在运行时进行。

这种类型检查时间的具体时机选择就把编程语言分成了静态类型和动态类型两种：

  * **静态类型语言** ：每个变量都由程序员显示指定类型，一般都是在编译时进行类型检测。

  * **动态类型语言** ：仅有数据值有固定类型，变量一般不指明类型，一般在运行时执行对变量的类型检测的。

很显然，按照这种区分方式， **Python属于动态类型语言** 。

#### 强类型 vs 弱类型

不同类型的数据之间是否存在兼容关系，决定了一个语言数据类型的“强度”。从这个角度，我们可以把编程语言分成：

  * **弱类型语言** ：变量可以隐式地转换成其它数据类型。

  * **强类型语言** ：变量有严格的类型，要转换成其他类型，必须要显式转换。

**C就是一种弱类型语言** ，比如 **下面C代码** ：

    
    
    int main() 
    { 
        int x = 10;    // x 被声明为整型变量
        char y = 'a';  // y 被声明为字符型变量
    
        x = x + y; // y被隐性转换为了整型，在ASCII码中，’a’的整型值为97
    
        float z = x + 1.0; // x被隐性转换为了浮点型
    
        printf("x = %d, z = %f", x, z); 
        return 0; 
    } 
    

运行的结果是：

> x = 107, z = 108.000000

而 **Python则是强类型语言** ，在Python中，不允许如C中那样的隐性转换，下面这段 **Python代码** 运行会出错：

    
    
    a = "1"
    a = a + 2
    print(a)
    

运行结果：

> Traceback (most recent call last):  
>  File "C:/Users/jull/PycharmProjects/test/test.py", line 8, in  a = a + 2
> TypeError: must be str, not int

Python代码要改成下面这样，才能正确打印出3：

    
    
    a = "1"
    a = int(a) + 2
    print(a)
    

不过有一点要注意——下面这段代码是正确的：

    
    
    a = "1"
    a = 3
    print(a)
    

同样能打印出3。

这是因为在Python中，每一次赋值都是独立的，可以给变量指定新的数据类型。

a最初被赋予字符串型值“1”，但是之后又被赋值为整型的3，那么后面的赋值覆盖前面的赋值，在print(a)时，a的类型是整型的。

这也是动态类型的特点。

### Python中的数组

因为后面的算法大多要用到数组，所以我们特别需要说明一下Python程序中的数组变量。

#### 逻辑上的数组

其实，我们在下面以及后面章节中的Python代码中，用来表示逻辑上数组的变量的数据类型叫做 **列表（List）**
，它是Python内置的6个序列类型之一。

Python的序列类型变量都是由一组元素组成，其中每个元素都有一个位置信息（或称为索引，对应数组中的下标），第一个索引是0，第二个索引是1，依此类推。

序列类型都可以进行索引，切片，加，乘，检查成员等操作，比我们之前讲到的数组要复杂得多，使用起来也要方便得多。

列表是最常用的Python数据类型，它可以用一个方括号框着一系列用逗号分隔的值的形式出现。

具体到其中的某一个元素，也可以用变量名加上方括号括上对应索引来表示——和大多数编程语言中数组元素的表示方法一致。

因此，我们用Python的列表类型来表示逻辑上的数据结构——数组！

#### 列表和元素

理论上讲，Python的一个列表中的不同元素，可以是不同类型的，比如下面这段Python代码，是正确的：

    
    
    arr = [2, 3, "apple", 52, 'c', True]
    print(arr)
    

输出是：

> [2, 3, 'apple', 52, 'c', True]

但一般在使用中，我们很少这样用，还是倾向于让一个列表中的各个元素都属于相同类型。

另外，Python有一种特殊的语法：用-1作为下标时，可以直接访问列表的最后一个元素，比如：

    
    
    arr = [2, 3, "apple", 52, 'c', True]
    print(arr[-1])
    

输出是：

> True

这样很方便，但是，作者不建议初学者用这种简便的方法。因为从一开始就这样用，不利于锻炼对于数组概念的理解和应用。

作者建议同学们用下面这种方式来访问数组的最后一个元素：

    
    
    print(arr[len(arr)-1])
    

虽然写起来麻烦了一点，但是每写一次就提醒我们：数组是从0开始索引的，最后一个元素的下标等于该数组的长度减去1——熟悉这样的基础概念对于刚接触编程的人还是蛮重要的。

#### 列表的赋值和赋值

一个列表量和通常的变量一样，有一个名字（标识符）表示它。

我们可以直接给它赋值，比如下面这个：

    
    
    arr = [1,5,8,19,3,2,14,6,8,22,44,95,78]
    

两个列表之间可以互相赋值，比如：

    
    
    arr_new = arr
    

如此一来，就把arr原本的值赋给了arr_new.

列表中的某一个元素也可以被单独赋值，例如：

    
    
    arr[0] = -3
    

如此一来，arr的第一个元素的值就变成了3.

让我们把上面的几个语句连成一段代码，再打印变量值来看看：

    
    
    arr = [1,5,8,19,3,2,14,6,8,22,44,95,78]
    arr_new = arr
    arr[0] = -3
    print("arr is:    ", arr)
    print("arr_new is: ",arr_new)
    

再看结果之前先自己想想打印出来是什么样的？

现实结果是这样的：

> arr is: [-3, 5, 8, 19, 3, 2, 14, 6, 8, 22, 44, 95, 78] arr_new is: [-3, 5,
> 8, 19, 3, 2, 14, 6, 8, 22, 44, 95, 78]

噫？怎么回事？

**_怎么arr_new的第一个元素也变成-3了？我明明只修改了arr啊？_**

这是因为，当我们采用简单的赋值符号（=）将一个List的值赋给另一个List的时候，实际上只是让两个不同标识符（arr和arr_new）都可以代表一个实在的数值序列而已。

这时，虽然有了两个名字，但是它们两个都指向同一个List，也就是[1,5,8,19,3,2,14,6,8,22,44,95,78]。

当我们通过arr[0]修改了这个List的第一个元素值之后，在通过arr_new来浏览这个List内部的每一个元素值，自然会发现，第一个元素变成了-3.

这样简单赋值，arr_new实际上是成了arr的 **别名** 。

形象点说：就好像有一个人原本叫张三，现在他起了一个别名叫李四。然后他上完了大学，个人属性发生改变，学历从高中变成了本科。这个时候，叫李四那个人的学历自然也就成了本科了。

如果我们不是要这样起别名，而是要生成一个当前值和arr一摸一样的新List，该怎么办呢？用List内置的copy函数，具体方法如下：

    
    
    arr = [1,5,8,19,3,2,14,6,8,22,44,95,78]
    arr_new = arr.copy()
    arr[0] = -3
    print("arr is:    ", arr)
    print("arr_new is: ",arr_new)
    

输出结果是：

> arr is: [-3, 5, 8, 19, 3, 2, 14, 6, 8, 22, 44, 95, 78] arr_new is: [1, 5, 8,
> 19, 3, 2, 14, 6, 8, 22, 44, 95, 78]

这一点蛮重要的，如果不注意和可能引起严重而隐蔽的bug.

