### 函数的参数和其值的变化

#### 两段代码

我们先来看看下面这两段代码，分别推测一下它们输出应该是什么？

建议大家先不要看后面给出的结果，也不要急着把代码放到运行环境里去试，而是自己先推演一下。

    
    
    def testScalarParam(a):
        a = a * 2
        return a
    
    x = 3
    y = testScalarParam(x)
    
    print("x is", x)
    print("y is", y)
    

**_代码-1_**

    
    
    def testListParam(arr):
        for i in range(0, len(arr)):
            arr[i] = arr[i] * 2
        return arr
    
    xArr = [1,2,3,4,5]
    yArr = testListParam(xArr)
    
    print("xArr is", xArr)
    print("yArr is", yArr)
    

**_代码-2_**

好好想想，输出到底是什么？

![enter image description
here](https://images.gitbook.cn/6cfcb940-c096-11e9-b2df-29c9ec00ee5c)

#### 代码输出

答案揭晓——输出其实是下面这样的：

代码-1输出：

> x is 3 y is 6

代码-2输出：

> xArr is [2, 4, 6, 8, 10] yArr is [2, 4, 6, 8, 10]

#### 函数参数值得变化

这是怎么回事？

  * 代码-1中，在调用 testScalarParam() 函数的时候，将 x 作为参数传给了它，之后在函数内部，参数变量明明被重新赋了值，可是为什么等到调用完成之后，再打印曾经做过它参数的 x，还是原来的值啊？

  * 代码-2中，传给 testListParam() 函数的参数 xArr，在函数内部被修改——重新赋值，调用完成后再打印，就是重新赋值之后的样子了。

为什么看起来这么像的两个函数，对于参数的处理，这么不一样呢？一个函数的参数，如果在函数内部被赋了新值，在函数结束后，这个参数的值到底是变还是不变啊？

要搞清楚这个问题，我们需要来学习几个重要的概念。

### 几个概念

#### 参数传递问题

类似的问题，也出现在 C 和 Java 之类更“年长”的编程语言中。

在那些语言里，用来讨论一个变量作为一个函数的参数，被“传递”进这个函数，在函数体内进被重新赋值，再到函数结束后，这个变量的值变或者不变的问题，叫做函数的
**参数传递问题** 。

讨论函数的参数传递问题，一般会看这个参数在传递给这个函数的时候，到底是“传值（pass by value）”还是“传引用（pass by
reference）”的。

#### 传值 vs 传引用（*）

> **NOTE** ：传值与传引用的问题曾经是笔试或者面试非常热衷的考察点，如果你是 C 或者 Java 程序员，务必把这个问题弄清楚。
>
> 不过对于 Python 来说，“传值 vs 传引用”的问题是不存在的。因此，本节属于本课的“超纲”部分，在这里仅作参考。也可以直接跳过。

传值和传引用可以用下面这副图来清晰地解释：

![enter image description
here](https://images.gitbook.cn/fee44c00-c097-11e9-ac57-dbec8b23aec1)

##### **传值**

上图的右侧部分表示的是参数“传值”操作。

当一个变量被作为参数“传值”给函数的时候，其实是在传递的那一刻生成了一个该变量的分身，将这个“分身”传给了函数。在函数里无论如何重新赋值，影响的都是这个分身，原变量本尊一点都没变。

所以传值的参数变量，在函数结束后仍然还是传递前的原值。

##### **传引用**

上图中左侧则是参数“传引用”的操作。

当一个变量作为参数被“传引用”给函数的时候，就是将“它自己”传给了函数，在函数内部的每一次赋值操作，都导致了原变量本尊取值的改变。

因此，传引用的参数变量，在函数结束后取值是很可能有所改变的，具体要看函数体内是否给它重新赋了值。

#### 传对象 vs 传对象引用

Python 的函数参数传递，传得既不是值（value）也不是引用（reference），而是 **对象** （object）或者 **对象引用**
（object reference）。

##### **Python 中的对象：可变 vs 不可变**

**在 Python 中一切都是对象，但对象又分为可变（mutable）对象和不可变（immutable）对象** 。

可变对象在传递给函数后，是可以在函数内部修改的，不可变对象则不行。

对于 Python 的内置数据类型而言：

  * 可变对象有：列表（List）、字典（Dict）和集合（Set）；

  * 不可变对象则包含：整型（int）、浮点型（float）、布尔型（bool）、字符串型（string），和元组型（tuple）。

##### **Python 的参数传递**

要彻底搞清楚可变 vs 不可变对象，以及传对象 vs 传对象引用的问题，需要去学习 Python 的执行模型（execution
model），会涉及到很多编程语言设计层面的概念和内容。

如果大家有兴趣欢迎自己研究：<https://docs.python.org/3/reference/executionmodel.html>

但其实，忽略编程语言在编译或解释过程中与硬件结合的细节，仅从用户的角度来看，无论传值/传引用还是传对象/传对象引用，其实效果都是差不多的。

具体到 Python 语言中，传对象和传对象引用的区别，我们不罗列定义和抽象解释，而是从感性角度来用例子展开。让我们用下面的两个函数为例来解释 Python
的函数参数传递问题。

### 煮()函数和混合煮()函数

我们用两个直观的例子来看看 Python 对不同的函数参数的处理：

#### 传对象

我们先来看看下面这个煮()函数。这是它的定义：

![enter image description
here](https://images.gitbook.cn/950a8dd0-a495-11e9-95c1-ebe16335a5d6)

其中的“食物”就是传入函数体的参数，它是一个 **不可变对象** ，以 **传对象** 的方式传给“煮”函数。

这种参数传递方式，相当于将这个对象拷贝了一份，进入到函数之中的，是它的替身，而不是自己，在函数内部，所有针对这个参数的操作，都作用到了“替身”身上，对本尊并无妨碍。（类比一下传值操作，颇有些异曲同工之妙啊。）

我们来看看对它的调用。

调用-1：

![enter image description
here](https://images.gitbook.cn/a51f11f0-a495-11e9-8efd-09cc8f7db509)

调用-2：

![enter image description
here](https://images.gitbook.cn/ab758980-a495-11e9-8efd-09cc8f7db509)

调用-2运行完之后，food 的值仍然是“汤圆”而不是“熟汤圆”。

这是因为，在将参数传给煮()函数的时候，煮()函数只是“看了一眼”传过来了参数是哪种食物，然后又“自己另外去拿了一份同样的食物，但没有直接烹饪原本那份食物”！

煮()函数完成调用之后，cookedFood 的值是“熟汤圆”，而 food
还是原来的“（生）汤圆”。它只是拿给煮()函数当成样子看看，而并没有真的投进锅里去。

当我们需要连续煮一系列食物的时候，需要像下面这样处理（调用-3）：

![enter image description
here](https://images.gitbook.cn/b64a5d40-a495-11e9-8efd-09cc8f7db509)

对于煮()函数而言，someFoods
就像一个样品盒，煮()函数这个厨师“看到"其中一种食物，就从别处找个同样的来拿去锅里煮，煮好后放到事先准备好的另一个食品盒——someCookedFoods
里面去，如此一样一样食物地操作。

等每一样食物都煮好以后，原本样品盒里的东西没动，而又多出来一系列熟食物放在 someCookedFoods[] 里！

![enter image description
here](https://images.gitbook.cn/c2ab9d60-a495-11e9-b802-f18daf16e87f)

#### 传对象引用

我们来看看另一个函数：混合煮()，它的定义如下：

![enter image description
here](https://images.gitbook.cn/cc363de0-a495-11e9-95c1-ebe16335a5d6)

混合煮()函数的参数是一个 List，也就是一个 **可变对象** ，对于这类的参数，Python 的处理是将该对象的引用传给函数—— **传对象引用**
。

传对象引用的方式，就是将一个对象本尊作为参数传递给函数，这个对象进入函数体内后，在其中对这个对象做的所有事情，都落实到了本尊身上！

调用混合煮()非常简单：

![enter image description
here](https://images.gitbook.cn/df42f360-a495-11e9-b802-f18daf16e87f)

> **NOTE** ：混合煮没有返回值！

于混合煮()函数而言，someFoods 是一个实际的食物盒，里面装的东西一起倒到锅里去混在一起煮，哪样熟了就把哪样捞起来放到原来的食物盒里。

函数运行之后 someFoods 列表中的元素值都变了——食物盒里面的东西不仅顺序变了，而且都变成了“熟的”。

![enter image description
here](https://images.gitbook.cn/e746ccd0-a495-11e9-b802-f18daf16e87f)

### 函数参数问题的简化理解

前面的内容可能乍看起来有点容易乱，对刚刚接触 Python 函数的初学者而言，也许一下子理解不了。

如果真是理解不了，不要着急。在本课中只需要记住：函数的参数的数据类型是基础类型——例如整型，还是列表（List）类型，是一件非常关键的事情，我们要将这两种情况分开对待——

  * 如果某个变量是一个整型变量，那么就算把它传给了一个函数，函数里面无论怎么扭曲折磨它，调用完了之后，它的原值仍然不变！

  * 反过来，如果把一个列表变量传给一个函数，函数调用之后，列表中元素的内容很可能就变了！这个要注意。

虽然像本章开头代码-2中那样，函数在处理了一个列表变量之后，再将它作为返回值返回出来，也是可以的。但是其实，这个程序里的几个列表变量，指向的都是同一个列表对象，只不过其中的元素值经过函数以后改变了而已。

![enter image description
here](https://images.gitbook.cn/fa5eccf0-a495-11e9-95c1-ebe16335a5d6)

故而， **作者建议**
：以后遇到要直接经由一个函数修改列表中元素值的情况，就不要再将修改结果经返回值传递出函数了，这样更容易搞乱。干脆就在原来的参数变量中改就好了。

也就是说代码-2建议改成下面这样：

    
    
    def testListParam(arr):
        for i in range(0, len(arr)):
            arr[i] = arr[i] * 2
        return
    
    xArr = [1,2,3,4,5]
    print("Before function:", xArr)
    testListParam(xArr)
    print("After function:",xArr)
    

输出结果：

> Before function: [1, 2, 3, 4, 5] After function: [2, 4, 6, 8, 10]

这也就是为什么，上一章中我们 swap() 没有返回值的原因。

