### 二叉树树的遍历

#### 树的遍历和图的遍历

在计算机科学里，树的遍历指按照某种规则，不重复地访问树的所有节点的过程。具体的访问操作可能是检查节点的值、更新节点的值等。不同的遍历方式，其访问节点的顺序是不一样的。

因为树是图的一个子集，因此，树的遍历，也属于图遍历的子集。图遍历的原则主要有深度优先和广度优先两种。

这两大遍历原则对于树也同样适用。又因为有根树是树的一种，二叉树是有根树的一种，二叉树的遍历也分为深度优先和广度优先两种。

不过在实际应用中，对二叉树而言，深度优先用得更多。

下面我们具体讲一下二叉树的几种遍历方式。

#### 二叉树的深度优先遍历算法

深度优先遍历二叉树的算法又有分为三种：先序遍历（Pre-Order Traversal），中序遍历（In-Order
Traversal）和后序遍历（Post-Order Traversal）。

这里的先、中和后所指向的主体是什么呢？是 **根节点** 。

先、中、后序遍历实际上是 **先根序，中根序** 和 **后根序** 遍历。

这三种算法的 **区别** 就在于：在访问一棵树的时候，是先访问根节点，在“半截/中间”访问根节点，还是在最后访问根节点。

但无论那种遍历，都要：

  * 把一棵树拆成左子树、右子树和根三个部分；
  * 再将左右子树分别作为两棵树划分左右子树和根，如此层层深入下去；
  * 直到一棵子树只有一个节点为止。

比如下面这棵二叉树：

![enter image description
here](https://images.gitbook.cn/cdce5cf0-7f9c-11e9-a72f-db858373b063)

我们来对它进行层层划分，就像下面这样，红色圈内是左子树，绿色圈内是右子树，没有被圈上的是根节点。

![enter image description
here](https://images.gitbook.cn/dd503e00-7f9c-11e9-b041-13225ca87d14)

#### 中序遍历

中根序的遍历过程是这样的：

  * 先访问根节点的左子树，
  * 然后访问根节点，
  * 最后访问根节点的右子树。

在访问子树的时候，也遵循同样的——“左子树->根->右子树”——的原则。

我们对二叉树进行中序遍历， 遍历结果用序列表达，应该是：{{左子树遍历结果}，1，{右子树遍历结果}}

左右子树的遍历结果再细化下去，直到一棵树的左右子树都只有0-1个节点为止——就像上图中（7），（8），（9），（10）那样，这4棵子树算是“到了头“，无法再被细分了。

我们按中序来看上图中（7）-（10）这4棵子树的遍历结果：

  * （7）子树的输出为：{12，7，13}
  * （8）子树的输出为：{14，8}
  * （9）子树的输出为：{15，9，16}
  * （10）子树的输出为：{11，17}

然后将这些输出带入到上一层：

  * （8）带入（4），得出（4）子树的输出为：{{14，8}，4}
  * （9）带入（5），得出（5）子树输出为：{{15，9，16}，5，{10}}
  * （10）带入（6），得出（6）子树输出为：{6，{11， 17}}

将目前的输出再带入上一层：

  * （4）和（5）带入（2），得出（2）子树的输出为：{{14，8，4}， 2， {15， 9， 16， 5， 10}}
  * （6）和（7）带入（3），得出（3）子树的输出为：{{6，11， 17}，3，{12，7，13}}

将（2）和（3）子树输出带入顶层：

  * （2）和（3）带入（1），得出整棵树最终的输出为：{{14，8，4， 2， 15， 9， 16， 5， 10}，1，{6，11， 17，3，12，7，13}}

#### 先序遍历

先序遍历的顺序是：根->左子树->右子树，具体逐层深入的方法和中序遍历是一样的。

对应上面的例子，先序遍历就变成了下面这样：

底层子树：

  * （7）：{7，12，13}
  * （8）：{8，14}
  * （9）：{9，15，16}
  * （10）：{11，17}

代入上一层：

  * （4）：{4，{8，14}} 
  * （5）：{5，{9，15，16}，{10}}
  * （6）：{6，{11，17}}

代入再上层：

  * （2）：{2，{4，8，14}，{5，9，15，16，10}}
  * （3）：{3， {6，11，17}， {7，12， 13}}

代入顶层：

  * （1）：{1， {2，4，8，14，5，9，15，16，10}，{ 3， 6，11，17， 7，12， 13}}

#### 后序遍历

后序遍历的顺序是左子树->右子树->根，具体逐层深入的方法和中序、先序遍历也是一样的。

对应上面的例子，后序遍历就变成了下面这样：

底层子树：

  * （7）：{12，13，7}
  * （8）：{14，8}
  * （9）：{15，16，9}
  * （10）：{17，11}

（4）：{{14，8}，4} （5）：{{15，16，9}，{10}，5} （6）：{{11，17}，6}

（2）：{{14，8，4}，{15，16，9，10，5}，2} （3）：{{11，17，6}，{12，13，7}，3}

（1）：{{14，8，4，15，16，9，10，5，2}，{11，17，6，12，13，7，3}，1}

无论是中序、先序还是后序遍历，都是从根节点开始“往下“走，往深层次走，所以叫做 **深度优先遍历** 。

#### 二叉树的广度优先遍历算法

和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。

二叉树的广度优先遍历又称 **按层次遍历** 。就是从根节点开始，每一层从左到右，把当前层都遍历完之后再进入下一层，每层都是从最左侧节点开始。

例如上面例子里的那棵树，如果是广度优先遍历则是下面这个顺序：

![enter image description
here](https://images.gitbook.cn/f0e9ca30-7f9c-11e9-a72f-db858373b063)

最后的输出为：{1，2，3，4，5，6，7，8，9，10，11，12，13，14，15，16，17}

关于树和二叉树的操作还有多种，比如：构建、查找、旋转等等。每个都有相应的一种或多种算法，也都很重要，不过遍历是所有算法中的最基础。

### 树和图的现实意义

为什么树和图这样的逻辑结构这么重要呢？是因为在现实当中，有很多事物的抽象结果，就是树或者图。

#### 图的抽象

比如前面提到的柯尼斯堡七桥问题问题，原本是两座小岛，两岸和七座桥，再加上两岸的建筑之类，画出来一幅很复杂的地图。

![enter image description
here](https://images.gitbook.cn/0484dd00-7f9d-11e9-a72f-db858373b063)

现在，我们要研究如何不重复地经过所有这七座桥，那么我们就可以将除了桥和岛、岸之外的其他地貌、建筑都忽略掉，变成下面这样：

![enter image description
here](https://images.gitbook.cn/0aaa0b60-7f9d-11e9-b041-13225ca87d14)

又因为我们要研究的是“经过”桥，因此，我们这要把七座桥的相对位置和连通方式表达出来即可。

于是，进一步把桥抽象成边，将它们的起止点抽象成顶点，就有了下面这个图（Graph）结构：

![enter image description
here](https://images.gitbook.cn/130e0630-7f9d-11e9-9482-6704bcd43149)

#### 树的抽象

树结构的抽象更为常见。我们来看几个例子：

**Case1** ：下面是利用16S 核糖体RNA绘制的系统发生树——系统发生树（phylogenetic
tree）又称演化树或进化树（evolutionary tree），是一种用来表明具有共同祖先的各物种间演化关系的有根树结构。

下图根在最下面，将它倒过来，就是一棵我们熟悉的树了。其中，三个最大分支分別为細菌、古菌和真核生物。

![enter image description
here](https://images.gitbook.cn/1f9b1140-7f9d-11e9-b041-13225ca87d14)

**Case2** ：计算机的目录结构也是有根树:

![enter image description
here](https://images.gitbook.cn/250d9170-7f9d-11e9-b041-13225ca87d14)

在Windows下命令行用tree 命令就可以看到目录树。

**Case3** ：企业的组织架构图也是典型的有根树：

![enter image description
here](https://images.gitbook.cn/3aed3d10-7f9d-11e9-b041-13225ca87d14)

**Case4** ：与组织架构类似，家谱也是一种有根树结构，比如下面这张世系表：

![enter image description
here](https://images.gitbook.cn/418f63a0-7f9d-11e9-8c78-99eb5a2d4558)

> **小贴士** ：有些家谱中把夫妇分为两个节点，然后再标明关联关系（比如下面这张），这就不是严格的树形结构了，至于为什么，请回顾树的定义。
> ![enter image description
> here](https://images.gitbook.cn/46b60dc0-7f9d-11e9-b041-13225ca87d14)

### 图 vs 树

#### 树为图的真子集

前面提到过，树是图的一类特例。那么自然所有的树都是图，但并非所有的图都是树。

  1. 树中不同节点间的连接有方向。

> **NOTE**
> ：在有根树中所有的连接都是从根开始，向叶子蔓延的，所以无须特意标出方向，我们在本章和上一章的有根树的图形中并没有标出方向，是因为方向默认，而不是不存在。

  1. 还有，树中没有环。

### 树相对于图更加严谨

简单来讲， **相对于图，树的限制更多** ，因此树形结构相对于典型的图（非树的那些图），更加严整、严谨。

举个非常直观例子：

>
> 如果一本小说中的人物关系基本上是树或者森林（多棵树）形状的结构，那么相对而言，小说的结构就比较规整，小说作者对于全局的掌控力比较强，整体的人物设置、情节安排乃至背景一般都是经过精心设计的。
>
> 但如果小说的人物关系是一张图（有环、无序），那么整体结构一般相对松散，作者在创作时的随意性较大。

作为我国古典小说的巅峰的四大名著，主体人物设置都是树或森林结构：

  * 《红楼梦》中的四大家族，
  * 《三国演义》中的政治军事集团，
  * 《水浒传》里108将聚义后的梁山， 
  * 《西游记》里的西天、天庭体系

都可以通过家谱树或者组织架构图来描绘。

![enter image description
here](https://images.gitbook.cn/202c6e10-847a-11e9-b2bb-451f18cbdadc)

而一些未经文学家整理的民间著作，比较典型的有各种评书、评话作品，往往缺乏自始至终的整体设计，而是“想到哪儿说到哪儿”。

一部书能有一个贯穿始终的人物（书胆）就很不错了，往往缺乏统一的整体设计。经常忽然出现各种与之前情节毫不相关的新人物和支线。

这样的作品，如果描绘人物关系图，几乎无法确定根、枝、叶，只能围绕书胆绘制成一张无向有环的图（Graph）。

比如有部评书作品叫做《雍正剑侠图》——以侠客童林为书胆，一会儿天南一会儿地北，各色奇形怪状的人物轮番登台，真是一幅“雍正剑侠Graph”。

![enter image description
here](https://images.gitbook.cn/2c99ffb0-8479-11e9-bf73-a153754b1981)

