### 以二分查找为例，看看“掌握算法的几个层次”

#### 掌握算法的几个层次

在前面，我们讲过学习一个算法的几个层次：

![enter image description
here](https://images.gitbook.cn/4e400370-9cc1-11e9-9de5-1dded3bba781)

#### 理论联系实际

现在我们就以刚刚学习过的经典二分查找算法为例，来讲解一下这几个层次对应到实际中是什么样子的。

#### Level - 1：听说

知道有个算法叫做“二分查找”，知道这个算法的目的是在一个 ** _有序的_** 序列里找到目标数所在的位置，或者确认其不存在该序列中！

#### Level -2：了解

了解二分查找的 **基本原理** ，能够用自然语言描述出算法运行的过程。

知道二分查找和顺序查找不同，不是“挨着找“的，是”跳着找“的，而且是每次跳一半儿，所以它也叫 **折半查找** 。

因为跳跃的缘故，所以很多元素的数据值根本没有被读取过，还要保证查找结果的正确性，那么就必须是一个有序的数组。

它的 **优点** 是快，但却无法处理数列无序的情况。

#### Level-3：理解

有基本的数据结构的知识，掌握最基础的序列结构：数组。并知道二分查找所采用的数据结构就是逻辑上的数组。

知道二分查找算法是在一个承载了有序数列的逻辑数组上寻找目标数的过程。

面对一个具体的待查数组和目标数，可以人肉模拟计算机，实现算法（例如向下图那样，在数列中寻找51）。

![enter image description
here](https://images.gitbook.cn/84495390-9cc1-11e9-b48e-bd06d4a7bdd5)

知道二分查找的时间复杂度是$O(\log{n})$，并且为什么是$O(\log{n})$。

#### Level-4实现

能够在没有任何外界信息提示的情况下，绘制出详细到变量层面的算法流程图。

能用Python（或任何其他）语言正确无误地实现经典二分查找。

#### Level-5应用

这一层面包含两部分内容：

  1. 在掌握了经典二分算法的基础上，能够自己推导出二分查找的几种变形算法。比如前面讲过的有重复元素的二分查找和旋转数列的二分查找。

  2. 在遇到没有直接告知你使用二分查找的情况下，能够根据具体的实际问题准确判断出应该用二分查找，并针对当时情况对算法进行相应的变形。

### 感性认识Level-5

对于第5层的第2重含义，我们来看个例子：

#### 一道例题

**题目** ：实现一个函数，满足如下要求：

    
    
    1）  它的输入是一个正整数
    2）  它的输出也是一个正整数
    3）  输出值是与输入值的平方根距离最近的那个整数
    4）  整个函数中只能使用加减乘除运算，而不能使用开平方函数
    5）  算法时间复杂度要尽量小
    

### 例题求解

#### 函数要素

这个问题要求我们写一个函数，那么就先来看看函数四要素吧，除了函数体，其他三个都好解决：

  * 函数名

函数名最好能够简洁地反应功能，通过 _要求3）_
可见，这个函数的作用是求离输入数据的平方根距离最近的整数，那么我们就起名叫closestSqrt（最接近的平方根）好了。

  * 参数

_要求1）_ 已经明确说了，输入是一个正整数，那么我们的参数列表就是一个整型参数：n。

  * 返回值

返回值也是一个正整数。因为返回值是在函数体中实现的，因此我们和函数体一起来看。

#### 函数体

函数体就是实现函数功能的具体逻辑了。

在这个函数中，我们要做什么呢？我们要做的是：求一个整数的平方根。

但按照 _要求4）_ ，又不能直接开平方，那该怎么做呢？

既然要求返回值是离输入的正整数平方根最近的那个整数，那么最笨的方法：我们可以从1开始试，分别用1，2，3，……
各个数字和自己相乘，然后看看这些数字的平方与输入参数n的关系：

  * 如果到了某个数字，它的平方正好等于n，那它就是我们要找的输出，直接返回它。

  * 如果某个数字的平方小于n，但是它加上1之后的平方就大于n了，那就说明n的平方根是一个位于当前这个数字和比它大一的整数之间的一个小数。

这个时候我们就要看：当前数字和比它大一的那个整数，谁的平方离n最近，就返回谁。

大致思路是这样，我们当然可以一个接一个数字的试，看它是否满足前述条件，但是我们是在正整数数列中查找，这个数列是天然有序的呀！

在有序数列中查找，又何必要用顺序查找算法，用二分查找不是时间复杂度小得多吗？

于是，就有了下面这个函数：

    
    
    def closestSqrt(n):    
        if n <= 0:
            print("input number is not invalid")
            return -1
    
        low = 1
        high = n
    
        while low <= high:
            m = int((high - low) / 2) + low
    
            if m * m == n:
                return m
            elif m * m < n and (m + 1)* (m + 1) > n :
                if n - m * m  > (m + 1)* (m +1 ) - n:
                    return m + 1
                else:
                    return m
            else:
                if m * m  >  n:
                    high = m - 1
                else:
                    low = m + 1
    
        return -1
    

大家可以看到，closestSqrt()函数结构和经典二分查找算法非常接近，主要差别体现在判断条件上。

#### 学习算法的误区

有些同学在学习了算法流程图或者看到了算法代码示例后，采用强行背记的方法，把流程图或者源码死记硬背下来。无论是重画经典算法流程图，还是直接用Python写出经典算法的实现代码，都能完成。

如此，看起来好像到了Level4的程度。但其实，他们对于其中每个步骤的含义并不理解。一旦对于记住的部分有稍许遗忘，就无法独立完成代码。

这种情况下，其真实水平连level3都未必有！

大家在自己学习的时候，一定要避免这种状况，不要刻意背诵算法流程，而是要首先搞清楚原理，然后逐步推导出流程，再从流程对应到代码。

#### 学会之后——创新

掌握程度到了 **level5** ，能够变形和熟练运用后，我们就可以算是 **学会了一个算法** 。

那么然后呢？在学会之后，还有没有更进一步？

当然有啦，学会之后，还要创新啊—— **优化（改进）算法** 和 **发明算法** ！

![enter image description
here](https://images.gitbook.cn/98613780-9cc1-11e9-b48e-bd06d4a7bdd5)

微创新：在现有算法的基础上对其进行进一步优化，以扩展功能，或者减低时间或者空间复杂度。

再进一步的，全面创新：发明新的算法！

其实何止算法，任何知识、技术，从接纳到创新的发展阶段，大抵如此。

