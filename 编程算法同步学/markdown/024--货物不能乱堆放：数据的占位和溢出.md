### 溢出

讲过了进制，我们回头来讲溢出。

#### 限定位数的数值表达

在位数不受限制的情况下，利用进位制，我们可以使用有限种数字符号来表示所有的数值。

但如果限制数位会如何？

还是用我们熟悉的十进制举例子：

> 假设我们规定，某一个整数是十进制数，但是它最多总共只能占两位——只能有两个数位，也就是最低的两位：个位和十位。
>
> 那么它最小能表达的是 0， 最大能表达的是99。
>
> 当我们给99加上1的时候，它的个位和十位都进了位，可是因为百位对于它根本不存在，于是最前面的1没有了，结果变成了99 + 1 = 0 。

这种现象，就叫做溢出。

#### 计算机中的溢出问题

原本三位的数字我非要放到两个数位里去，肯定是放不下啊。放不下非要硬放，于是就会出现错误，把最高位给“挤没了”。这个错误的名字叫做 **溢出** 。

溢出现象在平时我们徒手做数学计算的时候并不会出现，做算术题，位数不够了随时往前加就是了，草稿纸写到头了就换一张，总能继续往前写。

计算机里面可就不一定了，计算机里面的存储空间是有限的！

一般的编程语言给某一特定类型的数据值分配的存储空间大小是固定的，就那么多位，数字太大了就装不下——直观上可以理解为货太多，把货架撑爆了！

#### 二进制数的溢出

其实无论什么进制，在位数限定的情况下，都存在溢出这种现象。

不过，因为我们讲得是计算机，而计算机中用的是二进制，因此，当我们考虑程序中数据溢出的问题时，应该将数据转化为二进制来考虑。

2019年初有一部非常火爆的科幻电影《流浪地球》，里面有位力挽狂澜的程序员李 一 一（下图）。

![enter image description
here](https://images.gitbook.cn/2c1a3270-8e6b-11e9-bf3b-49545f004142)

根据他的名字和他的背景我们可以推测，他生在一个程序员之家，他家至少有四个孩子：李零零（00B），李零一（01B），李一零（10B），和李一一（11B）。

而最多只有五个孩子，如果有第五个的话应该叫李溢出。如果再有第六个，他们的名字就必须全部重新编码。否则老五和老六都叫溢出，怎么区分呢？

#### Java整型值的占位与溢出

因为Python对于整型值的处理和大多数编程语言不同，我们先以Java为例，来看看整型值溢出是怎么回事。

#### Java的整型数据取值范围

Java语言分配给整型数值的存储空间是4个字节。

**字节** （byte）是计算机信息计量单位，一个字节代表八个 **比特** （8 bits），一个比特是一个二进制位。

Java语言给整型$4 x 8 = 32$个二进制位，来表达整数值。

这32位里，最高位还要被划分出来表示正负号：

  * 最高位为0时，后面31位表示的数值是正数；

因此，Java中的int类型值，最大就是：$2^31 -1= 2147483648 - 1 = 2147483647$。

  * 当最高位为1的时候，表示负数，后面31位二进制数组成的数值再加个负号（-）就是实际值。

有一种情况要注意：如果最高位是1，而后面31位都是0，按说应该表示-0，但是-0=0，而0已经被32位全0表示了。

那么我们 **约定** ：最高位为1，后面31位为0时，表示$-(2^{32}) = -2147483648 $。

于是Java的整型值取值范围为$[-2147483648, 2147483647]$。

#### Java整型值的溢出

前面Java计算100阶乘的错误，就是源于实现Java整型值的内部二进制数的溢出。

回想一下那个Java程序——在计算100的阶乘的时候，是从100开始倒着往回乘的，那么：

100 x 99 x 98 x 97 =
94109400，乘到97时，尚且小于2147483647。然而，再继续乘以96，就会大于Java整型的最大值，就会产生溢出错误！

当二进制形式的94109400与96相乘时，后面31位已经hold不住了—— $94109400 \times 96 = 9034502400 >
2^{33} $，并且$94109400 \times 96 = 9034502400 < 2^{34}$。真要表示它，需要34个二进制位。

然而我们只有32个，于是Java运行环境就把9034502400转化为二进制后的后面32位取出来，作为结果显示了——又因为这32位中的最高位为0，因此它被打印成了一个正数。

这个数字和阶乘后面的数字（95，94，……，1）依次继续相乘下去，溢出部分给直接“扔掉了”，剩下的32位里，如果最高位为0就被打印成正数，如果为1就被打印成负数……

#### Java的其他类型

当然，Java（以及其他多种）编程语言有“容量”更大的无符号整型（unsigned int），以及比整型尺寸大一倍的长整型（long） 。

但无论存储空间多么大的数据类型，只要分配给某一个数据值的存储空间（bit数）是固定的，那么它能表达的最大值终归是有上限的。

### Python的整型

#### Python2

早在Python 2中，整型就已经扩展成了8 bytes。

更严格地说8 bytes的是长整型，不过在Python 2中当容量不够时整型会被自动提升为长整型，所以我们可以认为长整型的界限也就是整型的界限。

因此，Python2整型的最大值为9223372036854775807，最小值为-9223372036854775808。

#### Python3

到了我们用的 **Python 3** ，更是实现了飞跃： **整型值变得没有界限（unbounded）啦** ！

在Python 3中，整型是一种任意精度（arbitrary precision）数据类型。简单说就是想要多长就多长！

那么，我们用Python 3计算100的阶乘就变得非常简单了：

    
    
    result = 1
    for num in range(1, 101):
        result *=  num
    
    print(result)
    

运行后直接得出结果：
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000.

> **小贴士** ：此处代码，看不懂没有关系，只需要知道它们是用来计算100的阶乘的就好了。

那么难道Java，C等等编程语言，就没法做这种大数乘法了吗？当然不是，方法是有的。

对应算法的Python实现我们后面再讲，虽然有Python实现一遍有些画蛇添足，不过这是一个在应用层通过变通绕过系统层的限制的好例子。只是要读懂这个例子需要我们对语言有一定了解，所以要晚一些再讲。

#### 从整型数据看Python语言的特点

通过C，Java，Python2和Python3对整型数据值处理的对比，是不是觉得Python，尤其是Python3，特别可爱？

Python真是一种非常体谅用户的编程语言！

不同的编程语言运行在同一台计算机上，Python3可以不必关心整型溢出的问题，Java和C就不行。

为什么Python这样友好呢？因为Python3的运行环境（解释器）做了 ** _额外的处理_** ，避免了使用固定长度字节来存储整型变量。

负担的功能多了，效率自然也要降低。写程序方便了，程序的运行速度就会下降——Python也确实总被人诟病慢。

毕竟， **多·快·好·省不可能同时存在** 。

