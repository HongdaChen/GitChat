### 简单排序算法

前面已经说了，简单排序算法是一类算法，指那些直观、易理解的排序算法的总和。

![enter image description
here](https://images.gitbook.cn/d142fc50-c26e-11e9-b9eb-71e8d2e64545)

到现在为止，我们已经讲了的三种排序算法：选择排序、起泡排序和插入排序，都属于简单排序算法。

这三种算法有许多性能上的共性，本章就我们来类比看看。

### 时间复杂度

#### 排序的时间复杂度

假设我们要排列的数值共有 $n$ 个，那么排序算法的时间复杂度应该是大 $O$ 符号下一个 $n$ 的函数——$O f(n)$。

排序算法的时间复杂度不能一概而论，而是要区分最好情况，最坏情况和一般情况：

  * **最好** 情况是指待排数列原本就是有序的；

  * **最坏** 则是指待排数列是倒序的；

  * 最好最坏和介于两者之间的各种情况的综合属于一般（ **平均** ）情况。

#### 最坏时间复杂度

![enter image description
here](https://images.gitbook.cn/565724d0-c273-11e9-99d4-99f25a2efd84)

我们先来看看最坏情况。最坏情况对应到实际中，是给一个倒序的数列排序。

从代码的角度来看，就是将一个算法中所有的代码全都足额跑满，没有任何中途的 break/return/exit！

既然如此，就让我们先来对比一下三个排序算法的代码：

    
    
    def selectionSort(arr):
        for i in range(0, len(arr)):
            minPosition = i
            for j in range(i+1, len(arr)): 
                if (arr[j] < arr[minPosition]):
                    minPosition = j
            swap(arr, i, minPosition) 
        return
    
    def bubbleSort(arr):
        for i in range(0, len(arr) - 1):
            swapped = False
            for j in range(len(arr) -1, i, -1):
                if (arr[j] < arr[j - 1]):
                    swap(arr, j, j-1)
                    swapped = True
            if (not swapped):
                return
        return
    
    def insertionSort(arr):
        if (len(arr) == 1):
            return
        for i in range(1,len(arr)):
            for j in range(i, 0, -1): 
                if arr[j] < arr[j-1]:
                    swap(arr, j, j - 1)
                else:
                    break
        return            
    

大家发现没有，这三个算法的主体结构，都是两重嵌套的循环。

在这里再向大家透露一个 **窍门**
：一旦遇到这种两重循环的结构，当其无论内循环还是外循环都和数据量（$n$）直接相关时，我们基本上可以肯定，它的最差情况时间复杂度就是 $O(n^2)$.

如果不信，咱们可以一个个来看一下：

  * 选择排序：

    * 第 $1$ 次迭代，外圈走 $1$ 步，内圈走 $（n-1）$步；

    * 第 $2$ 次迭代，外圈走 $1$ 步，内圈走 $（n-2）$步；

    * ……

    * 第 $n-1$ 次迭代，外圈走 $1$ 步，内圈走 $1$ 步；

    * 第 $n$ 次迭代，外圈走 $1$ 步，内圈跳过；全部迭代结束。

因此，当足额执行所有代码时，总共的循环迭代步骤数 $ = （n-1）+（n-2）+ …… + 1 + 0$

同理计算：

  * 起泡排序的足额循环步骤数 $ = （n-1）+（n-2）+……+ 1 + 0$

  * 插入排序的足额循环步骤数 $ = 1 + 2 + …… + （n-2） + （n-1）$

可见它们三个在最差情况下，所走的循环步数是一样的，都 $= （n-1）+（n-2）+ …… + 1 + 0 $

$= （n-1）+（n-2）+ …… + （n - （n - 1）） + （n – n） $

$= n * n - （1+n）* \frac{n}{2} $

$= \frac{n^2 – n}{2} $

根据大 $O$ 符号取主要矛盾的特性，上式量级用大 $O$ 符号表示为：$O（n^2）$。

因此，我们说 **三个简单排序算法的的最差时间复杂度都是 $O(n^2)$** 。

#### 最好时间复杂度

![enter image description
here](https://images.gitbook.cn/62b111f0-c273-11e9-99d4-99f25a2efd84)

##### **选择排序**

再来看看最好情况，也就是待排序列原本就是正序的情况。

仔细分析一下代码不难发现， **选择排序最好和最坏的情况是一样的** 。

因为每次迭代都是找“剩下”的元素中最小的那个，因此，无论上一次迭代的情况是怎么样的，这次还是要把所有“剩下”的元素都访问一遍，怎么都省不了。

因此，选择排序的最好情况时间复杂度仍然是 $O(n^2)$。

既然无论最好还是最坏的时间复杂度都是一样的，那么自然， **选择排序的平均时间复杂度也是 $O(n^2)$** 。

##### **起泡排序和插入排序**

不过最好情况下，起泡排序和插入排序却和选择排序不同。

我们来分别看一看——

对起泡排序而言，如果待排数据本来就是有序的，则在第 $1$ 次迭代中，内圈访问完所有 $n-1$ 个元素，没有任何交换发生，swapped 还是
False，则进入 if(not swaped) 条件分支，直接返回。至此，总共的循环步骤为 $n-1$。

因此， **起泡排序最好情况时间复杂度仅为 $O(n)$** 。

插入排序中，当待排数据完全有序时，虽然 $n-1$ 次迭代都会进入外圈，但每次内圈循环仅进行一步就会进入 break
分支，退出内圈循环。正序时，整个算法总共只进行了 $1 + 1 + …… + 1 = n – 1$ 步。

**插入排序的最好情况时间复杂度也是 $O(n)$** 。

#### 平均时间复杂度

![enter image description
here](https://images.gitbook.cn/bb575080-c273-11e9-aeae-99ac44f0fb9e)

选择排序已经说过了。

这里，对于 **起泡排序** 的平均时间复杂度，我们用一个不是很严格方法来推导一下：

  * 在待排数串完全有序时起泡排序的时间复杂度是 $O(n)$；

  * 当待排数串中有 $1$ 个元素错序时，起泡排序的时间复杂度是 $O(n)\times 2$；

  * 当待排数串中有 $2$ 个元素错序时，起泡排序的时间复杂度是 $O(n)\times 3$；

  * ……

  * 当待排数串中有 $n-1$ 个元素错序时，起泡排序的时间复杂度是 $O(n)\times (n-1)$；

  * 当待排数串中有 $n$ 个元素错序时，起泡排序的时间复杂度是 $O (n) \times n$；

则他们的平均时间复杂度又可以写作 $\frac{（1 + 2 + 3 + …… + n）\times O（n）}{ n + 1} =
\frac{（n+1）\times n \times O（n）}{2 \times（n+1）} = \frac{n \times O（n）}{2}$

在此运用 $O$ 符号，则上式为 $O(n^2)$.

于是， **起泡排序的平均时间复杂度为 $O(n^2)$** 。

同理， **插入排序** 亦然， **平均时间复杂度也是 $O(n^2)$** 。

### 空间复杂度

三者的空间复杂度 $O(1)$。

因为很显然，三者唯一需要额外存储空间的就是在 swap 两个元素时借用的 tmp 变量的空间。

虽然整个算法 swap 很多次，但这些次 swap 是串行，而非并行，因此总共只需要一个额外空间即可。

### 简单排序算法性能总结

我们来列一个表格，总结一下简单排序算法的基本性能：

名称 | 数据对象 | 最好时间复杂度 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度  
---|---|---|---|---|---  
选择排序 | 数组 | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$  
起泡排序 | 数组 | $O(n)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$  
插入排序 | 数组 | $O(n)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$  
  
由上表可见，简单排序的空间复杂度还是不错的，就是时间复杂度大了点，$n$ 一旦“比较大”，它的平方就要“大得不得了”了，那时候的排序算法，就会变得很慢。

有没有可能让排序快一点呢？当然可能，下一章我们就来讲讲快速排序算法。

