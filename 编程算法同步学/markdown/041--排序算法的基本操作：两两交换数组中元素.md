### 查找 vs 排序

#### 比较查找与排序算法

说起来查找算法和排序算法从功能到使用目的都大有不同，但其实我们将要学习的（比较）排序算法和之前的查找算法相比，却也不乏相同之处。

让我们来分项对比一下两者看看：

![enter image description
here](https://images.gitbook.cn/6bed92b0-a488-11e9-8efd-09cc8f7db509)

#### 相同之处

  1. 虽然有许多不同，但是请注意，无论查找还是排序，都有 **“比大小”（比较）** 这个步骤。

  * 比较排序原本就是按照元素比较的结果来决定相对位置的；

  * 查找也要通过比较才知道是否相等。

![enter image description
here](https://images.gitbook.cn/0b6ec350-bf09-11e9-ba62-ab1efc78e0fb)

  1. 从数据层面而言，排序和查找都是对序列的操作，我们的数组数据结构在这两种算法中都很适用。

![enter image description
here](https://images.gitbook.cn/ee4e6730-bf08-11e9-ba62-ab1efc78e0fb)

#### 不同之处

虽然查找和排序算法都可以采用（逻辑上的）数组这种数据结构，但是对于同样数据结构中数据的操作，两者就很不同了。

  * 查找算法：

查找算法中，所有的待查数字都放在一个数组里，对这个数组的操作仅限于 **读取** ——只要知道这个数组中元素的值就可以了，不会修改这些值。

查找算法完毕之后，无论有没有找到目标数，原本的待查数组和算法开始前一样，一点都 **没变** 。

![enter image description
here](https://images.gitbook.cn/d8a6f7b0-bf0a-11e9-9938-37f9c2a5ccbd)

  * 排序算法：

与查找算法不同，我们运算排序算法的目的就是让原本无序的若干元素变得有序起来。那么，排序的过程中肯定要 **改变**
原本待排序数组里面的元素的位置，让一开始无序的数列变得有序。

对应地，对数组中数据的操作除了读取还有写入。

![enter image description
here](https://images.gitbook.cn/e2f27730-bf0a-11e9-8fe8-4f96fcd40d12)

### 两两交换数组内的元素

#### 一个排序算法的基础操作

在讲具体的排序算法之前，我们可以先笼统地想一下让一个元素无序的数组变得有序的过程——

之前我们讲数组的时候，曾经把数组比喻成为一排盒子，而把元素比喻为放在里面的东西。那么，我们假设待排序数组就是一排固定鸡蛋的包装盒，而其中的数值元素是一个个鸡蛋。

![enter image description
here](https://images.gitbook.cn/8c231280-a492-11e9-8efd-09cc8f7db509)

现在我们拿到了一盒鸡蛋，要把里面的蛋排列成一种新的顺序。这种情况下，我们可以怎么做呢？

我们可以有几种不同的做法：

> 【做法-1】另外找一个空盒子，把现在盒子里面的鸡蛋拿出来，按照预定顺序放到新盒子里面去。
>
> 【做法-2】不用任何新盒子，把原来盒子里面的鸡蛋一枚枚全都拿出去，放在旁边一块空地上，然后再按照预定顺序放回到原来的盒子里面。
>
> 【做法-3】不用任何新盒子，也不把所有鸡蛋都拿出去，每次只进行两枚鸡蛋的互换——
>
> 拿出去一个鸡蛋（鸡蛋A），这样就腾出了一个“空位”，然后把按照预定顺序应该位于这个空位上面的鸡蛋（鸡蛋B）放进去。
>
> 再把鸡蛋A放到鸡蛋B空出来的位置上，这样一直不停地交换，直到所有鸡蛋都按预定顺序排好位置。

这三种做法相比较，可以肯定的是：前两种比最后一种需要更多的额外空间。

前两种都需要和整个原本待排序数组一样大的额外存储空间——第二种虽然不“占盒儿”，但是要“占地儿”。而第三种仅需要和一个元素（鸡蛋）同样大的额外存储空间。

也就是说前两种的时间复杂度是$O(n)$，而第三种是$O(1)$。

虽然目前我们更看重时间复杂度，但空间复杂度始终是我们考虑算法时的关注点。更何况，上面前两种做法在多占空间的同时并不能比第三种更节约时间。

因此，这里可以剧透一下，对于本课以后要讲的几个排序算法，都会用到第三种归置元素的方法。

这也就是为什么，两两交换元素这个操作，对于排序算法非常重要的原因。

#### 用“一只手”交换“鸡蛋”

交换一个数组中的两个元素（元素A和元素B），需要几个步骤呢？

一共分三步：

  1. 将元素A放到一个临时存储空间里；
  2. 把元素B放到原来元素A所在的位置；
  3. 把元素A放到原来元素B所在的位置。

不就换两个鸡蛋嘛，怎么和把大象放进冰箱一样麻烦啊？

![enter image description
here](https://images.gitbook.cn/48ae8df0-bf0d-11e9-a602-c51ac4bff032)

我直接从鸡蛋盒里左手一个鸡蛋，右手一个鸡蛋，两手在空中一交换——只要一步不就把俩鸡蛋交换完了吗？

如果你是在家里整理鸡蛋，当然可以这样换。但是如果你是要在数组里整理数据元素，必须要分上面那3步。原因很简单：你有两只手，而程序只有一只手！

前面我们说到了，程序是一个指令的序列，每一个指令都是一个具体的步骤，在程序内部所有指令需要一条接一条的顺序进行。

条件、循环这些结构只不过是把一大堆有内在规律和分支选择可能的指令用一种简化的、形式化的方式来描述而已。到了具体执行的时候，所有实际运行的指令，仍然是一条一条从前到后执行的。

交换元素的三个步骤，就是三个指令，需要顺序执行。形象化的想象一下就是：计算机程序只有一只手，在某一个时刻，只能做一件事。

![enter image description
here](https://images.gitbook.cn/3a79db70-bf0f-11e9-a602-c51ac4bff032)

> **小贴士** ：此处要特别说明一下，我们现在说的所有的程序都是单线程程序，如果是多线程程序，同一个程序是可能并行执行多个指令序列的。
>
> 不过线程、单线程、多线程这些概念，以及多线程程序的实现和相应算法都属于相对有些难度的内容，是本课的“超纲”部分。此处先不纠结。
>
> 大家只需要知道，本课程中我们学习到的所有程序都是单线程程序，都是“只有一只手”的程序！

#### swap()函数

既然两两交换数组中的元素这么重要，那么我们先写一个函数来把这个功能封装起来吧！

说干就干，让我们一起来写一个swap()函数，它在后面的代码里会被反复重用。

我们已经知道，要写一个程序/函数，我们需要预先确定至少两件事情：

  1. 使用什么样的数据结构？
  2. 算法是什么？

对于这个swap()，它是要用来处理数组中的数据的，那么自然，我们就沿用前面用来实现逻辑上数组的Python数据结构：列表（List）。

还有，这个函数的算法我们已经知道了，就是上面的三个步骤啊！

既然如此，那就直接写出来吧：

    
    
    def swap(arr, i, j):
        if (len(arr) < 2):
            return
    
        if (i < 0 or i >= len(arr) or j < 0 or j >= len(arr)):
            return
    
        if (i == j):
            return
    
        tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
    
        return
    

swap() 函数的功能非常简单，就是交换一个List中的两个元素。

它的四要素如下：

  * 函数名：swap，含义是交换。

  * 参数：

    * 参数arr， 类型为List，指代其中元素被交换的那个List；
    * 参数i和参数j，类型为整型，指代arr中互相交换元素的两个位置下标。
  * 函数体：

    * 首先判断arr中是否包含两个或以上元素，如果没有则不必交换；

    * 然后判断i和j是否是有效的下标，如果越界（小于0或者大于等于len（arr）），则也不做交换；

    * 如果i和j虽然是有效下标但指向同一个位置，当然也不必交换。

    * 确定这些情况都不存在后，再交换不同位置的两个元素，具体做法就是“交换三步”。过程如下图：

![enter image description
here](https://images.gitbook.cn/9e006a00-bf10-11e9-a602-c51ac4bff032)

  * 返回值：无

这个swap()函数实在是太有用了，我们把它专门存放在一个名为utilities.py的文件里，以后有需要的时候，就直接import好了！

#### 没有返回值的swap()函数

大家发现没有，swap()函数没有返回值！

没有返回值怎么调用呢？

swap() 函数的调用其实和调用有返回值的函数是一样的，只不过不用再将其返回值赋给一个变量了。具体写出来，就是这一行：

    
    
    swap(arr, startPosition, minPosition)
    

如此调用之后，arr内部两个位置上的元素就已经交换了。也就是说，经历了这行代码之后的arr，和之前的arr已经不同了！

我们来用一个例子调用一下看看：

    
    
    arr = [3,2,1,5,8,7,9,10,13]
    print(arr)
    swap(arr, 0, 1)
    print(arr)
    

输出结果是：

> [3, 2, 1, 5, 8, 7, 9, 10, 13] [2, 3, 1, 5, 8, 7, 9, 10, 13]

而如果把swap的调用语句改成：

    
    
    print(swap(arr, 0, 1))
    

输出结果就变成了：

> None

这是怎么回事呢？这里实际上涉及到了函数内外的变量是如何作用于函数的问题。这个问题非常重要，我们下面必须专门讲一讲！

