### 软件工程

#### 概念

在软件开发过程中预防、发现 bug，从而提高软件质量的具体方法有很多。每种方法自然各有其作用，但是，如果只用一种，效果还是很有限的。

其实，早在几十年前，有识之士就发现了 bug 危害的严重性和软件质量的重要性。自上世纪六十年代，人们就开始研究系统性地提高软件质量的方法。

1968 年秋季，北约科技委员会召集了近 50
名一流的程序员、计算机科学家和工业界巨头，讨论研究如何应用系统化、规范化、可定量的过程化方法开发和维护软件，以及如何把管理学的经验与软件开发结合起来。

这套系统性方法被称为 **软件工程（Software Engineering）** 。这样称呼也是因为它从传统工程学中借鉴了很多内容。

软件工程出现至今已逾 50 年。在这半个多世纪的发展过程中，它为世界创造了许多方法和理论，有一些已经成为整个软件 /
互联网行业的常识。其中最具代表性的有：早期的瀑布模型，和稍晚些的敏捷开发。

#### 瀑布模型（Waterfall Model）

瀑布模型提出了完整的软件开发应周期的概念，对周期中的各阶段进行了定义：

![](https://images.gitbook.cn/593a3d90-9bd1-11e9-9fe7-a7858c3cb1c1)

因此瀑布模型又称为“系统发展生命周期”（System Development Life Cycle,
SDLC）。它强调开发过程需有完整的规划、分析、设计、测试过程，并对相关文档进行管理与控制，如此能够有效的确保系统质量。

在上世纪八九十年代，瀑布模型为大多数软件企业所选用。

#### 敏捷开发（Agile Development）

敏捷开发是与瀑布模型相对的一套方法。

##### **雏形**

敏捷开发的雏形出现得很早，比“软件工程”术语出现得都早——在 1957
年，迭代和增量式软件开发方法被提了出来。只是，后来瀑布模型在很长时间内成为开发的主流。

到了 1990 年代，随着应用软件开发的兴起，传统重量级软件开发方法越来越多地遭到批评，发展出了许多轻量及的细微化开发管理方法。

DSDM（Dynamic System Development
Method，动态系统开发方法）、Scrum、极限编程等，均属此列。虽然当时并没有统一公认的术语描述它们，其实它们都属于敏捷软件开发方法。

##### **问世**

2001年，十七名软件开发人员在美国犹他州的雪鸟度假村会面，讨论迭代、增量式进展、非传统的轻量级软件开发方法。

讨论的结果是，由 Jeff Sutherland、Ken Schwaber 和 Alistair Cockburn
发起，一同发表了著名的“敏捷软件开发宣言”（Manifesto for Agile Software Development，下图）：

![](https://images.gitbook.cn/ac4ba6e0-9bd1-11e9-85a0-adc1de285863)

它定义了相关的价值和原则，“ **敏捷（Agile）** ”方法，由此得名。其实，这份宣言本身就非常“敏捷”。

##### **Scrum**

上面这几句话在实践中得以贯彻后，确实带来了和在传统瀑布模型下开发软件截然不同的局面。目前，最具代表性的 **敏捷软件开发方法** 是 **Scrum** 。

Scrum 在英语中的含义是橄榄球运动中的列阵争球。在软件开发领域，它描述一种迭代式、增量式的敏捷开发过程。

简单而言，Scrum 的开发过程由若干“冲刺”（Sprint）组成，每个冲刺历时近 2-4 周，但却包含了从需求分析到设计、开发、测试、发布的全过程。若干
Sprint 不断迭代，直到软件从功能到性能均达到预计要求为止。

![](https://images.gitbook.cn/d36b1030-9bd1-11e9-9fe7-a7858c3cb1c1)

Scrum 摆脱了大量繁冗的文档，而用非常轻量级的白板、标签等作为管理工具；以面对面的开会为人员组织、交流方式。

![](https://images.gitbook.cn/dd9c9f10-9bd1-11e9-9fe7-a7858c3cb1c1)

由于其具备的高效、灵活等特征，Scrum 几乎横扫互联网企业，成为互联网软件开发的一时之选。

### 软件工程的作用

#### 能确保无 bug 吗

有了系统性的开发方法学，我们就能保证开发出来的软件没有 bug 了吗？很不幸，不能！

事实上，这个世界上或许存在没有 bug 的程序，比如：那些历经验证的算法实现——算法流程久经锤炼，实现程序短小简洁而可以对其逻辑一目了然，倒是有可能通过
code review 的方式确定其正确性。

而那些真正在负担着日常工作运行的软件，恐怕没有一个敢称作 bug free。无论负担的责任如何重大，无论有多少高智商的开发者投入其中，bug
总是无法避免的。

#### 工程学管理大工程

既然无论如何都会有 bug，那我们为什么还要搞一套软件工程呢？

因为，如果没有软件工程，我们将无法创造出大型软件。

一个人的体力和脑力是有限的，少数天才可以凭一己之力发明出某个惊世骇俗的算法，或者自己编写出针对某种特定功能的中小型高效软件。

但当实际业务要求大规模的软件系统，特别是这个系统应对的是一系列与现实绑定的复杂多变的工作时，则非要群策群力不可了。

在这种情况下，如果没有相应的理论知道，一群人像没头的苍蝇一样乱撞，又能做出些什么呢？历史上因为无法成功交付而空耗人财物最终以失败告终的软件开发项目也是不胜枚举。

正是有了基于工程学理论的软件工程，才使得我们在软件领域搞大项目、大工程成为了可能。

### bug 的处理流程

#### 带 bug 运行的软件们

虽然基本上个个都“身怀 bug”，但每天世界上仍然有几百几千万的软件在运行。那些能够运行正常的软件，一方面是有些 bug
还没有被发现；另一方面是开发者对于已经被发现的 bug
有一套修复流程规则，又有一群人围绕着这套规则实践着修复的每一步。如此，使得一旦有问题暴露出来，就能得到迅速有效的弥补。

几乎所有软件/互联网公司都有一套的 bug 提交、修复和验证的流程。许多公司还有专门的工具用于收集、描述 bug，并在 bug
修复的整个流程中来追踪其状态变化。

#### bug 处理流程的共性

对于 bug 处理流程而言，其中具体的一个个步骤，不同公司可能差别颇大，不过大致都包含下面几个主要步骤：

  * 被自己的测试人员或者用户发现了一个软件的问题，于是通过某种渠道提交 bug；

  * 开发人员看到 bug 之后评估一下是不是真的存在问题，如果是，则修改代码；

  * 代码被修改以后，要进行重新测试；

  * 经验证认定修复有效且安全后，将修复落实到产品中。

    * 在单机软件时代，这一步一般是通过发布“补丁”来完成；

    * 在互联网时代

      * 如果是后端系统的 bug，则可以在开发者公司的服务器上直接更新修改过的后端程序；
      * 如果是前端 bug，则可以通过发布软件前端的更新来实现。

#### 修复旧 bug，引出新 bug

关于 bug 的修复，说起来挺简单的，发现哪儿出错了，就直接改了不就得了嘛。

但在实践中，经常出现修一个 bug，引入多个 bug 的情况。直接原因嘛，可能是这样：

![](https://images.gitbook.cn/1274c230-9bd2-11e9-85a0-adc1de285863)

也可能是这样：

![](https://images.gitbook.cn/1ad69a20-9bd2-11e9-ac54-13ea42b6afc0)

在代码层面，往往因为缺乏足够的抽象和封装，随意添加“快速修复”而混乱不堪，甚至连代码本身都不是自己写出来的：

![](https://images.gitbook.cn/23895130-9bd2-11e9-85a0-adc1de285863)

但说到底，还是开发者缺乏对于软件结构的整体掌握——深层问题还是设计和管理的问题。

#### “假装 bug 是 Design”

这一问题进一步发展，引出了一种更加荒谬的现象：假装 bug 是原本的设计（Design）。

作者有一位在化工涂料公司工作的朋友，有次听他说起一件事：

>
> 公司里一位工人被要求调一种新的颜色，他对照着目标颜色的色板，调来调去就是调不出来。最后工人想想，用自己正在调的颜色把色板刷了一遍，然后交给领导，说他已经调好了。

涂料公司里这样的事情还当新鲜事说，在软件业，这已经是“常规操作”了。比如：有个 bug 怎么也修复（fix）不了，开发者告诉报 bug 的人：这不是
bug，而是故意设计成这样的，你就得这么用。

#### 产生 bug 的根本原因

bug 在软件被开发出来以后才会被发现，看起来，好像是软件的代码实现（编程）导致了 bug。但其实，真正难以修复的
bug，产生在编码之前——是设计的问题；是对于需求理解的问题；是缺乏通盘考虑的问题！

而所有这些问题，恰恰是软件工程力图通过基于理论研究的方法论来解决的。

### 软件工程与初学者

今天讲的内容，看起来好像和本课读者没有什么关系。毕竟嘛，我们就是学学编程而已，又没打算开发什么大型产品，软件工程和我们有什么关系？

不要忘了，软件工程是用来开发软件的，而软件，其实就是一种大型的程序。我们今天学习编程，无论是否打算未来以此技能为谋生手段，终归还是准备用它来做点有用的事情的。

用编程技能解决实际的问题，完成现实的任务，就要开发软件出来——这个软件的规模可以不大，但是无论大小，软件开发的流程是一致的：

  * 首先，了解需求——明白我们要用它做一件什么事情；
  * 之后，针对需求和资源限制进行设计——具体这件事怎么做，用到哪些数据和模块等；
  * 然后编码——实现我们的设计；
  * 继而测试——验证编码结果可用；
  * 最后是发布——用测试好的软件来执行任务。

——如何利用现有人财物在限定时间内完成这个过程，并提交出可用无害的软件，就是软件工程所研究的内容。即使是初学编程的我们，也应该知道这一点，为未来的进一步进修做准备。

