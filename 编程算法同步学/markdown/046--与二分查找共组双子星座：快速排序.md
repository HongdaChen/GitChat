### 一个“笑话”

网上有个笑话，题目叫做“ **会快速排序的图书馆大妈** ”，内容如下：

> 我去省图书馆看见两个志愿者需要把还回来的一堆书按顺序入架。
>
> 管理员大妈教他们说：“你先在这堆书里拉出一本来，把比它号小的扔到一边，比它大的扔到另一边，然后剩下两堆继续这样整，这样排的快！”

![enter image description
here](https://images.gitbook.cn/8bf5ab40-c16d-11e9-806d-771e8cb199b2)

虽然这段文字作为一个笑话颇不高明——笑话的提供者显然是把歧视（性别歧视 + 年龄歧视）当成了幽默，但从说明算法的角度，它还是有点可取指出的。

笑话中的嘲笑对象—— “图书馆管理员大妈”所提出的图书整理方法，就是我们今天要讲的排序算法：快速排序。

### 快速排序

#### 算法原理

快速排序（Quick Sort，简称快排），又名划分交换排序（Partition-Exchange Sort），最早由东尼 · 霍尔（Charles
Antony Richard Hoare，C.A.R.Hoare）在1960 年代初提出对起泡排序的一种改进。

![enter image description
here](https://images.gitbook.cn/3f3298f0-c27a-11e9-b9eb-71e8d2e64545)

这种排序算法说起来原理来非常简单，无外乎就是：

  * 将待排数列分割成两部分，其中一部分的所有数据比另一部分的所有数据都小；
  * 按此方法对分割出的两部分继续进行分割；如此迭代，直到整个数列有序为止。

#### 江湖地位

虽然原理不复杂，实现起来难度也不大，但快速排序却可以说是所有排序算法中最重要的一个。最直观的表现就是：它是最容易被当作面试题的排序算法。

能拥有这样的地位当然是有原因的：

  * 快速排序简单直接，好理解，易实现。

  * 同时在大多数情况下还有着相当优秀的性能——虽然它的时间复杂度（尤其是最坏时间复杂度）乍看之下并不惊艳，但平均复杂度却颇为可取。

  * 它出现得很早，而且因为它的实现过程可以在大部分计算机体系架构上高效完成，因此应用非常广泛。

![enter image description
here](https://images.gitbook.cn/8ffc0e10-c27a-11e9-b9eb-71e8d2e64545)

易学、易用、确实有效、用的人还多！如此一个排序算法，和二分查找一起组成了基础经典算法的双子星座！

这个算法是每一个只要学过计算机算法的同学都应该彻底掌握，并牢记终身的！

#### 算法步骤

快速排序的步骤如下：

  1. 对待排数列进行分区操作：

1.1 选轴

从待排序的数列中挑出一个元素作为“轴”（pivot）。

由于数列本身是无序的，因此理论上可以从中随机任选一个元素为“轴”。但是为了方便起见，我们在后面的操作中，都选原数列的第一个元素为轴。

1.2 分区

将待排数列中“轴”之外其他的元素分别与“轴”进行比较，然后：

    * 比“轴”小的元素都放在“轴”之前（左边），形成左区；

    * 比“轴”大的元素则放在“轴”之后（右边），形成右区；

    * 与“轴”相等元素理论上的可以放在任一边，我们就一律都放在左区。

  2. 第1步分出来的左区和右区成为了两个新的待排数列，分别对它们进行分区操作；

  3. 重复1-2步，反复迭代，直到分区操作得出的左右区数列大小是零或一（也就是说待排区域已经“到底了”）的时候。

当所有的待排序列都“到底”之后，整个数列也就完全有序。

下图就是一个数列快速排序的过程：

![enter image description
here](https://images.gitbook.cn/94375100-c16d-11e9-806d-771e8cb199b2)

上图中，每个虚线框对应一轮分区操作——一轮分区操作未必是给一个数列分区，上图中从上向下的第二个虚线框中其实就是同时给两个数列：[2, 3] 和 [9,
11, 8, 24] 分区。

### 快速排序的时间复杂度

原理看起来还是挺简单的，为什么快速排序就快呢？我们来计算一下它的时间复杂度就知道了。

#### 时间复杂度的计算

假设待排数列长度为 $n$。从原理中我们不难看到出，其实整个排序算法，就是做了很多轮分区操作，一直做到无法再继续分为止。

而每轮分区操作，最多访问的元素数为 $n$，某一个数组上的快速排序虽然在具体某一轮分区中访问的元素数可能有差别，但总体而言都和 $n$
相关，因此一轮分区操作的时间复杂度为 $O(n)$。

假设快速排序算法运行总共要经历 $X$ 轮分区，则整体时间复杂度就是 $O(n X)$。

$X$ 值到底是多少呢？直觉上，我们感觉 $X$ 是 $n$ 的函数，但这个函数具体是什么呢？我们分不同情况来看看：

#### 最佳时间复杂度

先想想我们最希望出现的情况是什么？

肯定是：每次分区要把待排数列分成均匀的两截，这样肯定经历的分区轮数最少。

反之，当中间有切割不均匀时，必然会比依次均匀切割所需次数增多。

不信的话大家可以看看下面这个直观的例子，十六个元素，左侧是平分，右侧从第三轮分区开始，有一个子数列不是平分的，结果右侧就比左侧多一次。

![enter image description
here](https://images.gitbook.cn/a4dc0730-c16d-11e9-806d-771e8cb199b2)

是不是很像二分查找？

如果每次都把每段待排数列对切成两半，这样一层层分下来，总过需要 $O(\log{n})$ 轮分区操作。

由此可知，快速排序在最佳情况下的时间复杂度就是 $O(\log{n}) \times O(n)= O(n \log{n})$

#### 最差时间复杂度

我们再来看最坏的情况。

既然越均匀越好，那么反之，越不均匀也就越坏咯。

最坏的情况无外乎是每次选出来的“轴”都正好是剩下的所有的元素中最大或者最小的一个，结果所有剩余元素全部集中在左区或右区里。这样的话，等于每做一轮分区操作仅能确定一个元素的位置。于是，确定所有
$n$ 个元素的位置，就需要 $n$ 次。

于是整体时间复杂度就成了 $n \times O(n) = O(n \times n) = O(n^2)$.

快速排序在最坏情况下的时间复杂度，就和简单排序一样了。

#### 一般情况时间复杂度

##### **平均时间复杂度**

一般情况下，快速排序时间复杂度是多少呢？

在这里可以先把结论告诉大家：快排在平均时间复杂度和最好时间复杂度一样，也是 $O(n\log{n})$。

##### **理解快排的平均时间复杂度**

一般情况居然和最好情况一样？有点不好理解啊。

![enter image description
here](https://images.gitbook.cn/216335b0-c30a-11e9-a797-b7290d4ef0b1)

要知道，$O$ 符号的含义是取主要矛盾。在这个前提之下，同样是 $Of(n)$ 的时间复杂度，对应到具体数值，可能相差若干倍。

快速排序最好情况下的 $O(n\log{n})$，和一般情况下的 $O(n\log{n})$，如果除掉大 $O$
符号，实际上是相差着常数系数以及量级更低的项，两者并非相等关系。而是在大 $O$ 符号的遮掩之下，样子一样罢了。

##### **平均时间复杂度的计算**

那一般情况是怎么计算的呢？

首先明确一点：因为我们的输入数列可以是任意组合，里面的元素可以任意排列，所以，就算我们每次都是取子数列中位置在第一位的元素作为“轴”，这个“轴”的取值在所有元素中的大小排列，仍然是随机的。

明确了“轴”的随机性，我们再来看看它在最终排好序的序列中所处的位置。

下图展示的是一个已经被排好序的数列，最前面的绿色区表示头部最小的25%的元素，最后的紫色区表示最大的25%的元素，中间的蓝色区域对应的是位于中部的50%的元素。

![enter image description
here](https://images.gitbook.cn/ac94cde0-c16d-11e9-ac93-35f161337e57)

上图中任何一个位于蓝色区域的元素，都可保证它至少比25%的元素大，且至少比25%的元素小。

那么，如果我们在对一个数列进行快排时，从第一次到最后一次分区操作，每次选择的“轴”都是位于蓝色区域之中，则我们最多只需要把数列分切 $2\log{n}$
次。也就是说只需要进行 $2\log{n}$ 次的分区操作，就可以保证整个数列被排有序了。这种情况，快排的时间复杂度为：$2\log{n} \times
O(n) = O(n\log{n})$

当然咯，毕竟随机选取的“轴”落在上图中蓝色区域中的概率只有 $50%$。也就是说，整体而言，所需要的分区操作次数是 $2 \times 2 \log{n}
= 4 \log{n}$。

也就是说快速排序算法的整体平均时间复杂度应该是 $4\log{n} \times O(n)$。在大 $O$ 符号的作用下，$2$ 或者 $4$
都一样，都作为“次要矛盾”被忽略了，最后都是 $O(n\log{n})$。

因此，快速排序在一般情况下的时间复杂度是 $O(n\log{n})$。

