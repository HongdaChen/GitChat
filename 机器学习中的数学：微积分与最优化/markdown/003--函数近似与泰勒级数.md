### 谈谈 $\Delta y$ 与 $dy$

在上一讲的内容中，我们提到了利用 $\frac{dy}{dx}$ 来表示因变量 y 关于自变量 x
的导数，而我们到目前为止，都是将其作为一个整体来看待的。在这一讲的开头，我们尝试分别来单独讨论 dy 和 dx 的含义。

首先我们还是来看导数的含义，如果函数 f(x) 在点 $(x_0,y_0)$ 处是可微的，那么依照定义就有：

$$lim_{\Delta x\rightarrow 0}\frac{f(x_0+\Delta x)- f(x_0)}{\Delta x}=
f'(x_0)$$

从这个式子中我们发现了什么端倪呢？那就是 $\Delta x$ 的值越小，越趋近于 0，那么式子的左边，即：$\frac{f(x_0+\Delta x)-
f(x_0)}{\Delta x}$ 就越趋近于 $x_0$ 处导数的真实值 $f'(x_0)$。

我们简单地对式子进行一下变换就有：

$$f(x_0+\Delta x)-f(x_0)\approx \Delta xf'(x_0)$$

这个表达式的左侧部分 $f(x_0+\Delta x)-f(x_0)$ 称作是 $\Delta y$，顾名思义就是当自变量 x 从 $x_0$ 变到
$x_0+\Delta x$ 时， y 的真实改变量，而右侧部分 $\Delta xf'(x_0)$ 我们称之为 dy，它充当的是 $\Delta y$
的近似值，如下图所示：

![图1.y值改变量的近似](https://images.gitbook.cn/d4659f30-e061-11e9-a5fc-a91acf4e1767)

因此， dy 可以作为 $\Delta y$ 的一个近似值来看待，特别是当 $\Delta x$ 越小的时候，近似效果越好。

我们最后来总结一下 $\Delta x$、$dx$、$\Delta y$、$dy$ 这几个概念。

对于自变量为 x 的可微函数 y=f(x)，$\Delta x$、$dx$、$\Delta y$、$dy$ 的含义分别总结如下：

  * $\Delta x$：表示自变量 x 的任意增量。
  * $dx$：表示自变量 x 的微分，实际上就等于 $\Delta x$。
  * $\Delta y$：表示当自变量 x 变化到 $x+\Delta x$ 时，因变量 y 的真实改变量，即：$\Delta y=f(x+\Delta x)-f(x)$。
  * $dy$：因变量 y 的微分，实际上 dy=f'(x)dx，这里请大家注意，微分 dy 可以作为真实值 $\Delta y$ 的一个近似。

因此可以看出，微分的作用非常广，我们这里首要关心的就是它在近似过程中的应用：

$$f(x+\Delta x)=f(x)+\Delta y \approx f(x)+dy$$ $$=f(x)+f'(x)\Delta x$$
$$\Rightarrow f(x+\Delta x) \approx f(x)+f'(x)\Delta x$$

### 线性近似的概念

基于上面的式子，进一步的，我们可以表示出：假如函数 f 在 c 点处可微，由直线方程的写法可以拿出函数 f 的曲线在点 (c,f(c)) 处的切线方程
g(x)：

$$f'(c)=\frac{g(x)-f(c)}{x-c}\Rightarrow g(x)$$ $$=f(c)+f'(c)(x-c)$$

那么此时，过点 (c,f(c)) 的切线 g(x) 就可以看做是原函数 f 在点 c 处的线性近似。

概念还是很空洞的，我们还是结合一个例子简单说明一下。

我们试着用上面的方法来观察一下函数 f(x)=1+sin2x 在取值 $x=\pi/2$ 处的线性近似情况。

我们首先按照上面的公式写出 $x=\pi/2$ 处的切线方程：

$$g(x)=f(c)+f'(c)(x-c)$$ $$=f(\pi/2)+f'(\pi/2)(x-\pi/2)$$
$$=1+sin\pi+2cos\pi(x-\pi/2)$$ $$=-2x+(1+\pi)$$

即：$g(x)=-2x+(1+\pi)$。

然后我们绘制出函数 f(x) 和 $x=\pi/2$ 处切线的图像，并在不同的自变量区域尺度内观察：

代码片段：

    
    
    import matplotlib.pyplot as plt
    import numpy as np
    import seaborn
    from math import pi
    seaborn.set()
    
    def f(x):
        return 1+np.sin(2*x)
    
    def g(x):
        return -2*x+(1+pi)
    
    fig, ax = plt.subplots(2, 2)
    
    x = np.linspace(0, pi, 1000)
    ax[0, 0].plot(x, f(x), color='k')
    ax[0, 0].plot(x, g(x), color='r')
    ax[0, 0].plot(pi/2, f(pi/2), 'ko', markersize=4)
    
    x = np.linspace(pi/4, 3*pi/4, 1000)
    ax[0, 1].plot(x, f(x), color='k')
    ax[0, 1].plot(x, g(x), color='r')
    ax[0, 1].plot(pi/2, f(pi/2), 'ko', markersize=4)
    
    x = np.linspace(3*pi/8, 5*pi/8, 1000)
    ax[1, 0].plot(x, f(x), color='k')
    ax[1, 0].plot(x, g(x), color='r')
    ax[1, 0].plot(pi/2, f(pi/2), 'ko', markersize=4)
    
    x = np.linspace(7*pi/16, 9*pi/16, 1000)
    ax[1, 1].plot(x, f(x), color='k')
    ax[1, 1].plot(x, g(x), color='r')
    ax[1, 1].plot(pi/2, f(pi/2), 'ko', markersize=4)
    
    plt.show()
    

**运行结果：**

![图2.切线的线性近似效果](https://images.gitbook.cn/f7320210-e061-11e9-8b74-3dd44b38685a)

很明显的是，随着自变量 x 区间的不断收窄，在点 $(\pi/2,f(\pi/2))$ 的领域附近，切线的图像和原函数是高度重合的，因此在 $\Delta
x$ 越来越小的时候，线性近似的效果就会显得越好。

但是，如果我们仅仅使用这种线性近似，它的效果毕竟还是不算太好，它的近似精度其实还是有很大的提升空间的，那么我们下一步该如何做呢？也许级数是一个很不错的想法。

### 关于无穷级数

#### 无穷级数的前 n 项和

这里我们引入一个背景知识进行讨论。当我们用计算机来计算正余弦函数或者是自然对数的幂，即 $e^n$
的时候，通常是基于下面的无穷数列来给出满足较高精度的近似值：

$$sin(x)=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+...$$

$$cos(x)=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+...$$

$$e^x=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}+...$$

上面的表达式就是无穷级数。无穷级数的概念很多，我们先看最简单的：一组数字的无穷级数：

$$\frac{1}{2}+\frac{1}{4}+\frac{1}{8}+...$$

在这个级数当中，如果只包含第一项，那么和就为 1/2，如果包含前两项，那么和为 1/2+1/4=3/4，如果只包含前三项，那么和就为
1/2+1/4+1/8=7/8。

级数的前有限项的和，我们叫作部分和。我们把前 n 项部分和记为是 $S_n$，很显然对照上面所描述的就有：

$$S_1=\frac{1}{2}，S_2=\frac{3}{4}，S_3=\frac{7}{8}$$

显然还可以归纳出 $S_n=1-\frac{1}{2^n}$，并且可以看得出，$S_n$ 收敛于 1。

而至于说无穷级数的和，我们将其定义为部分和 $S_n$ 的极限：

$$lim_{n\rightarrow \infty}S_n$$

当然，我们脱离上面这些个具体的数字来谈定义，我们给出无穷级数前 n 项和的一般表示方法，即考虑无穷级数：

$$a_1+a_2+a_3+a_4+a_5+......$$

那么在这种表示方法之下，前 n 项的和我们定义为：

$$S_n=a_1+a_2+a_3+...+a_n=\sum_{k=1}^{n}a_k$$

#### 级数的收敛性

对于无穷级数，我们最关注的便是级数的收敛性，这里我们给出一个比较严格的定义和说法：

对于一个无穷级数 $\sum_{k=1}^{\infty}a_k$，如果由它的前 n 项和构成的数列 $\\{S_1,S_2,S_3,...,S_n\\}$
最终收敛于 S，那么我们就称无穷级数 $\sum_{k=1}^{\infty}a_k$ 收敛并且它的和为 S。反之，如果数列
$\\{S_1,S_2,S_3,...,S_n\\}$ 发散，那么无穷级数也是发散的，这个无穷级数是没有和的。

#### 几何级数

对于无穷级数，我们特别地需要关注以下这种形式：

$$\sum_{k=1}^{\infty}ar^{k-1}=a+ar+ar^2+ar^3+...，$$ $$其中 a\neq 0$$

这种形式所表示的级数，称之为几何级数，这是一种比较常见的级数。更具体的，我们可以把几何级数划分为两大类。

一类是常数项级数，即不含自变量的，类似于：

$$\frac{1}{2}+\frac{1}{4}+\frac{1}{8}+\frac{1}{16}+...$$

也就是上面写的 $\sum_{n=1}^{\infty} a_n$ 这种形式，非常好理解。

另外一类就是函数项的级数，即 $\sum_{n=1}^{\infty}a_n(x)$。这其中，级数的每一项 $a_n(x)$ 都是一个关于自变量 x
的函数，函数项的级数用处更为广泛，它将是我们后续内容中的重点研究的对象。

最基本、最简单的一种函数项无穷级数：

$$\sum_{n=0}^{\infty}a_nx^n=$$ $$a_0+a_1x+a_2x^2+a_3x^3+......$$

我们就将其称之为自变量 x 的幂级数。而进一步，我们将这种表达式一般化，写成是：

$$\sum_{n=0}^{\infty}a_n(x-a)^n=$$ $$a_0+a_1(x-a)+a_2(x-a)^2+a_3(x-a)^3+...$$

这称为关于 x-a 的幂级数。

### 函数的幂级数表示及其近似

#### 利用泰勒级数表示函数

走到这里，你可能还非常困惑，我们为什么铺垫了这么多无穷级数、包括特殊的幂级数的概念，目的到底是想干嘛？

其实很自然，我们是想探究这样一个问题，那就是给定一个已知函数 f(x)，我们能否将这个函数以 x-a 的幂级数的形式进行表示，并且探索它的一些重要性质？

那么，更具体的，我们的目标就是找到一组数 $c_0$,$c_1$,$c_2$,...,$c_n$，使得函数 f(x) 表达成如下的形式：

$$f(x)=c_0+c_1(x-a)+$$ $$c_2(x-a)^2+c_3(x-a)^3+...$$

如果这个式子想要成立，很显然，我们对上面的级数表达式进行求导，从一阶导数开始，逐步求取它的高阶导数（ n 阶导）：

$$f(x)=c_0+c_1(x-a)+$$ $$c_2(x-a)^2+c_3(x-a)^3+...$$

$$f'(x)=c_1+2c_2(x-a)+$$ $$3c_3(x-a)^2+4c_4(x-a)^3+...$$

$$f'’(x)=2\times 1c_2+3\times 2c_3(x-a)$$ $$+4\times 3c_4(x-a)^2+...$$

$$f^{(3)}(x)=3\times 2\times 1c_3+$$ $$4\times 3\times 2c_4(x-a)+$$ $$5\times
4\times 3c_5(x-a)^2...$$

$$f^{(4)}(x)=4\times 3\times 2\times 1c_4+$$ $$5\times 4\times 3\times
2c_5(x-a)...$$

看上去一大篇的式子，我们又该如何处理呢？其实也很容易，我们将 x=a 代入到上面的所有表达式中，就可以顺利地消去所有的非常数项：

$$f(a)=c_0\Rightarrow c_0=f(a)$$

$$f'(a)=c_1\Rightarrow c_1=f'(a)$$

$$f'’(a)=2\times 1c_2\Rightarrow c_2=\frac{f''(a)}{2!}$$

$$f^{(3)}(a)=3\times 2\times 1c_3 \Rightarrow c_3=\frac{f^{(3)}}{3!}$$

$$f^{(4)}(a)=4\times 3\times 2\times 1c_4 \Rightarrow c_4=\frac{f^{(4)}}{4!}$$

最后，我们可以得出系数 $c_n$ 的一般表达形式：

$$c_n=\frac{f^{(n)}(a)}{n!}$$

从这个推导过程中，我们知道了函数 f(x) 如果能用关于 (x-a) 的幂级数的形式来进行表示，那么表达的方式不可能多于一种。那么，对于一个给定函数
f(x) 而言，用以 (x-a) 为表达方式的幂级数，我们就将其称之为 **泰勒级数** ，而一种比较特殊的情况，即当 a=0
时的幂级数，我们可以将其称之为麦克劳林级数。

如果我们把泰勒级数的项数固化到 n
项，会更方便于我们在实际过程中的处理，毕竟我们不可能处理无限个级数项。这里我们运用微分中值定理，就可以把无穷项的泰勒级数转化为有限项的泰勒级数，这里运用到的就是带有余项的泰勒公式，即如果函数
f(x) 的 (n+1) 阶导数 $f^{(n+1)}$ 在 x=a 的邻域内存在，那么在这个邻域内函数 f 可以表示成以下的有限项的形式：

$$f(x)=f(a)+f'(a)(x-a)+$$ $$\frac{f''(a)}{2!}(x-a)^2+...+$$
$$\frac{f^{(n)}(a)}{n!}(x-a)^n+R_n(x)$$

最后一项 $R_n(x)$ 我们称之为余项，换句话说它代表了函数真实值 f(x) 与前 n 项和之间的误差，利用微分中值定理，我们可以将其表示为：

$$R_n(x)=\frac{f^{(n+1)}(c)}{(n+1)!}(x-a)^{n+1}$$

在这其中， c 是 x 和 a 之间的一点。

#### 函数的泰勒近似

那么谈到这里，我们就会受到启发，我们似乎可以利用函数 f 的泰勒级数的前 n 项和来对函数在 x=a 邻域内的实际取值进行近似。

再回过头来看看前面对于函数的线性近似的内容，我们讲过函数 f 在 a 点邻域内的值，可以用经过函数 f 点 (a,f(a)) 的切线去近似：

$$p_1(x)=f(a)+f'(a)(x-a)$$

看看这是什么？我们发现 $p_1(x)$ 由两项组成，即包含泰勒级数关于 x=a 点展开的 0 阶项和 1
阶项，因此，我们把线性近似称之为是一阶泰勒多项式。

但是我们不难发现，毕竟切线是一条直线，用它去近似函数 f 所代表的曲线，只要随着自变量 x 稍微远离 a 点，近似值和实际的函数取值的差距就会显著增大。

于是我们就在想，线性近似只使用了泰勒级数的第 0 项和第 1 项，似乎丢失了太多后面的信息，那么我们把级数中后续更高阶的项也利用起来，例如用 2
阶泰勒多项式：

$$p_2(x)=f(a)+f'(a)(x-a)+$$ $$\frac{f''(a)}{2!}(x-a)^2$$

这个相比于一阶泰勒多项式（也就是线性近似），它的近似效果会显得更好。

如果我们追求更高的近似精度，我们可以使用更高阶数的 n 阶泰勒多项式进行函数的近似：

$$p_n(x)=f(a)+f'(a)(x-a)+$$ $$\frac{f''(a)}{2!}(x-a)^2+...+$$
$$\frac{f^{(n)}(a)}{n!}(x-a)^n$$

并且相应地，如果此时 a=0 ，那么 n 阶泰勒多项式就转化为了 n 阶麦克劳林多项式，用于对 0 附近邻域内的函数取值进行近似。

$$f(x) \approx p_n(x)=f(0)+f'(0)x+$$
$$\frac{1}{2!}f''(x)x^2+...+\frac{1}{n!}f^{(n)}(0)x^n$$

很显然，按照这个公式我们可以很轻松地得到例如 $e^x$， cosx 的麦克劳林级数：

$$e^x \approx 1+x+\frac{1}{2!}x^2+\frac{1}{3!}x^3+$$
$$\frac{1}{4!}x^4+...+\frac{1}{n!}x^n$$

$$cos x\approx 1-\frac{1}{2!}x^2+\frac{1}{4!}x^4-...+$$
$$(-1)^{n/2}\frac{1}{n!}x^n$$

#### 实际的近似试验

为了展示高阶麦克劳林级数（泰勒级数）在指定点附近邻域的良好近似特性，我们在 x=0 处利用不同阶数的麦克劳林级数对原函数 y=cosx
进行近似，并利用函数图像观察近似效果：

**代码片段：**

    
    
    import matplotlib.pyplot as plt
    import numpy as np
    import seaborn
    seaborn.set()
    
    ##计算n的阶乘
    def factorial(n):
        result = n
        for i in range(1,n):
            result *= i
        return result
    
    ##原函数
    def f(x):
        return np.cos(x)
    
    ##1阶麦克劳林级数
    def p1(x):
        return 1
    
    ##2阶麦克劳林级数
    def p2(x):
        return 1-1./factorial(2)*(x**2)
    
    ##4阶麦克劳林级数
    def p4(x):
        return 1-1./factorial(2)*(x**2)+1./factorial(4)*(x**4)
    
    ##6阶麦克劳林级数
    def p6(x):
        return 1-1./factorial(2)*(x**2)+1./factorial(4)*(x**4)-1./factorial(6)*(x**6)
    
    ##8阶麦克劳林级数
    def p8(x):
        return 1-1./factorial(2)*(x**2)+1./factorial(4)*(x**4)-1./factorial(6)*(x**6)+1./factorial(8)*(x**8)
    
    x = np.linspace(-5, 5, 1000)
    plt.plot(x, f(x), color='k', label='cosx')
    plt.hlines(1, -5, 5, colors='g', label='p1')
    plt.plot(x, p2(x), color='b', label='p2')
    plt.plot(x, p4(x), color='r', label='p4')
    plt.plot(x, p6(x), color='y', label='p6')
    plt.plot(x, p8(x), color='m', label='p8')
    
    plt.ylim(-2, 2)
    plt.legend()
    plt.show()
    

**运行结果：**

![图3.不同阶数的麦克劳林函数近似效果](https://images.gitbook.cn/143f2450-e062-11e9-a5fc-a91acf4e1767)

从图中我们可以看出，y=cosx 的 8 阶麦克劳林级数在 x=0 的附近邻域对原函数 cosx 的近似程度已经是相当高了。

为了方便与作者交流与学习，GitChat 编辑团队组织了一个专栏读者交流群，添加小助手，回复关键字「279」给小助手伽利略获取入群资格。
![R2Y8ju](https://images.gitbook.cn/R2Y8ju.jpg)

