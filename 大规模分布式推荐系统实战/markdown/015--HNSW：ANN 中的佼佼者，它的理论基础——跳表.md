上篇文章咱们提到了对于给定的 **查询向量（query）** ，在 **海量向量（candidates）**
中去查询其近邻时，会给线上环境带来极大的挑战性，尤其是对于每秒请求量（QPS）很大的场景，似乎向量召回变得很难运用起来。于是各种各样的 ANN
算法层出不穷，都为了在精度损失很小的情况下，提高查询的速度。这个 [GIT REPO](https://github.com/erikbern/ann-
benchmarks)$^1$ 特地为市面上主流的 ANN 算法做了性能测试，在速度（Y 轴：每秒查询次数）和精度（X 轴：召回率）上给出了很好的比对。

我们今天要讲的 HNSW$^2$ 就是这么一种表现优异的 ANN 算法，笔者曾经所在的公司就是使用 HNSW
线上根据用户向量从五百万广告库中实时召回万级的结果，性能绝对值得信赖。

不过在详细介绍该算法细节之前，我们首先看下 跳表 这种数据结构，在掌握了跳表后，再去看 HNSW，会觉得“啊，原来是这样”！

### 二分查找

提起二分查找，久经沙场或者初出茅庐的你总会感慨这个老朋友总会时不时地出现，多半出现在求职的面试过程中。那么二分查找与跳表又有什么关系呢？别着急，咱们慢慢来。

相信大家都玩过 **猜数字** 游戏，如下图所示：

![](https://images.gitbook.cn/9ea20c90-2835-11eb-b804-ef8651c2512a)

这个小游戏完美地将二分查找的思想运用到了实际生活中：每次猜数时，选择上界与下界的中间值。如果猜的数字比中间值大，那么就把上界换成该数字；如果猜的数字比中间值小，那么就把下界换成该数字；否则就猜对了。

可以看到每次能够将查找的数字个数缩减一半，这可不得了。

简单看下二分查找的时间复杂度：假设初始的元素个数为 $n$，第一次查找后个数变为 $n/2$，第三次查找后个数变为 $n/4$……，第 $x$
次查找后个数变为 $1$，查找结束。那么这个 $x$ 就是我们的时间复杂度，$x$ 是多少呢？

$$\begin{align}n \times (\frac{1}{2})^x = 1 \Longrightarrow x =
log_2(n)\end{align}$$

由此可见，二分查找的时间复杂度是 $log(n)$。

算法代码如下（假设数组中不存在重复元素）：

    
    
    int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
    
        while(left <= right) { // 1
            int mid = left + (right - left) >> 1; // 2
            if(arr[mid] < target) left = mid + 1;
            else if(arr[mid] > target) right = mid - 1;
            else return arr[mid];
        }
    
        return -1;
    }
    

标注 `//1` 和 `//2` 的两行需要注意下哦。

### 有序链表

二分查找固然好，可以局限性也比较大，那就是只能用在类似数组顺序表结构中，要求能够根据下标来访问。而有序链表（如下图）结构，普通的二分查找似乎显得无能为力了，因为链表不支持随机访问，只能从头指针开始访问（单向链表）。

如果我们把链表中的节点想象成公交站，公交车必须从始发站开始，逐个停靠每个站点直至底站。如果不巧你正好是从始发站上车，目的地是底站，你看着这辆车在每个站点都会停留片刻，心里极度不爽，心想这些个小破站又没人上车，不禁感慨“要是有大站快车就好了”。

> 大站快车：只在大站点停靠，小站点不停。

![](https://images.gitbook.cn/c09c7970-2835-11eb-97c1-1314be3cdf10)

为了解决这个问题，我们可以在原始链表上再加一层，如下图所示：

![](https://images.gitbook.cn/c8da0080-2835-11eb-96ab-0d95f8d73f7e)

可以看到，现在只需要停靠 4 次即可实现从 A 到 I，相比于原始链表的 8 次已经缩短了一半的时间。

如果目的地是 F 站呢？我们的行驶路线如下：

  * 大站快车从 A 站出发
  * 到达 D 站，此时发现大站快车的下一站 G 站比目的站 F 要大，于是我们下车，换乘普通公交，下一站为 E 站
  * 到达 E 站，再到 F 站，下车

只需停靠 D、E、F 共 3 站，而普通公交需要停靠 B、C、D、E、F 共 5 站。

可见，加一层确实可以减少时间复杂度，那么如果我们加更多的层，是不是可以让时间复杂度更低呢？

恭喜你，答对了！这就是跳表。

### 跳表

跳表在原始 **有序链表** 上面增加了多层链表，也叫多级索引，通过索引来实现快速查找。

传统的链表我们都知道每个元素会有一个 next 指针，指向下一个元素，而跳表因为其结构的原因，又在每个元素上添加了一个指针——down
指针。如下图所示为一个简单的只有一级索引的跳表：

![](https://images.gitbook.cn/d9a3f1f0-2835-11eb-90f6-fbd19bda6e6e)

根据图例，跳表的查询逻辑（假设原始有序链表从小到大）如下：

1\. 要查找的元素值为 q[uery]，从最顶层开始，当前节点为 p。

2\. 如果 p 的值等于 q，返回 p。

3\. 如果 p 的值大于 q，返回 NULL（大于 q 的情况只可能出现在首次比较，说明原始有序链表最小值都比 q 大）。

4\. 如果 p 的值小于 q，则查看 p 的 next 节点：

  * 如果 next 节点的值等于 q，返回 next 节点；
  * 如果 next 节点的值也小于 q，p 移动到 p 的 next 节点（说明要查找的元素不在 p 和 p 的 next 节点之间）；
  * 如果 next 节点的值大于 q，p 移动到 p 的 down 节点（说明要查找的元素可能在 p 和 p 的 next 节点之间）。

5\. 重复第 2 步。

6\. 返回结果。

那么，我们先来看看上图这种简单的跳表，其查询的时间复杂度是多少。

假设原始有序链表的长度为 $|L_0|$，一级索引的长度为$|L_1|$，在这里再次假设 $|L_0|$ 是 $|L_1|$
的整数倍，一级索引把原始链表分成了 $\frac{|L_0|}{|L_1|}$ 段。

当一次查询从 $L_1$ 跳至 $L_0$ 时，在 $L_0$ 上的查找次数最多为 $\frac{|L_0|}{|L_1|}$（想想这是为什么）。

> 因为当需要从 $L_1$ 跳至 $L_0$ ，说明要查找的数在 $L_1$ 上大于等于当前节点，小于下个节点。而 $L_1$ 上两个节点在 $L_0$
> 上的距离为 $\frac{|L_0|}{|L_1|}$。

所以，此时只有一级索引的跳表的时间复杂度（假设原始链表长度为 $N$ ）为：

$$\begin{align}T &= |L_1| + \frac{|L_0|}{|L_1|} \\\&>= 2\sqrt{|L_1|\times
\frac{|L_0|}{|L_1|}} \\\&= 2\sqrt{|L_0|} = 2N^{\frac{1}{2}}\end{align}$$

所以我们只加了一级索引，但是时间复杂度从 $O(N)$ 下降到了
$O(\sqrt{N})$，这样的空间换时间好像很划算呀。如果加多个索引，那么时间复杂度又如何呢？

接下来我们就来好好分析分析多级索引的情况。

### 时间复杂度

> 依然假设跳表的每一级索引与上一级索引的长度是整数倍的关系，且倍数都一样，便于分析问题。

由上一小节我们看到了只有两层链表的跳表的时间复杂度为 $2N^{\frac{1}{2}}$，那么具有三层链表的跳表的时间复杂度呢？

$$\begin{align}T &= |L_2| + \frac{|L_1|}{|L_2|} +\frac{|L_0|}{|L_1|} \\\&>=
3\sqrt[3]{|L_2|\times \frac{|L_1|}{|L_2|} \times \frac{|L_0|}{|L_1|}} \\\&=
3\sqrt[3]{|L_0|} = 3N^{\frac{1}{3}}\end{align} \tag{1}$$

公式 (1) 中的不等式使用到了均值定理，即：

$x_1$, $x_2$, $x_3$, ..., $x_n$ 为正数时

$$\frac{x_1+x_2+...+x_n}{n} >=\sqrt[n]{x_1x_2...x_n}$$

假设顶层链表的节点个数为 $m$，下一层的个数则为 $m^2$，再下一层为 $m^3$（可以思考下为什么），......，最底层的原始链表元素为
$N$，可以很容易地算出从顶到底的链表层数为 $log_mN$，而此时的时间复杂度为：

$$\begin{align}&T = (log_mN) \times N^{\frac{1}{log_mN}} \\\& =>T = (log_mN)
\times N^{log_Nm} \\\& => T = mlog_mN\end{align}$$

哇，跳表的查找时间复杂度居然是
$O(logN)$，这不就是二分查找的时间复杂度嘛，也就是说有序链表这种结构也可以实现跟二分查找类似的时间复杂度了，普天同庆！

但是，等等，我们也为此付出了代价，为了达到 $O(logN)$ 的时间复杂度，我们使用了 $log_mN$ 个链表，每个链表的个数都是 $m$
的指数次（$m$, $m^2$, $m^3$, ..., $m^{log_mN}$）。那么我们到底为此付出了多少的空间代价呢？

### 空间复杂度

$log_mN$ 个链表的长度从顶到底依次为 $m$, $m^2$, $m^3$, ..., $m^{log_mN}$，则总长度为：

$$\begin{align}L &= m + m^2 + m^3 + ... + m^{log_mN} \\\&= m \times
\frac{1-m^{log_mN}}{1-m} \ \ \ \ // 等比数列求和 \\\&= m \times \frac{N-1}{m-1}
\end{align}$$

即空间复杂度还是 $O(N)$。

很容易计算出，额外增加的空间为 $L-N = \frac{N}{m-1} - \frac{m}{m-1} \approx \frac{N}{m-1}$。

如果 $m=2$，则额外需要 $N$ 个空间，$m=3$，额外需要 $\frac{N}{2}$ 个空间……

这么一算，好像空间复杂度也并没有想想中的那么大，只需要不超过 $N$ 个额外空间，就能获得 $logN$ 的时间复杂度，这笔交易——划算。

这里的分析只考虑元素值本身，忽略了 next 指针和 down
指针的空间占用情况。不过实际工作中我们对于空间复杂度的要求可远远低于时间复杂度，毕竟一寸光阴一寸金。

### 跳表与 HNSW

通过上面的讲解，相信同学们对于跳表及其各种复杂度分析已经了如指掌了。

跳表的性能特别优秀，Redis 底层某些功能就是通过跳表来实现的，有兴趣的同学可以去好好研究一番，这里就不作展开了。

那么，如果查询的元素是向量怎么办呢？这时候跳表好像无能为力了，因为它只适用于元素是单值的情况。但是可不可以从跳表的思想中受到启发，也生成多级索引，每一级的索引都是下一级索引的子集，只不过这些索引不再是链表，而是一个个高维度的空间结构，从而能够快速且精确地搜索到查询元素的近邻呢？

答案当然是肯定的——这就是 HNSW 近邻搜索算法（paper [地址](https://arxiv.org/pdf/1603.09320.pdf)）。

咱们，下篇再见。

* * *

注释 1：这个 Git 仓库不断地更新，在笔者写这篇文章时，HNSW 一直是 TOP1 的存在，随着技术的发展，一定会有性能更好的算法会超越它

注释 2：HNSW 算法 paper 地址在[这里](https://arxiv.org/pdf/1603.09320.pdf)

