上一篇文章已经详细地介绍了 **Apriori 算法** 的细节，这篇文章咱们来好好剖析一下频繁项集挖掘的另一种算法——FPGrowth。

相信聪明的你已经知道 **Apriori 算法** 的致命缺点——慢！

  1. 每一步产生候选集时几乎产生全排列的候选组合，而有的组合可能根本就不是频繁项，且当数据集中物品个数很多时，这样的候选组合数量会极其庞大；
  2. 每一步都需要计算 Support，且每次计算都需要对数据集做全集扫描，不可忍受。

这些问题都可以被接下来“闪亮登场”的 **FPGrowth 算法** $^1$ 各个击破。

### 何谓 FPGrowth

FP 是频繁模式（Frequent Pattern）$^2$ 的缩写，频繁模式一般是指频繁地出现在数据集中的模式。我们知道 Apriori 算法为了找到
**频繁项集** 需要生成很多候选集，正是这一步极大地影响了算法的性能。FPGrowth 算法正是巧妙地避开了这一步，找到频繁模式并不需要生成候选集。整个
FPGrowth 算法的核心在于 FP 树的建立。

### FP 树

如下图是一棵简单的 FP 树，读者可以暂时不用知道它具体是怎么生成的。

![FPTREE](https://images.gitbook.cn/f74fa130-2750-11eb-97c1-1314be3cdf10)

FP 树的 FP 树中的每一个节点（除了根节点），比如 I1、I2、I3 等都是数据集中的某个物品，节点中的数字是 此物品在路径中出现的次数。 FP
树存在的意义就是通过它来挖掘数据中 **最频繁的模式** （Most Frequent Pattern）。

简单介绍了 FP 树的概念之后，咱们来看看 FPGrowth 算法如何利用 FP 树来找到物品与物品之间的关联。

### FPGrowth 算法

前面说到“找到频繁模式并不需要生成候选集”，弄清楚下面 FPGrowth 算法的执行步骤之后，就知道原因了。

1\. 与 Apriori 算法一样，第一步需要 **扫描全量数据集** ，得到所有物品及其对应的次数。

2\. 再次 **扫描全量数据集** ，建立 FP 树。

扫描第一个交易（Transaction），将其中的物品按照次数降序排列，排序后将此交易插入到 FP 树的一根树枝上去。

扫描第二个交易，同样按照次数降序排列，插入到一根新的树枝上去，如果此树枝上有物品与另一根树枝上的物品一样，那么此树枝与另一根树枝共享同一个祖先树枝。

每插入一个节点，该节点对应的物品数就 +1。

> 是不是看起来很抽象？没事，一会儿用一个例子来说明，一看就懂。

依此类推，直到扫描完整个数据集

3\. 构建 **条件 FP 树** ，由条件 FP 树生成最终的频繁模式（频繁项集）。

可见，FPGrowth 算法只需要扫描全量数据集 2 次即可完成，大大提高了挖掘速度。

不过，上面的文字描述太过抽象，一堆新名字，我在第一次看的时候云里雾里，好在有例子，一看便会！

### FPGrowth 算法举例

假设数据集如下。

表 1：

Transaction | Items  
---|---  
T1 | 🍖🍺🍭  
T2 | 🍖🍼🥤  
T3 | 🍼🥤🍺🍕  
T4 | 🍺🥤🍕  
T5 | 🍼🍺🍖🍎  
T6 | 🥤🍺🍖🍼  
T7 | 🍺  
T8 | 🍺🍼🍌🍖  
T9 | 🥤🍺🍖  
T10 | 🍕🍖🍼  
  
以下就据此数据集来详细说明 FPGrowth 算法的步骤。

#### **第一步：统计物品次数**

扫描数据集，得到各个物品的出现次数：

Item | Count  
---|---  
🍺 | 8  
🍖 | 7  
🍼 | 6  
🥤 | 5  
🍕 | 3  
~~🍭~~ | ~~1~~  
~~🍌~~ | ~~1~~  
  
最小支持度设为 2，则针对上述数据集来说，有效物品为：

> 🍺 : 8，🍖 : 7，🍼 : 6，🥤 : 5，🍕 : 3

#### **第二步：构建 FP 树**

再次扫描全量数据集，构建 FP 树。

**1\. 扫描第一个 Transaction** ，将其中不满足最小支持度的删掉，同时根据物品次数降序排序，得到：

Transaction | 原始 | 过滤排序后  
---|---|---  
T1 | 🍖🍺🍭 | 🍺🍖  
  
同时将这条记录插入到 FP 树中（树根永远为 NULL），每个节点中的物品 count 初始均为 1。

![T1](https://images.gitbook.cn/88943d30-2752-11eb-97c1-1314be3cdf10)

**2\. 第二个 Transaction**

Transaction | 原始 | 过滤排序后  
---|---|---  
T2 | 🍖🍼🥤 | 🍖🍼🥤  
  
插入🍖，并没有与 root 节点直接相连的🍖节点，所以新建一个🍖节点作为 root 节点的孩子节点，并依次将🍼节点和🥤节点依次插入，新插入的三个节点的
count 均为 1，形成了一个新的路径 `NULL->🍖->🍼->🥤`。

同时，另一根树枝上的🍖节点生成一个指向新的🍖节点的指针，供后续 FPGrowth 计算使用。

![T2](https://images.gitbook.cn/a4fd0920-2752-11eb-9825-558323e50dbd)

**3\. 第三个 Transaction**

Transaction | 原始 | 过滤排序后  
---|---|---  
T3 | 🍼🥤🍺🍕 | 🍺🍼🥤🍕  
  
首先插入🍺节点，因为 root 节点已经有了一个🍺孩子节点，所以直接对此节点的 count 加 1 即可。

![T3](https://images.gitbook.cn/bfb9f9d0-2752-11eb-9e6e-492b4066adc9)

**4\. 第四个 Transaction**

Transaction | 原始 | 过滤排序后  
---|---|---  
T4 | 🍺🥤🍕 | 🍺🥤🍕  
  
![T4](https://images.gitbook.cn/ce39fb40-2752-11eb-96ab-0d95f8d73f7e)

**5\. 第五个 Transaction**

Transaction | 原始 | 过滤排序后  
---|---|---  
T5 | 🍼🍺🍖🍎 | 🍺🍖🍼  
  
![#](https://images.gitbook.cn/09d190f0-2753-11eb-badb-4943f989e399)

**6\. 第六个 Transaction**

Transaction | 原始 | 过滤排序后  
---|---|---  
T6 | 🥤🍺🍖🍼 | 🍺🍖🍼🥤  
  
![T6](https://images.gitbook.cn/4343d5a0-2753-11eb-9e6e-492b4066adc9)

**7\. 第七个 Transaction**

Transaction | 原始 | 过滤排序后  
---|---|---  
T7 | 🥤🍺🍖🍼 | 🍺🍖🍼🥤  
  
![T7](https://images.gitbook.cn/5137eac0-2753-11eb-b0e7-2bcf5f61297e)

**8\. 第八个 Transaction**

Transaction | 原始 | 过滤排序后  
---|---|---  
T8 | 🥤🍺🍖🍼 | 🍺🍖🍼🥤  
  
![T8](https://images.gitbook.cn/62276590-2753-11eb-97c1-1314be3cdf10)

**9\. 第九个 Transaction**

Transaction | 原始 | 过滤排序后  
---|---|---  
T9 | 🥤🍺🍖🍼 | 🍺🍖🍼🥤  
  
![T9](https://images.gitbook.cn/757c6eb0-2753-11eb-bb9f-e35884210416)

**10\. 最后一个 Transaction**

Transaction | 原始 | 过滤排序后  
---|---|---  
T10 | 🥤🍺🍖🍼 | 🍺🍖🍼🥤  
  
![T10](https://images.gitbook.cn/867697e0-2753-11eb-96ab-0d95f8d73f7e)

最终的 FP 树：

![FINAL](https://images.gitbook.cn/8d9b0dd0-2753-11eb-9825-558323e50dbd)

#### **第三步：条件 FP 树与频繁模式**

在介绍 **条件 FP 树** 之前，先说明下什么是节点的前缀路径（Prefix Paths）：指的是包含该节点的所有路径。

比如，🍕的前缀路径为：

![](https://images.gitbook.cn/a6543f40-2753-11eb-97c1-1314be3cdf10)

🥤的前缀路径为：

![](https://images.gitbook.cn/b216ce60-2753-11eb-bb9f-e35884210416)

现在，就以🍕为例，说明如何根据前缀路径生成条件 FP 树。如下所示：

![](https://images.gitbook.cn/ff144760-2753-11eb-b804-ef8651c2512a)

首先，删除路径中所有的🍕节点，并将路径中所有节点的个数更新为本路径中🍕的个数：

  * 对于🍺，因为它出现在了两条含有🍕的路径中，所以它的次数更新为 1 + 1 = 2 个。
  * 🍖和🍼所在的路径中🍕个位为 1，所以它们的个数均从 2 更新到 1 个。

这一步之后，该树中的物品个数为：

> 🍺 : 2, 🍖 : 1, 🍼 : 2, 🥤 : 2

而 min support 的个数为 2，因此删除🍖。

![](https://images.gitbook.cn/0ea67c20-2754-11eb-b5c5-e14bfa43e9db)

删除🍖后，还剩下🍺🍼🥤，因此🍕对应的频繁项集肯定包含 2-项集 {🥤🍕}{🍼🍕}{🍺🍕}，但是为了找到🍕对应的所有频繁项集，还需要递归地建立
{🥤🍕}{🍼🍕}{🍺🍕} 对应的条件 FP 树。

{🥤🍕} 的条件 FP 树：

![](https://images.gitbook.cn/2d2f9000-2754-11eb-b5c5-e14bfa43e9db)

因此又找到了🍕的一个频繁项集：{🍺🥤🍕}。

{🍼🍕} 的条件 FP 树：空树。

> 为什么🍺不在 {🍼🍕} 的条件 FP 树中呢？留给读者的一个小问题。

![](https://images.gitbook.cn/44337050-2754-11eb-9825-558323e50dbd)

{🍺🍕} 的条件 FP 树：空树。

![](https://images.gitbook.cn/5958a590-2754-11eb-9e6e-492b4066adc9)

遍历完 2-项集之后，发现找到了一个 3-项集 {🍺🥤🍕}，于是继续递归的建立 {🍺🥤🍕} 对应的条件 FP 树，很简单了，为空树。

于是，得到🍕对应的频繁项集：

Item | Frequent Pattern/Itemsets  
---|---  
🍕 | {🍕} {🥤🍕} {🍼🍕} {🍺🍕} {🍺🥤🍕}  
  
相同的逻辑运用在其他物品上，可得到所有的频繁项集：

Item | Frequent Pattern/Itemsets  
---|---  
🍕 | {🍕} {🥤🍕} {🍼🍕} {🍺🍕} {🍺🥤🍕}  
🥤 | {🥤} {🍺🥤} {🍖🥤} {🍼🥤} {🍖🍼🥤} {🍺🍼🥤} {🍺🍖🥤}  
🍼 | {🍼} {🍺🍼} {🍖🍼} {🍺🍖🍼}  
🍖 | {🍖} {🍺🍖}  
🍺 | {🍺}  
  
总结一下 **根据条件 FP 树挖掘频繁模式/项集** 的生成逻辑：

1\. 将物品按照支持度从小到大排序，得到物品集 Itemsets。

2\. 遍历 Itemsets 中的每个 Itemset：

  * 初始化此 Itemset 的频繁模式为 FP。

  * 生成 Itemset 对应的前缀路径。

  * 根据前缀路径以及最小支持度，构建条件 FP 树。

  * 根据条件 FP 树，生成 k 项集（k 项集中的每个组合都包含当前 Itemset），添加到 FP 中。

  * 遍历 k-项集 中的每个 Itemset：

    * 生成 Itemset 对应的前缀路径。
    * 根据前缀路径以及最小支持度，构建条件 FP 树。
    * 根据条件 FP 树，生成 k+1 项集（k+1 项集中的每个组合都包含当前 k-项集），添加到 FP 中。
    * 遍历 k 项集 中的每个 Itemset……

3\. 可见挖掘的过程是一个递归操作，直到某个 k+n 项集生成的条件 FP 树为空树才停止。

### 下篇预告

本篇详细地描述了 FPGrowth 的算法原理，其中最最核心的部分当然是条件 FP
树的建立，希望读者一定要弄清楚建立的过程，基本上这也是该算法唯一一个有难度的地方。

现在我想将 FPGrowth 算法运用在地鼠商城的购物车推荐上，可是要怎么实现呢？

开什么玩笑，作为地鼠商城最老的元老，怎么可能重复造轮子！Spark 早已帮我们准备好了，所以下一节，咱们就来分析下 Spark 实现 FPGrowth
算法的源码。

下篇见。

* * *

注释1：[FPGrowth paper](https://www.cs.sfu.ca/~jpei/publications/sigmod00.pdf)

注释2：一般计算机大神们都喜欢用 Pattern 这个词，其实 FP 和频繁项集的意思没有太大区别

