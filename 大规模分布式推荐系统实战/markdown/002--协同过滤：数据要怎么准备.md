上一篇文章中提到，随着地鼠商城的商品越来越多，用户越来越难以发现自己感兴趣的商品，除了少数销量超高的店铺之外，很多的商家都不满意自己在商城的曝光量，不断地投诉——收了“平台保护费”还得不到保护。这是我们要解决的问题：提高用户体验的同时，提升商家的满意度。

作为地鼠商城个性化推荐系统的主程（其实就我一个人），最先想到的当然是——协同过滤，这一经典的充满哲理的简约算法。

俗话说，物以类聚、人以群分，协同过滤便是对此的完美体现。

本文主要讲解物品协同过滤（Item-item collaborative filtering）。用户协同过滤（User-user collaborative
filtering）的逻辑与之完全相同。

### 什么是协同过滤$^1$

首先看下[维基百科](https://en.wikipedia.org/wiki/Item-
item_collaborative_filtering)对协同过滤的定义：

> Item-item collaborative filtering, or item-based, or item-to-item, is a form
> of collaborative filtering for recommender systems based on the similarity
> between items calculated using people's ratings of those items.

可见，协同过滤的基本思想如下。

给用户推荐那些和他们之前“感兴趣”的物品相似的物品，一般分成两步：

  1. 计算物品之间的相似度；
  2. 根据物品的相似度和用户的历史行为给用户生成推荐列表。

所以协同过滤的核心是计算物品的相似度，不过咱们暂时跳过第 1 步，来看看第 2 步是如何完成的。

### 如何使用协同过滤

假设我们已经有了一张物品相似度表（简单起见，每件商品只保留 top3 的相似商品），表数据如下：

物品 1 | 物品 2 | 相似度  
---|---|---  
iPhone11 | iPhone10 | 0.95  
iPhone11 | Huawei P40PRO | 0.80  
iPhone11 | iPhone11 手机壳 | 0.50  
MacBook Pro | Surface Pro | 0.90  
MacBook Pro | iPad | 0.70  
MacBook Pro | Xbox One X | 0.30  
大米 | 面粉 | 0.8  
大米 | 小米 | 0.7  
大米 | 食用油 | 0.4  
…… | …… | ……  
  
同时系统也存储了每个用户的历史行为轨迹：

用户 | 行为轨迹  
---|---  
小明 | MacBook Pro、iPhone11、大米……  
小暗 | ……  
小黑 | ……  
  
那么，当小明来到地鼠商城时，仅含有协同过滤的召回服务的运转过程如图：

![](https://images.gitbook.cn/37bd63d0-2650-11eb-b804-ef8651c2512a)

  * 推荐引擎将“小明的信息”传递给召回服务；
  * 召回服务以此找到小明的行为轨迹，得到小明的历史行为商品列表；
  * 根据小明的历史行为商品$^2$ 列表，去物品相似度表中查询每条行为商品对应的相似商品，得到最终的推荐列表；
  * 返回给推荐引擎。

上述流程中，用户的行为轨迹和物品相似度表一般存储在 Redis/HBase 中。

至此，我们已经完全弄清楚 **协同过滤** 的使用方法，那么作为整个算法中最为核心的物品相似度该如何去计算呢？

### 物品相似度计算

再来回顾一下协同过滤的定义：

> ... based on the similarity between items calculated using people's ratings
> of those items.

由此看出，要计算物品相似度，首先得有用户对商品的打分，而打分数据的构造，将是决定整个算法性能表现的重中之重。

#### **用户打分**

在进入正题之前，先熟悉一个概念——隐式反馈。与之相对应的是显式反馈。

  * 显式反馈：用户很明确地表达出自己的喜好，比如豆瓣的评分以及知乎的点赞等用户主动打分的行为。 
  * 隐式反馈：用户不明确地表达出自己的喜好，比如用户在地鼠商城中的商品浏览行为等，用户并没有明确表现出对此商品的喜好，只能说用户可能对此商品有喜好（比如浏览商品后发现不是自己想要的，那么虽然有浏览行为，但是用户并不喜欢此商品）。

很明显，在绝大多数的应用里，包括地鼠商城，都只有用户的隐式反馈行为，这种行为数据量大、容易获取，但不是用户直接喜好的体现，那么就需要建立一套打分机制，去将隐式反馈转化为显式反馈。

下面介绍常见的两种打分机制。

**0/1 打分**

这是最基础的打分策略，只要用户对物品有过行为（不管是浏览、加购、购买等任何行为），那么打分就是 1 分，所以会生成类似这么一张打分表：

用户\物品 | 《算法导论》 | P40PRO | 《计算机原理》 | iPad | 啤酒 | 葡萄酒  
---|---|---|---|---|---|---  
小明 |  | 1 |  | 1 |  |  
小暗 | 1 |  | 1 |  |  |  
小黑 |  |  |  |  | 1 | 1  
  
不过在实际的工作中很少会使用这种打分机制，因为它完全掩盖了用户的行为差别（浏览和购买、加车等行为所反映的用户喜好程度应该是不一样的）。

**多行为打分** $^3$

假设用户行为表中，有如下数据（简单起见，只考虑用户的浏览和购买行为）：

用户 | 物品 | 行为类型 | 行为时间  
---|---|---|---  
小明 | P40PRO | 浏览 | 20200610  
小明 | iPhone11 | 浏览 | 20200605  
小暗 | 《操作系统原理》 | 浏览 | 20200510  
小暗 | iPhone11 | 浏览 | 20200515  
小明 | iPad | 浏览 | 20200530  
小明 | 吸尘器 | 浏览 | 20200401  
小明 | 空气净化器 | 浏览 | 20200405  
小暗 | P40PRO | 购买 | 20200520  
小明 | P40PRO | 购买 | 20200611  
小暗 | 香皂 | 浏览 | 20200620  
  
针对这张表，为了得到用户对物品的打分，需要经过以下几个步骤。

**1\. 确定行为分值（假设购买固定为 5 分）**

  * 人为拍板：浏览分值为 1 分，购买分值为 5 分
  * 根据每种行为的次数而定：
    * 浏览分值 = 购买分值 * 购买次数 / 浏览次数 = 5 * 2 / 8 = 1.25 分
    * 浏览分值 = 购买分值 / LOG2( 浏览次数 / 购买次数 ) = 5 / LOG2(8 / 2) = 2.5

有了每个行为的分值，但是为了计算用户对物品的打分，我们还有两个方面需要考虑。

**2\. 行为时间衰减**

假设当前时间是 20200620，那么小明在 20200610 浏览了 P40PRO，20200605 浏览了
iPhone11，时间越靠近当前时间，行为更能反映用户的喜好（人是不断变化的）。

一般可以尝试以下几种时间衰减策略之一：

  * 线性衰减：DECAY(X) = 1 / (1 + X)。这里 X 是当前时间与行为时间的时间差（单位是天）
  * 指数衰减：DECAY(X) = EXP(-X / C)。这里的 C 是一个常量，业务不同，C 的取值也不同。这个公式也称为遗忘曲线
    * 当 X = C 时，EXP(-X / C) = 1/ 2.718 ≈ 1 / 3，也就是 C 天前的行为打分会被衰减成 原来分值的 1 / 3 ，可以以此来设定 C 的值，比如我希望 7 天衰减成 1/3，那么 C = 7，希望 10 天衰减成 1 / 3，C = 10 
  * 不衰减：不考虑时间衰减

假设浏览分值为 1 分，采用指数衰减，C 为 7，则小明：

  * 对 20200610 浏览的 P40PRO 的打分 = 1 * EXP(-10 / 7) = 0.24
  * 对 20200605 浏览的 iPhone11 的打分 = 1 * EXP(-15 / 7) = 0.12

**3\. 打分合并**

现在还有一个问题需要解决，那就是用户对同一件物品有多个行为，该如何处理呢？一般可以尝试以下策略之一：

  * 打分累加：比如小明对 20200610 的 P40PRO 的浏览行为根据指数衰减后的打分为 0.24 分，对 20200611 的 P40PRO 的购买行为根据指数衰减后的打分为 1.28 分，则 小明 对 P40PRO 的打分为 1.28 + 0.24 = 1.52 分。
  * 最大打分：很好理解，取同一种物品打分中最高的那个，则小明对 P40PRO 的打分为 MAX(1.28, 0.24) = 1.28 分。

同学们根据具体业务不同，可以采取不同的行为分值、时间衰减和打分合并策略，当然如果时间充裕，每个策略都可以去尝试一遍。

经过上述步骤，我们已经可以得到一张基本可以反映用户喜好程度的用户打分表，终于到物品相似度计算这一步了。

假设：

  * 行为分值：浏览 1 分、购买 5 分
  * 行为时间衰减：指数衰减，C 为 7
  * 打分合并：最大打分
  * 当前时间：20200620

据此，得到如下用户物品打分表：

用户 | 物品 | 打分  
---|---|---  
小明 | P40PRO | 1.28  
小明 | iPhone11 | 0.12  
小明 | iPad | 0.05  
小明 | 吸尘器 | 0.00001  
小明 | 空气净化器 | 0.00002  
小暗 | 《操作系统原理》 | 0.0033  
小暗 | iPhone11 | 0.0067  
小暗 | P40PRO | 0.07  
小暗 | 香皂 | 1  
  
#### **相似度计算**

**单用户**

让我们先从最简单的情况开始：只有一个用户，也就是说，整个地鼠商城就一个用户产生过行为，这个人就是小明。

小明的物品打分集合如下：

用户 | 物品打分集合  
---|---  
小明 | P40PRO : 1.28, iPhone11 : 0.12, iPad : 0.05, 吸尘器 : 0.00001, 空气净化器 :
0.00002  
  
因为只有小明一个用户的行为，所以地鼠商城的物品相似度表只能基于他的行为去计算得到。

显然，从同一个人的角度去看，他对两个物品的打分越接近，这两个物品在他眼里就越相似，所以需要把打分与相似度对应起来，可以参考以下几种策略。

**求分差** ：similarity(item1, item2) = 1 / (1 + |score1 -
score2|)。通过分差去计算相似度：分差越小相似度越高。

  * similarity(P40PRO, iPhone11) = 1 / (1 + |1.28 - 0.12|) = 0.46
  * similarity(iPhone11, iPad) = 1 / (1 + |0.12 - 0.05|) = 0.93

**求倍数** ：similarity(item1, item2) = 1 / (1 + |LOG2(score1 /
score2)|)。通过分数的倍数去计算相似度：倍数越大相似度越小。

  * similarity(P40PRO, iPhone11) = 1 / (1 + |LOG2(1.28 / 0.12)|) = 0.23
  * similarity(iPhone11, iPad) = 1 / (1 + |LOG2(0.12 / 0.05)|) = 0.44

**其他** ：只要能够满足分数越接近，相似度越高的计算方法，都可以尝试。

上述计算方法皆是抛砖引玉，根据分值得到相似度的计算方法实在太多了。

通过 **求分差法** 以及唯一用户小明的打分集合，可以计算出物品相似度表（保留 top3）：

物品 1 | 物品 2 | 相似度  
---|---|---  
P40PRO | iPhone11 | 0.46  
P40PRO | iPad | 0.45  
P40PRO | 吸尘器 | 0.43  
吸尘器 | 空气净化器 | 0.99  
吸尘器 | iPad | 0.95  
吸尘器 | iPhone11 | 0.89  
…… |  |  
  
那么，如果小暗也来到了地鼠商城，此时有两个用户了，该如何计算相似度呢？

**多用户**

首先，小暗的物品打分集合如下：

用户 | 物品打分集合  
---|---  
小暗 | 《操作系统原理》: 0.0033, iPhone11 : 0.0067, P40PRO : 0.07, 香皂 : 1  
  
采用上节同样的计算方法，也可以得到小暗视角的物品相似度：

物品 1 | 物品 2 | 相似度  
---|---|---  
P40PRO | iPhone11 | 0.94  
P40PRO | 《操作系统原理》 | 0.937  
P40PRO | 香皂 | 0.52  
…… | …… | ……  
  
可见，只有 (P40PRO, iPhone11) 这一物品对在小明和小暗的个人物品相似度表中均有出现，需要合并。

可以对两条记录求平均，得到最终的相似度，也即：

> 相似度 (P40PRO, iPhone11) = (小明眼中的 (P40PRO, iPhone11) 的相似度 + 小暗眼中的 (P40PRO,
> iPhone11) 的相似度) / 2

综上，得到相似度合并的步骤：

  * 如果一对物品只出现一个用户的行为记录中，那么此用户眼中的相似度即代表了此物品对的相似度；
  * 如果一对物品出现在了多个用户的行为记录中，那么将多个用户眼中的相似度求平均，即可得到此物品对的最终相似度。

一对物品的相似度计算出来了，那么根据同样的逻辑，全量物品之间的相似度也就自然而然可以计算出来了。

掌握了协同过滤所需的一切之后，地鼠商城的协同过滤设计便水到渠成。

### 地鼠商城召回算法之协同过滤设计思路

  1. 首先要拿到四张用户行为表：流览表、加车表、收藏表以及购买表；
  2. 根据“多行为打分”中的打分策略，将所有用户的隐式反馈转化为显示反馈，得到用户的打分表；
  3. 根据单个用户的行为列表，计算 物品相似度，得到 (物品 ID1, 物品 ID2) -> 相似度 SIM；
  4. 以 (物品 ID1, 物品 ID2) 为 KEY，聚合相同的 (物品 ID1, 物品 ID2) 对应的 相似度集合 [SIM1, SIM2, SIM3, ......]；
  5. 针对第 4 步中得到的 相似度集合求平均，即可得到 (物品 ID1, 物品 ID2) 最终的相似度。

上述流程如下图所示：

![](https://images.gitbook.cn/774ef130-2655-11eb-badb-4943f989e399)

  * u：用户
  * i：物品
  * ts：时间戳
  * s：打分
  * sim：相似度

i11 表示用户 1 对物品 1 产生行为、i21 表示用户 2 对物品 2 产生行为。这里的聚合可以理解为 SQL 中的 GROUP BY。

### 下篇预告

在设计完地鼠商城的协同过滤算法之后，接下来要做的就是去实现以及改进它。

下一篇的主要内容有：

  * 协同过滤的分布式代码怎么编写
  * 协同过滤有哪些常用的优化方法，不仅让算法运行的更快，还能让算法更准

下篇再见。

* * *

注释
1：本文的协同过滤除非特别说明，一般指物品协同过滤，[论文地址](http://files.grouplens.org/papers/www10_sarwar.pdf)

注释 2：行为商品，指的是产生过行为（如点击、购买等）的商品

注释 3：多行为指电商里有浏览、加车、收藏和购买，视频网站有播放、点赞、分享和下载等等

