>
> 第一次看到“装配线与工作站问题”是老师在课堂上出的一个题目，当时脑子简单，直接就用穷举法给解了，后来看到《算法导论（第二版）》这本书用的是动态规划算法来解决的，实际测试后发现其效率是穷举法的四五倍，感觉十分神奇，后来理解了动态规划的原理之后，也就不觉得神奇了。
>
> 第 3 部分的内容是介绍穷举法在算法设计中的应用，所以我们先介绍如何用穷举法来解决这个问题。介绍第 4
> 部分动态规划内容时，我会再具体介绍如何用动态规划的思想来设计这个算法。

### 算法分析

首先介绍一下这个题目：Colonel
汽车公司在有两条装配线的工厂内生产汽车，一个汽车底盘在进入每一条装配线后，每个工作站会在汽车底盘上安装不同的部件，最后完成的汽车从装配线的末端离开，如图（1）所示：

![enter image description
here](https://images.gitbook.cn/f5fcaa60-b70b-11e8-bb53-294539be73f6)

图（1）装配线与工作站问题图示例

每一条装配线上有 n 个工作站，编号为 j=1,2,…,n，把装配线 i（i 为 1 或 2）的第 j 个工作站表示为 S(i,j)。装配线 1 的第 j
个工作站 S(1,j) 和装配线 2 的第 j 个工作站 S(2,j)
执行相同的功能，然而这些工作站是在不同的时间建造的，并且采用了不同的技术，因此，每个工作站上完成装配所需要的时间也不相同，即使是在两条装配线相同位置的工作站也是这样。把每个工作站上所需要的装配时间记为
a(i,j)，并且，底盘进入装配线 i 需要的时间为 e(i)，离开装配线 i 需要的时间是
x(i)。正常情况下，底盘从一条装配线的上一个工作站移到下一个工作站所花费的时间可以忽略，但是偶尔也会将未完成的底盘从一条装配线的一个工作站移到另一条装配线的下一个工作站，比如遇到紧急订单的时候。假设将已经通过工作站
S(i,j) 的底盘从装配线 i 移走所花费的时间为 t(i,j)，现在的问题是要确定在装配线 1 内选择哪些工作站以及在装配线 2
内选择哪些工作站，可以使汽车通过工厂的总时间最小，如图（2）所示，最快的时间是选择装配线1的 1、3 和 6 号工作站以及装配线 2 的 2、4 和 5
号工作站。

![enter image description
here](https://images.gitbook.cn/0b7508b0-b70c-11e8-b4f9-03a2d2559361)

图（2）最优解的底盘转移过程示意图

这个题目描述很长，简单理解一下这个题目的意思就是汽车底盘选择一条装配线，期间不能更换，从第一个工作站移动到最后一个工作站，即可完成安装，但是根据对题目的理解，这样所花费的时间肯定不是最短的。如果另一条装配线上的某个工作站效率比较高，那么装配到这一步的时候，换到那条装配线上进行装配肯定会节省时间，但是考虑到从一条装配线移动到另一条装配线也需要花费时间，那就要综合考虑了。“移”还是“不移”？这是个问题。

之前的课程介绍过穷举的几种模式，这里复习一下，这些模式分别是线性遍历、广度搜索遍历和深度搜索遍历以及树形遍历，具体使用何种遍历模式，取决于问题的解空间是什么模式。本题的答案是汽车底盘完成安装花费的时间，不过千万不要头脑简单，本题的解空间肯定不是一个个装配时间。透过现象看本质，装配时间是怎么算出来的？是汽车底盘在每个工作站之间移来移去，最后完成装配时把每次移动底盘需要的时间和在每个工作站的装配时间求和就是最终的装配时间。所以，本题的解空间是底盘在各个工作站上装配和移动的过程记录，根据这个过程记录，很容易计算出实际的装配时间。

如何产生一个移动过程记录？对了，产生一个移动过程记录的关键点是“移动”这个动作。根据题意，每次“移动”会有两个可能的结果，其一是在本生产线上继续移动到下一个工作站，另一个是移动到另一条装配线上的下一个工作站。显然，我们的移动过程记录是树形结构，每次移动产生两个分支，如图（3）所示，最终的结果就是和一棵二叉树一样的结构，从根节点到任何一个叶子节点就是一个移动过程。我们的穷举过程就是对每个移动过程来计算花费的时间，然后比较时间，找出花费时间最短的移动过程。

![enter image description
here](https://images.gitbook.cn/1b2db130-b70c-11e8-bb53-294539be73f6)

图（3）解空间与最优解移动记录示意图

对树形空间遍历，最好的策略就是使用递归的方法进行穷举。考虑到解空间规模比较大，如果采用先穷举搜索得到全部的解空间，然后再逐个计算装配时间并比较时间的方法，就需要一个很大的存储空间，当问题规模比较大时，有可能超出系统存储能力的限制。为了避免这个问题，算法在遍历的过程中，应该找到一个完整的装配过程后就立即与当前已知最小值进行比较，如果这个结果已经不是最优解，则不存储当前结果，然后回溯到上一个位置，继续遍历。如果这个结果比当前最小值还要小，则记录这个结果，并更新当前已知最小值，然后再回溯。

### 准备数据模型

根据题目给出的信息，这个算法给出的时间开销参数有四种，分别是每个工作站的装配时间、每个工作站转移到另一条装配线的转移时间、进入装配线时间和离开装配线时间，这些值统一存放在`Program_T`数据结构中。进入和离开装配线的时间开销用一维数组存储，每个工作站的装配时间和转移时间用二维数组存储，这个数据结构的定义比较简单：

    
    
    typedef struct 
    {
        int assemble_time[LINES][STATIONS];
        int transport_time[LINES][STATIONS];
        int enter_time[LINES];
        int exit_time[LINES];
    }Program_T;
    

前面算法策略提到，穷举遍历不保存全部结果，但是需要保存当前正在搜索的一个结果和当前已知的最优结果。根据题目要求，算法的结果输出除了装配时间，还要包含底盘在各个工作站的转移记录。所以，每个结果应包含两个属性，一个是装配时间，另一个是转移记录。遍历结果的数据结构定义如下：

    
    
    typedef struct
    {
        int line[STATIONS];  //遍历过程中的当前结果记录
        int fs;
        int fline[STATIONS];  //当前已知的最优结果
        int ffs;
    }Result_T;
    

转移记录用一个一维数组表示，表示每个工作站所在的装配线，比如 line[3] 存放的就是第 4 个工作站所在的装配线（工作站和装配线的编号都是从 0
开始，便于数组操作）。ffs 和 fline 存放当前已知的最优结果，当整个搜索遍历完成后，它们就是最终结果。

### 穷举算法设计

有递归的地方就有回溯，二者的关系剪不断，但理起来也不乱。在上面“算法分析”中提到过，树形结构的遍历使用递归法最简单，用递归法设计算法的关键是找到递归主体和递归退出条件，递归主体可以认为是一个子结构，所有的子结构都可以用同一套方法进行处理，子结构的区别仅仅在于层次或位置不同。递归不能无限制进行，必须在合适的地方退出，以便进行回溯处理。设计递归算法，递归主体和退出条件明确了，算法也就实现了。

先来分析一下这个算法的递归主体，这个算法实现的核心就是将汽车底盘从一个工作站移动到下一个工作站，移动底盘到下一个工作站有两种选择，归纳起来就是，假如底盘当前的位置在第
i 条装配线上的第 j 个工作站，则底盘可以采用以下两种方式移动：

  * 移动到第 i 条装配线上的第 j+1 个工作站；
  * 移动到第 (i+1)%2 条装配线上的第 j+1 个工作站，需要记录转移装配线的开销。

其中，(i+1)%2 的意义就是当 i 是 0 的时候，转到 1 号装配线，当 i 是 1 的时候，转到 0 号装配线）。

这就是我们的递归子结构，无论当前底盘在哪个工作站，都可以用这个子结构对其进行移动操作。再看子结构之间的区别，那就是表示装配线和工作站编号的 i 和 j
两个参数。如果算法的递归主体用一个接口函数来封装，那么这个函数至少要有 i 和 j
两个参数，考虑到程序参数和结果的传递，可以推导出递归算法的主体函数原型应该是这样的：

    
    
    void search_stations_sequence(Result_T *rt, Program_T *para, int line, int station)
    

接着分析递归的终止条件。显然，当底盘从任何一条装配线的最后一个工作站移出时，即表示完成了汽车底盘的安装，也就意味着已经遍历到了一个结果。根据对递归子结构的分析，当第
j 个工作站就是最后一个工作站时，就应该退出递归，开始回溯。如果我们定义工作站的数量是 STATIONS，那么上述函数原型中 station 参数的值等于
STATIONS - 1 时，就意味着底盘已经完成最后一个工作站的安装，需要处理结果并进行回溯。

两个条件都已经分析完了，现在可以着手完成`search_stations_sequence()`函数的具体实现了。`search_stations_sequence()`函数应该做三个事情：

  1. 当 station 参数等于 STATIONS - 1 时，处理结果并退出递归；
  2. 将当前的装配线和工作站的编号记录到`Result_T`结果中；
  3. 调整 line 和 station 参数，通过递归调用自身的方式，完成递归子结构中定义的操作。

将这三个事情翻译成代码，就是`search_stations_sequence()`函数的具体实现：

    
    
    void search_stations_sequence(Result_T *rt, Program_T *para, int line, int station)
    {
        if (station == (STATIONS - 1)) //1. 完成装配，整理一次结果，退出当前递归子结构
        {
            rt->fs += para->assemble_time[line][station];
            rt->fs += para->exit_time[line];
            rt->line[station] = line;
            if (rt->fs < rt->ffs) /*当前穷举到的路径时间开销更小*/
            {
                rt->ffs = rt->fs;
                memmove(rt->fline, rt->line, STATIONS * sizeof(int));
            }
            return;
        }
    
        //2. 记录中间结果到 line 属性中
        int curCost = rt->fs + para->assemble_time[line][station];
        rt->line[station] = line;
    
        //3. 调整 line 和 station 参数，完成递归子结构的动作
        /*选择本装配线的下一个装配站，开销忽略不计*/
        rt->fs = curCost;
        search_stations_sequence(rt, para, line, station + 1);
    
        /*选择另一条装配线的下一个装配站，需要计算转移开销*/
        rt->fs = curCost;
        rt->fs += para->transport_time[line][station + 1];
        int nextline = (line + 1) % LINES;
        search_stations_sequence(rt, para, nextline, station + 1);
    }
    

当 station == (STATIONS - 1) 条件成立时，就意味着得到了一个结果，此时需要计算这次装配流程的时间开销。由于 fs
参数已经记录了每一步的时间开销，所以这里只要加上最后一个工作站的装配时间和从装配线上移走需要的时间即可。

    
    
    rt->line[station] = line;
    

这行代码的作用是记录最后一个工作站的装配线信息，形成完整的转移记录。接下来就是与当前已知最优结果比较，当前已知最优结果被初始化为一个很大的数，这也是从一批结果中寻找最小值时常用的技巧。最后是通过调整子结构参数递归调用`search_stations_sequence()`来遍历下一个工作站的所有移动操作，当完成后返回回溯点时，要对
fs 重新赋值，以实现正确的回溯。

最后，补上底盘进入装配线，开始穷举遍历的启动代码，算法就完成了。

    
    
    result.fs = pd.enter_time[0];  //装配线 1 的进入开销
    search_stations_sequence(&result, &pd, 0, 0); //从第一条装配线开始
    result.fs = pd.enter_time[1];  //装配线 2 的进入开销
    search_stations_sequence(&result, &pd, 1, 0); //从第二条装配线开始
    

只要`Program_T`的参数无误，就能得到正确的结果：

    
    
    Total Time 38
    Station 1 on Line 1
    Station 2 on Line 2
    Station 3 on Line 1
    Station 4 on Line 2
    Station 5 on Line 2
    Station 6 on Line 1
    

### 总结

这一课我们使用穷举法实现了对“装配线和工作站”问题的算法设计，演示了如何用递归法对二叉树结构的解空间进行穷举遍历，重点介绍了数据模型的定义和算法实现的思考以及分析过程。希望读者看完这一课的内容后，能够再掌握一种穷举遍历的方法，并且对穷举法有更深入的理解。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

