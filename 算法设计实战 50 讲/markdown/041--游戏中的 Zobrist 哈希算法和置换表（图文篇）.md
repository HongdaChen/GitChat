> 复杂棋类游戏的搜索和估值通常比较耗时，为了提高棋类游戏的
> AI，人们通常会使用置换表，置换表存储的是一些已知棋局的评估结果，当遇到相同的棋局时，查置换表比再搜索一遍要高效。既然要查表，就意味着需要对棋局进行比较，人们通常采用哈希算法将棋局映射为固定长度的哈希值，然后通过比较哈希值实现对棋局的比较。在各种哈希算法中，Zobrist
> 哈希算法简单实用，并且高效，在各种棋类游戏算法中得到了广泛的应用。

### Zobrist 哈希算法

Albert L.Zobrist 在 1970 年发表了一篇名为 _A New Hashing Method with Application for
Game Playing_ 的论文，提出了一种可用于游戏局面评估的哈希算法，这种算法后来被命名为 Zobrist
哈希算法。该算法为棋盘上每一个位置的所有可能状态赋予一个绝不重复的随机编码，通过对不同位置上的随机编码进行异或计算，在极低冲突率的前提下将复杂的棋局编码为一个整数类型哈希值。Zobrist
哈希算法的数学原理非常简单，就是利用异或操作的数学特性：(A^B)^B = A。

#### Zobrist 哈希算法原理

对于一个棋盘状态，Zobrist 哈希算法的哈希编码步骤如下。

（1）识别出棋盘的最小单位（格子或交叉点），确定每个最小单位上所有可能的状态数。以奥赛罗棋为例，其最小单位是 8 × 8 = 64
个可以落子的交叉点，每个交叉点有 3 种状态，分别是空状态、黑棋和白棋。

（2）为每个单位上的所有状态都分配一个随机的编码值。棋类游戏一般需要“棋盘最小单位数×状态数”个状态，以奥赛罗棋为例，需要 64 × 3 个随机数编码值。

（3）对指定的棋局，每个单位上的当前状态用对应的编码值（随机数）做异或运算，最后得到一个哈希值。

以上第（1）步和第（2）步是准备阶段，可以实现计算并分配好，只有第（3）步是对每个棋局进行编码计算。用 Zobrist
算法产生的编码值是个随机数，表面上看起来好像和棋局没有什么关系，但是如果棋子移动过，相关的一个或多个最小单位上的状态就会变化，于是对应的编码值也就变化了，棋局的哈希值相应也发生了变化。也就是说，只要一个棋子发生变动，最终得到的棋局哈希值也会变化。

Zobrist
哈希算法有两大优点，第一个优点是冲突概率小，只要随机编码值的范围够大，棋局哈希冲突的概率非常小，实际应用中基本上不考虑冲突的情况（最多就是出个昏招输掉一局棋）；第二个优点是棋局发生变化时，不必对整个棋局重新计算哈希值，只需要计算发生变化的那些最小单元的状态变化即可，对棋类游戏算法的搜索效率来说，这是一个非常诱人的红利。

![](https://images.gitbook.cn/7d7307d0-078b-11e9-846c-df2cdd71336c)

图（1）Zobrist 哈希算法示意图

接下来，我们用一个简单的例子解释一下 Zobrist 哈希算法的原理，以及该算法第二个优点的体现。假设有一个大小为 2 × 2 的棋盘（4
个棋子位置），每个位置有 3 个状态，分别是空状态、黑棋和白棋。我们用一维数组做棋盘模型，这四个棋子的位置分别为 1 ~
4，如图（1）所示。按照哈希编码的第（1）步和第（2）步，我们需要给 4 × 3 = 12 个状态分别给出一个随机编码（以 32 位编码为例）：

位置 | 空状态 | 黑棋 | 白棋  
---|---|---|---  
1 | 0x‭269328D5‬ | 0x0‭3FEC752‬ | 0x‭177044D6‬  
2 | 0x‭070DAEF9‬ | 0x‭1F4EBA0C‬ | 0x‭2809F58E‬  
3 | 0x‭3234D017‬ | 0x‭28CC3BE2‬ | 0x‭1015BE02‬  
4 | 0x‭1975EF52‬ | 0x‭1C991C94‬ | 0x‭157CC882‬  
  
假设黑棋在位置 1 上放置一枚棋子，如图（1-b）所示的棋盘状态，Zobrist 哈希值的计算方法是：

    
    
    hash1 = (1黑棋)^(2空状态)^(3空状态)^(4空状态) = 0x0‭3FEC752^0x‭070DAEF9‬^0x‭3234D017‬^0x‭1975EF52 = ‬0x‭2FB256EE
    

当白棋在位置 4 上放置一枚棋子后，如图（1-c）所示的棋盘状态，Zobrist 哈希值的计算方法是：

    
    
    hash2 = (1黑棋)^(2空状态)^(3空状态)^(4白棋) = 0x0‭3FEC752^0x‭070DAEF9‬^0x‭3234D017‬^0x‭157CC882 = ‬0x‭‭23BB713E‬
    

实际上，对于图（1-c）所示的棋盘状态，不需要完整计算哈希值，只需要在图（1-b）状态对应的哈希值基础上，修改变化的部分即可得到图（1-c）所示的棋盘状态哈希值。图（1-c）相对于图（1-b）的变化就是位置
4 的状态由“空状态”变成“白棋”，具体的计算方法是：

    
    
    hash2 = hash1^(4空状态)^(4白旗) = ‬0x‭2FB256EE^0x‭1975EF52‬^0x‭157CC882‬ = 0x‭23BB713E
    

由此可见，当棋盘规模比较大，状态比较多的时候，这种只计算差异部分就能更新哈希值的算法能够带来巨大的效率提升。

#### 五子棋的 Zobrist 哈希算法实现

五子棋的棋盘是上一节例子的放大版，它有 64 个位置，每个位置有 3 个状态（空状态、黑棋和白棋）。很显然，对适用于五子棋的 Zobrist
哈希算法建模需要用到二维表，一个维度是棋盘位置，另一个维度是棋盘状态：

    
    
    typedef struct tagZobristHash
    {
        unsigned int key[GAME_CELLS][PLAYER_TYPE];
    }ZOBRIST_HASH;
    

实现 Zobrist 哈希算法的第（2）步是为所有的位置和状态指定各不相同的随机数，我们使用 32 位的随机数，计算出来的哈希值也是 32
位的。实际上，为了进一步降低哈希值冲突的概率，很多棋类游戏都使用 64 位的随机数，计算 64 位的哈希值。C++ 的 rand() 函数只能得到 16
位的伪随机值，因此每次用两个 16 位随机值组合成一个 32 位的随机值。

    
    
    void InitZobristHashTbl()
    {
        srand((unsigned)time(NULL));
    
        for(int i = 0; i < GAME_CELLS; i++)
        {
            for(int j = 0; j < PLAYER_TYPE; j++)
            {
                zob_hash.key[i][j] = rand() | ((unsigned int)rand() << 15);
            }
        }
        zobristHashInit = true;
    }
    

第（3）步就是用上面的随机数表计算棋盘的哈希值，i 是棋盘的逻辑位置，范围是 1 ~ 64。cell2board[] 是棋盘逻辑位置与实际 Warren
Smith 棋盘模型中的位置关系对照表，m_board[cell] 的值就是棋盘逻辑位置的落子状态。Zobrist 哈希算法是不是很简单？

    
    
    unsigned int GameState::GetZobristHash()
    {
        unsigned int hash = 0;
        for(int i = 0; i < GAME_CELLS; i++)
        {
            int cell = cell2board[i];
            hash ^= zob_hash.key[i][m_board[cell]];
        }
    
        return hash;
    }
    

增量计算的优势怎么体现呢？假如我们知道某个棋局的 Zobrist 哈希值是 hash，此时黑棋在 cell
位置落子，那么落子后棋局新的哈希值的计算方法就是：

    
    
    const int PLAYER_NULL = 0;  //空状态
    const int PLAYER_A = 1;   //黑棋
    const int PLAYER_B = 2;   //白棋
    
    new_hash = hash ^ zob_hash.key[cell][PLAYER_NULL] ^ zob_hash.key[cell][PLAYER_A];
    

原理就是先将原来对应的空状态异或掉（还记得 (A^B)^B = A 吧），然后再与黑棋对应的状态异或，就得到了棋局新状态的 hash
值。假如此位置的黑棋后来被白棋反转了，那么针对这个位置的变化就是：

    
    
    new_hash = hash ^ zob_hash.key[cell][PLAYER_A] ^ zob_hash.key[cell][PLAYER_B];
    

对所有变化的位置都如此异或计算一遍，最后的 hash 值就是新棋局的 hash 值，不需要使用 GetZobristHash() 函数把全部 cell
都重算一遍。

### 置换表

简单来说，置换表就是已知棋局的 Zobrist
哈希表。棋类游戏中使用置换表的目的一般有两个，一个是利用置换表存储已知棋局的评估结果，对棋局进行评估时，可以先搜索置换表，避免重复搜索；使用置换表的另一个目的是使用事先准备好的棋局数据库，提高电脑
AI 下棋的“智商”。

#### 辅助搜索

置换表用于存储已经搜索过的棋局（包括以该棋局为根的搜索子树）的搜索结果，搜索算法在搜索一个棋局时，首先查置换表，如果从置换表中能查到这个棋局的信息（已经完成的搜索结果），就可以直接使用这些信息，从而避免对这个棋局再次做完整搜索。置换表的每个表项包含与该棋局有关的搜索信息，如果该棋局及其状态子树已经完全搜索，则会存储该棋局的精确结果。

如果该棋局及其状态子树还没有完成搜索，则会存储已经完成的搜索窗口，使用“α-β”剪枝的搜索算法通常有三种不同类型的评估值，分别是精确值、α 值和 β
值。精确值，顾名思义，就是搜索得到的评估结果落在区间 [α, β]
之内，将评估结果视为精确值；如果状态子树的所有子节点没有找到比当前极大值更好的结果，则将评估结果视为 α
值；如果状态子树的所有子节点没有找到比当前极小值更差的结果，则将评估结果视为 β 值。

搜索深度也是置换表中的一个重要属性，它决定了对这个表项的使用和更新方式。假如要对一个棋局进行 n 层深度的搜索，如果置换表中存在一个搜索深度是 m，且 m
>= n 的表项，则说明这个棋局的搜索结果可以直接使用，无需对该棋局再做完整的搜索。

根据以上分析，置换表的表项可以用以下数据模型定义：

    
    
    typedef struct 
    {
        int flag;
        int depth;
        int value;
    }TT_ENTRY;
    
    static std::map<unsigned int, TT_ENTRY> tt_map;
    

flag 是标志位，表示这个结果是精确值（TT_FLAG_EXACT）、α 值（TT_FLAG_LOWERBOUND）或 β
值（TT_FLAG_UPPERBOUND），depth 是评估结果的搜索深度，value 是评估值。为了简单演示一下置换表的用法，我直接用了
std::map，如果对内存没有要求，并且编译器支持 C++ 11 的话可以直接用 std::unordered_map。

std::unordered_map 就是哈希表（为啥不是传说中的 std::hash_map？说来话长了），查找的时间复杂度接近
O(1)，很多棋类游戏其实也是直接用各种自定义的哈希表。

LookupTranspositionTable() 函数是置换表的查表接口，根据一个棋局的 hash 值，得到这个棋局的评估结果。

    
    
    bool LookupTranspositionTable(unsigned int hash, TT_ENTRY& ttEntry)
    {
        std::map<unsigned int, TT_ENTRY>::iterator it = tt_map.find(hash);
        if(it != tt_map.end())
        {
            ttEntry = it->second;
            return true;
        }
    
        return false;
    }
    

置换表的替换原则也称覆盖策略，就是同一个棋局（棋局的哈希值相同）如果有了更新的搜索结果，以何种方式更新置换表中的表项。对于单一的置换表算法，其替换原则一般有两种，一种是深度优先替换（Deeper
Priority），一种是始终（随时）替换（Always Replace）。

深度优先替换原则执行的是“同样的搜索深度或更深时替换”的策略，也就是说，只有新棋局的搜索深度大于或等于置换表中已经存在的值时，才更新置换表中的值。深度优先策略只考虑搜索的深度，没有考虑棋局演化出的新棋局信息对后续演化的影响，置换表容易被已经过时的、但搜索深度很深的棋局占满，无法保证棋局评估结果的实时性，同时也降低了置换表的搜索效率。

始终替换原则就是不考虑其他情况，如果置换表中存在搜索过的棋局，始终用新的搜索结果替换已经存在的结果。始终替换策略总是用新的结果代替旧的结果，能保证棋局评估结果的实时性，但是容易丢掉搜索层数较深的棋局评估结果，而搜索深度越深，往往意味着更优的评估值（对很多搜索算法而言，结果往往是这样的）。

StoreTranspositionTable()
是存储或更新置换表的接口，采用的是深度优先替换原则。如果棋局不存在，就将当前结果存入置换表；如果棋局已经存在一个评估值，那么就比较一下新结果的搜索深度和原有结果的搜索深度；如果新结果的搜索深度超过原有结果的搜索深度，则进行替换。

    
    
    void StoreTranspositionTable(unsigned int hash, TT_ENTRY& ttEntry)
    {
        std::map<unsigned int, TT_ENTRY>::iterator it = tt_map.find(hash);
        if(it != tt_map.end())
        {
            TT_ENTRY& old_entry = it->second;
            if(ttEntry.depth > old_entry.depth)
            {
                old_entry = ttEntry;
            }
        }
        else
        {
            tt_map[hash] = ttEntry;
        }
    }
    

置换表的使用大概是这样的模式：在搜索过程中，先尝试查表，如果能查到结果的精确值，就直接返回结果，如果查到的不是精确值，就根据 flag
的标志，更新本次搜索的区间 [α, β]。搜索结束后，还需要将搜索结果更新到置换表中，更新的原则如下面代码片段所示：

    
    
    int NegamaxAlphaBetaSearcher::NegaMax(GameState& state, int depth, int alpha, int beta, int max_player_id)
    {
        unsigned int state_hash = state.GetZobristHash();
    
        //查询置换表，更新 [alpha, beta] 起始区间
        TT_ENTRY ttEntry = { 0 };
        if(LookupTranspositionTable(state_hash, ttEntry) && (ttEntry.depth >= depth))
        {
            if(ttEntry.flag == TT_FLAG_EXACT)
                return ttEntry.value;
            else if(ttEntry.flag == TT_FLAG_LOWERBOUND)
                alpha = std::max(alpha, ttEntry.value);
            else// if(ttEntry.flag == TT_FLAG_UPPERBOUND)
                beta = std::min(beta, ttEntry.value);
    
            if(beta <= alpha)
                return ttEntry.value;
        }
    
        .... //正常的搜索过程，得到评估值 score
    
        //更新置换表
        ttEntry.value = score;
        if(score <= alpha)
            ttEntry.flag = TT_FLAG_UPPERBOUND;
        else if(score >= beta)
            ttEntry.flag = TT_FLAG_LOWERBOUND;
        else
            ttEntry.flag = TT_FLAG_EXACT;
    
        ttEntry.depth = depth;
        StoreTranspositionTable(state_hash, ttEntry);
    
        .......
    

#### 棋局数据库

置换表的另一个用途是使用开局库和终局库，俗话说：“好的开始是成功的一半。”棋类游戏的开局尤其如此，如果能在开局阶段占据先机，对整个棋局的发展都是非常有利的。终局又称残局，是棋类游戏中决定胜负的最后阶段，也是棋类游戏中非常重要的一个阶段。但是很多棋类游戏在开局和终局阶段棋盘上的棋子很少，棋类游戏
AI
的搜索算法在面对空荡荡的棋盘时，常用的启发手段基本上失效，搜索算法退化为普通的穷举搜索，很多落子位置最终的评估结果都是一样的，搜索算法变得“不知所措”，也正是这个原因导致许多棋类游戏的
AI 算法在开局阶段或终局阶段常常走出令人匪夷所思的“昏招”。

针对这种情况，很多棋类游戏的算法都会使用开局库和终局库，在开局和终局阶段，直接从库中搜索已知的开局和残局走法，借鉴各种经典的和成熟的开局走法，利用前人对弈的智慧度过这个阶段。到进入中局时，棋盘上的棋子比较多，在搜索过程中可以利用各种启发式搜索获取千变万化的棋局的评估结果时再使用搜索算法。

开局库和终局库实际上就是一种存储了各种开局和终局棋局信息的数据库，基本查找原则和置换表一样，只是开局库和终局库一般是专用的软件，根据大量的对局棋谱抽取出来的经验数据库，并不需要根据搜索结果更新这个数据库。开局库一般要存储开局的棋局，该棋局对应的各种走法和评估分数，有些开局库还统计了该开局最终的胜局次数、平局次数和负局次数，给出开局棋局的权重等附加信息供搜索时选择。

终局决定了一盘棋的胜负，终局中也有很多规律和定势，许多棋类游戏算法也会使用终局库，以便在终局阶段借鉴一些经典的走法。相对于局面简单的开局库，终局库棋子没有固定的位置，走法更为多样化，棋局的变化更无常。因此终局库的规模常常是开局库的几百或几万倍，检索时间比较长，效率比较低，需要根据实际需要酌情使用。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

