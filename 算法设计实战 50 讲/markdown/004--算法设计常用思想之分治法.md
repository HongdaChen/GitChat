上一篇中介绍了算法模式中的贪婪法，现在我们继续介绍分治法。分治，顾名思义，分而治之。分治法（Divide and
Conquer）也是一种解决问题的常用模式，分治法的设计思想是将无法着手解决的大问题分解成一系列规模较小的相同问题，然后逐个解决小问题，即所谓分而治之。分治法产生的子问题与原始问题相同，只是规模减小，反复使用分治方法，可以使得子问题的规模不断减小，直到能够被直接求解为止。

### 分治法的基本思想

分治法作为算法设计中一个古老的策略，在很多问题中得到了广泛的应用，比如最轻、最重问题（在一堆形状相同的物品中找出最重或最轻的那一个），矩阵乘法、大整数乘法以及排序（例如，快速排序和归并排序）。除此之外，这个技巧也是许多高效算法的基础，比如快速傅立叶变换算法和
Karatsuba 乘法算法。

应用分治法，一般出于两个目的，其一是通过分解问题，使得无法着手解决的大问题变成容易解决的小问题，其二是通过减小问题的规模，降低解决问题的复杂度（或计算量）。给
1000 个数排序，可能会因为问题的规模太大而无从下手，但是如果减小这个问题的规模，将问题一分为二，变成分别对两个拥有 500
个数的序列排序，然后再将两个排序后的序列合并成一个就得到了 1000 个数的排序结果。对 500 个数排序仍然无法下手，需要继续分解，直到最后问题的规模变成
2 个数排序的时候，只需要一次比较就可以确定顺序。

这正是快速排序的实现思想，通过减小问题的规模使问题由难以解决变得容易解决。计算 N 个采样点的离散傅立叶变换，需要做 N2 次复数乘法，但是将其分解成两个
N/2 个采样点的离散傅立叶变换，则只需要做 (N/2)2 +(N/2)2 = N2/2
次复数乘法，做一次分解就使得计算量减少了一半，这正是快速傅立叶变换（FFT）的实现思想，通过减小问题的规模来减少计算量，以降低问题的复杂度。

在很多情况下，分治法都会使用递归的方式对问题逐级分解，但是在每个子问题的层面上，分治法基本上可以归纳为三个步骤。

  * **分解** ：将问题分解为若干个规模较小，相互独立且与原问题形式相同的子问题，确保各个子问题的解具有相同的子结构。
  * **解决** ：如果上一步分解得到的子问题可以解决，则解决这些子问题，否则，对每个子问题使用和上一步相同的方法再次分解，然后求解分解后的子问题，这个过程可能是一个递归的过程。
  * **合并** ：将上一步解决的各个子问题的解通过某种规则合并起来，得到原问题的解。

分治法的实现模式可以是递归方式，也可以是非递归方式，一般采用递归方式的算法模式可以用伪代码描述为：

    
    
    T DivideAndConquer(P)
    {
        if(P 可以直接解决)
        {
            T <- P 的结果;
            return T;
        }
    
        将 P 分解为子问题{P1, P2,..., Pn};
        for_each(Pi : {P1, P2,..., Pn})
        {
            ti <- DivideAndConquer(Pi); //递归解决子问题 Pi
        }
        T <- Merge(t1, t2,...,tn); //合并子问题的解
    
        return T;
    }
    

能使用分治法解决的问题一般都具有两个显著的特点，第一个特点是问题可以分解为若干个规模较小的相同问题，并且这个分解关系可以用递归或递推的方式逐级分解，直到问题的规模小到可以直接求解的程度。这里说的相同问题，并不是说分解后的子问题与原问题完全一样，这里说的相同只是问题的结构相同，比如原问题有四个属性，分解后规模较小的子问题也应该具有四个相同的属性，不同的只是各个属性的范围和规模。第二个特点是子问题的解可以用某种方式合并出原始问题的解。这很容易理解，如果不能合并出原始问题的解，那么子问题的划分和求解就没有意义了。

分治法的难点是如何将子问题分解，并且将子问题的解合并出原始问题的解，针对不同的问题，通常有不同的分解与合并方式。先来看看快速排序算法，快速排序算法的分解思想是选择一个标兵数，将待排序的序列分成两个子序列，其中一个子序列中的数都小于标兵数，另一个子序列中的数都大于标兵数，然后分别对这两个子序列排序，其合并思想就是将两个已经排序的子序列一前一后拼接在标兵数前后，组成一个完整的有序序列。再来看看快速傅立叶变换，快速傅立叶变换的分解思想是将一个
N 点离散傅立叶变换，按照奇偶关系分成两个 N/2 点离散傅立叶变换，其合并思想就是将两个 N/2 点离散傅立叶变换结果按照蝶形运算的位置关系重新排列成一个
N 点序列。

最后再介绍一下 Karatsuba 大整数乘法算法，其分解思想是将两个参与计算的 n 位大数各自分成两部分：a + b 和 c + d，其中，a 和 c
分别是这两个大整数的整数幂部分，b 和 d 分别是它们的剩余部分，然后利用乘法的分解公式：(a + b)(c + d) = ac + ad + bc +
bd，将其分解为四次小规模大数的乘法计算，并且利用一个小技巧将其化解成三次乘法和少量移位操作。最终结果的合并思想就是用几次加法对小规模乘法的结果进行求和，得到原始问题的解。

以上两个例子的具体原理和实现在《算法的乐趣》一书中都有详细的介绍，有兴趣的读者可以了解一下。

由以上的例子可知，分治法最难也最灵活的部分就是对问题的分解和结果的合并，对于一个未知的问题，只要能找到对子问题的分解方式和结果的合并方式，应用分治法就可以迎刃而解。而在数学上，只要能用数学归纳法证明的问题，一般也都可以应用分治法解决，这也是一个应用分治法的强烈信号。

### 递归实现和分治法

递归作为一种算法的实现方式，与分治法是一对儿天然的好朋友。为什么这么说呢？因为问题的分解肯定不是一步到位，往往需要反复使用分治手段，在多个层次上层层分解，这种分解的方法很自然地导致了递归方式的使用。从算法实现的角度看，分治法得到的子问题和原问题是相同的，当然可以用相同的函数来解决，区别只在于问题的规模和范围不同。通过特定的函数参数安排，使得同一个函数可以解决不同规模的相同问题，这就是递归方法的基础。

以快速排序为例，如果把待排序的序列作为问题的话，那么子问题的规模就可以定义为子序列在原始序列中的起始位置。对此一般化之后，原始问题和子问题的描述就统一了，都是原始序列
+ 起始位置，原始问题的起始位置就是 [1,n]，子问题的起始位置就是 [1,n] 中的某一个子区间，由此一来，递归的接口就明确了：

    
    
    void quick_sort(int *arElem, int p, int r)
    

其中，p 和 r 就分别是子序列在 arElem 中的起始位置，有了子问题的递归定义接口，快速排序的算法实现也就水到渠成了：

    
    
    void quick_sort(int *arElem, int p, int r)
    {
      if(p < r)
      {
        int mid = partion(arElem, p, r);
        quick_sort(arElem, p, mid - 1);
        quick_sort(arElem, mid + 1, r);
      }
    }
    
    int intArray[] = {12, 56, 22, 78, 102, 6, 90, 57, 29};
    quick_sort(0, 8); //原始问题：对数组中的1-9号元素排序
    

不用递归是不是就不能用分治法了？当然不是，快速傅立叶变换算法就没有用递归。很多算法都有自己的非递归实现方式，是否用了递归方法不是判断是不是分治法的必要条件。即便是一些使用了递归方法的算法，也都可以用一个自己构造的栈将其改编为非递归方法，比如快速排序就有很多用栈实现的非递归方法。Robert
Sedgewick 在其著作《算法：C语言实现》一书中就给出了一种快速排序的非递归高效算法，有兴趣的读者可阅读此书，了解一下算法实现。

### 分治法的例子：字符串全排列问题

我们的问题是：给定一个没有重复字母的字符串，输出该字符串中字符的所有排列。假如给定的字符串是“abc”，则应该输出“abc”、“acb”、“bac”、“bca”、“cab”和“cba”六种结果。首先分析这是一个全排列问题，解决这个问题我们的常用策略是每次选择固定一个字符，然后对剩下的两个字符进行排列。比如这个三个字母的字符串，我们首先选择固定
a，然后对 bc 进行排列，可以得到“abc”和“acb”两个结果；然后选择固定 b，对 ac
进行排列，可以得到“bac”和“bca”两个结果；最后选择固定 c，对 ab 排列，可以得到“cab”和“cba”两个结果。

不知道大家有没有意识到，这其实就是使用了分治法的思想在解决问题。三个字符排列，我们人脑可能处理不过来，但是我们固定一个字母后，把问题的规模减小为两个字符的排列，两个字符的排列只有两种结果，是可以解决的问题；然后我们将小问题的结果与固定的字母组合在一起，就可以得到原始问题，即三个字符的排列结果。分治法分解子问题，并不是一定要用某种方式均匀分解原始问题，哪怕是每次只能将原始问题的规模变小一点，也是一种分解子问题的方法。

回到我们这个问题上，对字符串类问题分解子问题，通常考虑的方法有两个。

  * 一个方法是用字符串的开始位置和字符串的长度表示一个子字符串，对于一个长度为 n 的字符串，用这种方法定义的子问题就是“从位置 i 开始，长度为 m 的字符串，其中，$1 \leqslant i < n$，$0 < m \leqslant n$”，原始问题就是从位置 1 开始，长度为 n 的字符串。
  * 另一个方法是用字符串的位置区间来表示一个子字符串，同样对于一个长度为 n 的字符串，用这种方法定义的子问题就是“从位置 i 开始，到位置 j 结束的字符串，其中，$1 \leqslant i < n, i \leqslant j \leqslant n$”，原始问题就是从位置 1 开始到位置 n 结束的字符串。考虑到很多编程语言中索引位置都是从 0 开始，上述描述中的索引位置要做 -1 修正，读者应该能够理解，接下来的例子用 C++ 实现算法，就会体现这一点。

对于这个问题，我们选择用区间的方法定义子问题，即用字符位置索引区间 [begin, end]
表示子问题，选好子问题的表达方式，接下来就要考虑如何分解子问题。根据之前的分析，我们采用每次固定一个字符，然后将剩下的字符串作为一个子问题进行全排列的方式分解子问题。因为每个字符都要被“固定”一次，所以算法实现的方法是用一个循环对子问题
[begin, end] 区间上的每个字符都选择一次。

因为大多数编程语言都没有提供直接的方法能够将一个字符固定，同时将剩下的内容重组为一个连续的字符串，所以很显然，这里面就会有一个实现上的困难需要克服，即如何选中一个字符固定，还要让剩下的字符保持连续，成为子问题所描述的字符串。我们采用的方法是将问题区间
[begin, end] 中的 begin 位置作为选中的固定字符位置，将除了这个位置之外的问题区间 [begin+1, end]
作为子问题进一步处理。如果被选中的固定字符不在 begin 位置，则交换两个字符的位置，使得被选中的固定字符位于 begin 位置。

解决了子问题的分解，接下来要考虑子问题的求解。分解的目的是为了减小问题的规模，直到问题能够求解，对于这个字符串排列问题，当子问题的规模减小到只有一个字符的时候，子问题就可以求解了。因为我们处理方式是从前向后，每次固定
begin 位置的字符，然后将区间 [begin+1, end] 作为子问题进一步处理，所以当 begin 位置和 end
位置相同的时候，就说明字符串只有一个字符了，这时就不需要再分解子问题了。

因为这个问题的特点，它不需要显式求解子问题，只需在子问题变成只有一个字符的字符串时输出这个字符串即可，并且因为之前分解子问题的时候，每个位置都已经固定好字符，所以当
begin 位置和 end 位置相同的时候，就实际得到了一个全排列结果。

算法实现的主体就是一个可递归调用的 Permutation() 函数，Permutation() 函数解决字符串 chList 中从 begin 位置开始到
end 位置结束的字符串的全排列问题，要求解原始问题，只需将 begin 设置成 0，将 end 设置成字符串长度 -1 即可（字符串长度 -1
就是字符串最后一个字符的索引位置）。递归展现出了无与伦比的优雅，最后的算法实现只要十几行代码就搞定了。

    
    
    void Swap(std::string& chList, int pos1, int pos2)
    {
        if (pos1 != pos2)
        {
            auto tmp = chList[pos1]; 
            chList[pos1] = chList[pos2];
            chList[pos2] = tmp;
        }
    }
    
    //将字符串[begin, end]区间的子串全排列
    void Permutation(std::string& chList, int begin, int end)
    {
        if (begin == end)//就剩一个字符了，不需要排列了，直接输出当前的结果
        {
            std::cout << chList << std::endl;
        }
    
        for (int i = begin; i <= end; i++)
        {
            Swap(chList, begin, i); //把第 i 个字符换到 begin 位置，将 begin+1 位置看作新的子串开始
            Permutation(chList, begin + 1, end); //求解子问题
            Swap(chList, begin, i); //在挑选下一个固定字符之前，需要换回来
        }
    }
    
    //求解问题字符串：abcd
        std::string cl = "abcd";
        Permutation(cl, 0, cl.length()); //原始问题的规模是从 0 位置开始的整个字符串
    

### 总结

分治法有很多典型的应用，比如二分查找、Karatsuba
大整数乘法、棋盘覆盖问题、快速排序、合并排序，等等，大家可以找来相关的算法实现研究一下，看看各种情况下分解子问题和合并子问题的解的方法。我记得前几年有个很火的网文，说是
90% 的程序员写不出完全正确的二分查找算法，那么本节课的问题就是，用你熟悉的编程语言实现一个二分查找算法，完成这个作业，你就是那 10% 了。

### 答疑与交流

为了方便与作者交流与学习，GitChat 编辑团队组织了一个专栏读者交流群，添加小助手-
伽利略微信：「GitChatty6」，回复关键字「259」给小助手伽利略获取入群资格。

![avatar](https://images.gitbook.cn/FsONnMw_1O_6pkv-U-ji0U1injRm)

