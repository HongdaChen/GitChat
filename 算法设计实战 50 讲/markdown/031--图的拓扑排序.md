>
> 拓扑排序常用来确定一个依赖关系集中事物发生的顺序。一个典型的应用场景就是在项目管理或工程实施中安排各种生产活动的计划，在考虑各种活动的依赖关系的基础上，安排各种活动的开始时间，使得项目或工程能够以高效合理的速度完成。这些功能通常需要在基本的拓扑排序算法基础上进行适当的改造，本课仿照的项目管理软件功能实现的“根据活动开始时间排序”算法，就是一种这样的改造。图的拓扑排序涉及的概念有：有向无环图（Directed
> Acyclic Graph，DAG）、AOV 网、顶点的出度和入度等。在学习这一课的内容之前，希望大家对这些概念能有一些了解。好了，废话不多说，开始吧。

### 拓扑排序（Topological Sorting）

对有向无环图进行拓扑排序，是图论算法中的一个重要算法，它不仅是各种算法题目中常见的内容，在现实生活中也得到了广泛的应用，比如各种项目管理软件中的“按照开始时间排序”功能，其背后的算法支撑就是拓扑排序。这一课，我们用一个简化的工程活动安排这个题目为例，介绍一下拓扑排序算法的应用。

假如某工程分解后得到 P1 ~ P9 共 9 个活动，这些活动需要的时间和它们之间的依赖关系如下表所示：

**活动名称** | 活动时间（天） | 前置依赖  
---|---|---  
P1 | 8 |  
P2 | 5 |  
P3 | 6 | P1、P2  
P4 | 4 | P3  
P5 | 7 | P2  
P6 | 7 | P4、P5  
P7 | 4 | P1  
P8 | 3 | P7  
P9 | 4 | P4、P8  
  
一个活动的前置依赖，表示这个活动需要在前置依赖的活动完成后才能开始。请根据上述条件，拟定一个工程活动的开始顺序，合理安排它们的开始时间，使得各项活动能够有序进行。

#### 拓扑序列和拓扑排序

在图论中，一个有向无环图 G(V, E)
的所有顶点可以排成一个线性序列，当这个线性序列满足以下条件时，称该序列为一个满足图的拓扑次序（Topological Order）的序列：

  * 图中的每个顶点在序列中只出现一次；
  * 对于图中任意一条有向边 (u, v) ∈ E，在该序列中顶点 u 一定位于顶点 v 之前。

这样的序列也被称为拓扑序列，对有向图的所有顶点排序，获得拓扑序列的过程就是有向图的拓扑排序。

实际上，拓扑排序作为一种利用数据元素中某个属性的偏序关系得到数据元素的全排序序列的方法，不仅仅用于有向图的排序，还可以用在很多其他场合，但是这一课，我们只介绍有向图的拓扑排序。根据题目给出的互动开始时间信息，可以得到一个活动的开始次序：P1、P2、P5、P3、P7、P8、P4、P6、P9，这个序列就是用拓扑排序（按照开始时间的偏序）得到的一个拓扑序列。很多情况下，拓扑序列并不是唯一的，以本题为例，P1、P2、P5、P7、P3、P8、P4、P6、P9
也是一个合法的拓扑序列。

#### DAG 和 AOV 网

图的主要元素是顶点和边，用有向无环图表示工程活动之间的关系时，根据顶点和边所代表的意义不同，通常有两种常见的表示方法，分别是 AOV 网和 AOE
网。如果图中顶点代表的是活动，有向边代表的是与此边相连的两个活动的前后关系，则这样的有向无环图就被称为“顶点表示活动网（Activity On Vertex
Network）”，简称 AOV 网，AOV 网常用于通过拓扑排序决定活动开始关系。图（1）就是上述 P1 ~ P9 这几个活动的 AOV 网示意图：

![](https://images.gitbook.cn/03ba49d0-f12e-11e8-aa74-1b3a5fb75d2e)

图（1）本题的无向图用 AOV 网的表示

图中的 st 就是各个活动对应的开始时间，可以看出来，P5 活动在 P2 活动结束之后就可以开始了，P2 需要 5 天时间才能完成，因此 P5
的开始时间就是 P2 开始的 5 天之后；对于 P3 活动来说，它需要 P1 和 P2 都完成后才能开始，因此它的开始时间是 P1 和 P2 开始之后的第
8 天。这样，从活动时间上安排，P5 可以在 P3 之前开始。

#### 拓扑排序的基本步骤

对有向图进行拓扑排序可以得到顶点的拓扑序列，拓扑排序的基本过程如下：

  1. 初始化有向图；
  2. 将有向图中没有前驱（入度为 0）的顶点压入栈中；
  3. 将栈顶元素出栈，输出该节点，并遍历其所有邻接顶点，将每个邻接顶点的入度减 1（相当于删除该顶点发出的所有有向边），如果某个邻接顶点的入度被减为 0，那么将该邻接顶点入栈；
  4. 重复步骤3，直到栈为空。

按照上述处理步骤，第3步顺序输出的顶点序列就是一个拓扑序列。如果计算完成后，图中还有未输出的顶点，但是入度都不为
0，则说明有向图中存在环路，不能进行拓扑排序。

### 拓扑排序算法应用实例

对有向图的拓扑排序有什么实际意义呢？在项目管理过程中，人们总是希望每个活动尽早开始，对一个项目的所有生产活动进行拓扑排序时，如果能将活动的最早开始时间考虑进来，得到一个各项活动按照最早开始时间排序的拓扑序列，对工程实施具有非常大的实用性。Project
软件中的“按照开始时间排序”就是满足这种需求的一个功能，这一课，我们也仿照 Project 软件实现一个按照开始时间对活动进行拓扑排序的算法。

上一课给出的图的拓扑排序算法是标准的拓扑排序，排序的依据是各顶点的依赖关系，能保证“图中任意一条有向边 (u, v) ∈ E，在该序列中顶点 u
一定位于顶点 v 之前”的要求，但是不能保证开始时间尽量早的要求。按照标准的拓扑排序步骤，活动 P3、P5 和 P7 只要保证在 P1 和 P2
之后，并且在 P8 之前就算满足条件的拓扑序列。但是根据图（1）计算好的开始时间，活动 P5 应该在 P3 和 P7
之前才是满足我们“按照开始时间排序”的拓扑序列。

为了实现这个功能，我们对算法过程中用到的数据结构进行改造，将标准过程中的栈改造成按照开始时间排序的带优先级的队列。带优先级的队列能够保证顶点入栈时根据开始时间的顺序插入到队列中适当的位置上，出栈时总是开始时间最早的顶点先出栈（被处理），这样就达到了既满足拓扑序列的条件，又按照开始时间有序的目的。很多编程语言都支持带优先级的队列，C++
是 std::priority_queue，用 std::priority_queue 组织的入栈和出栈操作可做如下实现：

    
    
    struct QUEUE_ITEM
    {
        int node;    //图的顶点编号
        int sTime;   //顶点代表的活动开始时间
        bool operator < (const QUEUE_ITEM &a) const
        {
            return sTime > a.sTime;  //最小值优先     
        }
    };
    
    void EnQueue(std::priority_queue<QUEUE_ITEM>& q, int node, int sTime)
    {
        QUEUE_ITEM item = { node, sTime };
        q.push(item); //入队列
    }
    
    int DeQueue(std::priority_queue<QUEUE_ITEM>& q)
    {
        int node = q.top().node;   //访问队首元素
        q.pop();  //出队列
        return node;
    }
    

QUEUE_ITEM 是队列元素数据类型，按照 STL 的习惯提供了“小于”比较算子，std::priority_queue
会在元素入队的时候调用其对应的“小于”比较算子，对队列中的元素进行排序。

#### 图的数据模型

前面介绍了 AOV 网，其实是暗示我们将会使用邻接表的方式表示本算法用到的图。邻接表突出的是图中顶点的关系，更适合 AOV
网的气质。首先定义顶点，根据题目的描述，顶点包含以下内容：

    
    
    typedef struct 
    {
        char *name;   //活动名称
        int days;       //完成活动所需时间
        int sTime;    //活动最早开始时间
        int inDeg;    //活动的前驱节点个数(入度)
        std::vector<int> adjNode; //相邻活动列表（节点索引）
    }VERTEX_NODE;
    

  * name 不是必须的，仅仅是为了输出信息更有意思一点，如果你遇到的题目有这样的要求，可以替换成对应的活动名称。
  * days 是活动需要的时间，也不是必须的内容，但是如果你想完成本课最后的题目，这个时间就是必须的。
  * inDeg 是活动的前置活动个数，表现在图的形式上就是顶点的入度。
  * adjNode 是相邻活动列表，记录相邻活动的顶点对应的编号，邻接表中顶点的关系不一定要用链表串联，我们用的就是可变长数组（std::vector）。

顶点的编号依然是常用的从 0 开始编号，这样可以借助数组下标的技巧，这里不再啰嗦。TP_GRAPH
数据结构是用邻接表形式定义的图，根据这个数据模型定义，上面给出的活动数据的存储结构，如图（2）所示。

    
    
    typedef struct 
    {
        int count;   //图的顶点个数
        VERTEX_NODE vertexs[MAX_VERTEXNODE];   //图的顶点列表
    }TP_GRAPH;
    

![](https://images.gitbook.cn/1522ec40-f12e-11e8-aa74-1b3a5fb75d2e)

图（2）用邻接表表示的图的存储结构

#### 计算开始时间

项目中每个活动的开始时间受前置活动的约束，不可能随时开始，但是活动的开始时间可以根据前置活动之间的关系推算出来，具体推算的方法如下：

  * 如果一个活动没有前驱活动，则这个活动的开始时间是 0；
  * 如果一个活动有前驱活动，则这个活动的开始时间是前驱活动的开始时间与前驱活动持续时间的和；
  * 如果一个活动有多个前驱活动，则这个活动的开始时间是这些和中最大的一个。

以上面给出的活动为例：

  * P1 和 P2 没有前驱活动，其开始时间 st=0；
  * P7 的开始时间是 P1 的开始时间与 P1 的持续时间之和，即 P7 的开始时间 st=8；
  * P3 的开始时间受制于 P1 和 P2，其开始时间是 max(8+0, 5+0)，即 P3 的开始时间 st=8。

最终我们人肉算出了每个活动的开始时间，如图（1）所示，现在就基于这个开始时间对这些活动进行拓扑排序。

#### 算法实现

有向图的拓扑排序算法真的很简单，没有递归，也没有复杂的调用关系。基本上就是按照“拓扑排序的基本步骤”内容描述的过程，结合优先级队列的方法实现了
TopologicalSorting() 函数。排序的顶点存储在 sortedNode 数组中，可以用简单的输出函数打印最后的结果。最后的
`(sortedNode.size() == g->count)` 判断这个图是否有环，如果有环的话是没有合法的拓扑序列的。

    
    
    bool TopologicalSorting(TP_GRAPH *g, std::vector<int>& sortedNode)
    {
        std::priority_queue<QUEUE_ITEM> nodeQueue;
    
        //第一步：所有入度为 0 的顶点入队（栈）
        for (int i = 0; i < g->count; i++)
        {
            if (g->vertexs[i].inDeg == 0)
            {
                EnQueue(nodeQueue, i, g->vertexs[i].sTime);
            }
        }
        //第二步：队列（栈）顶元素处理
        while (nodeQueue.size() != 0)
        {
            int node = DeQueue(nodeQueue);   //按照开始时间优先级出队（栈）
            sortedNode.push_back(node);   //输出当前节点，按照顺序排入 sortedNode 数组中
    
            //遍历节点 node 的所有邻接点，将表示有向边 inDeg 值减 1
            for (int adjNode : g->vertexs[node].adjNode)
            {
                g->vertexs[adjNode].inDeg--;
                //如果 inDeg 值为 0，则该节点入队列（栈）
                if (g->vertexs[adjNode].inDeg == 0)
                {
                    EnQueue(nodeQueue, adjNode, g->vertexs[adjNode].sTime);
                }
            }
        }
    
        return (sortedNode.size() == g->count);
    }
    

### 总结

有向图的拓扑排序在工程管理和项目管理方面应用广泛，各种项目管理的“按照时间排序”和“按照活动顺序排序”功能，背后都是拓扑排序算法。有向图的拓扑排序算法原理简单，实现也简单，但是要实现一些有特殊要求的拓扑排序，还是需要构造特殊的数据模型，并对标准算法实现过程做适当的修改。本课实现的“根据活动开始时间排序”算法，就是引用了带优先级的双向队列代替了标准算法中的栈。

有向图的拓扑排序基本上不会单独出题，但是常常作为其他题目中的一个步骤出现，建议读者常备拓扑排序算法模板的同时，还要能够弄懂拓扑排序的基本原理，根据题目要求随时修改，以不变应万变。

本课的题目是：在本课给出的数据模型定义基础上，实现一个推算活动最早开始时间的算法，自动计算出每个活动的最早开始时间。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

