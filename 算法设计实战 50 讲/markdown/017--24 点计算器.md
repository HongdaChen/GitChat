> 24 点游戏是一个很有意思的数字游戏，也是一道常见的算法面试题。题目是这样的：任给四个数（为了便于人们心算或口算，一般都是小于 10
> 的数），对四个数字用各种组合进行加、减、乘、除四则运算，看看结果是否能等于
> 24？对于面试题来说，这是一个典型的穷举类型算法问题。这个题目比较有意思的地方是它除了要对数字组合进行枚举，还要对四个运算符进行组合。这一课我们要介绍的方法有点特殊，它没有简单地使用穷举遍历，而是采用穷举法和分治法相结合的方法来解决这个问题，这种方法比数字
> + 运算符一起枚举的方法简单，容易理解，整个算法只有大约 40 行有效代码，其中主体部分有效代码只有不到 20 行，快来看看是怎么回事儿吧。

### 问题分析与建模

这个算法问题的难点主要有两个，一个是数字和运算符的穷举遍历，另一个是将四则运算表达式作为结果输出。无论是运算符遍历还是表达式输出，都要考虑运算符的优先级，必要时要加括号。当然，也可以采用后缀表达式的形式，避免在枚举遍历的过程中考虑括号的问题。一般我们书写和计算都采用中缀表达式，中缀表达式的特点是运算符始终位于两个操作数的中间，对于运算符的优先级采用括号的方式解决，比如以下四则运算采用的就是中缀表达式的形式：

7 + ( 3 + 2 ) × 4 − 8

后缀表达式又称为“逆波兰表达式”，上述中缀表达式转换成后缀表达式后就是这个样子：

732 + 4 × + 8 −

后缀表达式通过运算符的位置来决定计算顺序，避免使用括号，便于计算机计算处理。后缀表达式的求解计算一般用栈比较方便，具体的方法就是从左向右扫描表达式，当遇到操作数时就将操作数入栈；当遇到操作符时就从栈中弹出两个操作数，将操作数与这个运算符一起计算得到一个结果，并将这个结果入栈，然后继续扫描表达式，直到结束。后缀表达式的计算以及将中缀表达式转变成后缀表达式也都是经典数据结构课程的算法，这一课我们就不具体介绍了。大家如果感兴趣可以在读者圈中留言，我们后面可以安排补充一篇关于后缀表达式的内容。

引言部分提到过，我们这个方法会用到分治法，分治法的主要特点之一就是通过分解子问题的方式减小问题的规模，怎么划分子问题呢？复习一下前面讲过的内容，子问题和原始问题必须是同构的，所谓同构就是问题必须是一样的，问题的模式不能变，能变的只是问题的规模。对于这个问题来说，原始问题的规模是
4 个数字计算 24 点，那么分解子问题可以从两个方向考虑：一种是只考虑减少问题的规模，对于这个问题来说，减少规模不就是变成 3 个数字计算 24
点吗？然后再减少为两个数字计算 24
点，以此类推，直到问题能够直接求解为止；另一种是在减少问题规模的同时，调整结果的范围，同样，对这个问题来说，假如说我将问题规模从 4 个变成 3
个，被排除的数字是 3，那么子问题就应该变成“3 个数字计算 21 点”。进一步将问题规模减少成两个数字时，假如被排除的数字是 7，则子问题就变成“2
个数字计算 14 点”，以此类推，直到问题能直接解决为止。

本课我们尝试采用第一种方法来分解子问题。我们的思路是每次从 4 个数字中任选两个，分别应用加、减、乘、除四种运算方法得到 4
个计算结果，每个计算结果与剩下的 2 个数字一起组成一个规模为 3 个数字的子问题，一共可以得到 4 个子问题，其变化过程如图（1）所示（图中第一行的数字为
4 个数字的索引位置，第二行的数字分别是 4 个待计算数字，第三行是计算过程），使用第一个数字和第二个数字组合计算，得到了一组 4
个子问题，然后用第一个数字和第三个数字组合计算，得到了另一组 4 个子问题：

![enter image description
here](https://images.gitbook.cn/c5b9bc80-cc64-11e8-b2d5-0748641b7f61)

图（1）第一层组合计算将问题规模减小到 3 个数字

根据组合规则，从 4 个数字中选两个进行不能有重复的排列，可以得到 $P_{4}^{2} = 12$ 个组合结果，也就是说总共有 12 × 4 = 48
个规模为 3 个数字的子问题，图（1）展示了其中的两组。接下来，我们选择图（1）中紫色标识的那个子问题，再进一步应用上述思想减小问题的规模。

从 3 个数字中任选两个，然后应用加、减、乘、除四种运算方法得到 4 个计算结果，每个计算结果与剩下的 1 个数字组成一个规模为两个数字的子问题，又可以得到
4 个子问题。从 3 个数字中任选两个进行不重复的排列，可以得到 $P_{3}^{2} = 6$ 个组合结果，也就是说总共有 6 × 4 = 24
个规模为两个数字的子问题，图（2）展示了其中一组，也就是第一个数 3/7 和第二个数 3 的组合情况：

![enter image description
here](https://images.gitbook.cn/2703be00-cc65-11e8-945d-85bdd822989f)

图（2）第二层组合计算将问题规模减小到两个数字

3/7 和 3 经过加、减、乘、除得到了 4 个结果，分别是 24/7、−18/7、9/7 和 1/7，将它们与剩下的数字 7 组合，得到了图（2）所示的
4 个子问题。接下来，我们选择图（2）中黄色标识的子问题，再进一步应用上述思想减小问题的规模。

从两个数字中任选两个，然后应用加、减、乘、除四种运算方法得到 4 个计算结果，得到 4 个规模是 1 个数字的子问题，如图（3）所示：

![enter image description
here](https://images.gitbook.cn/541ed4b0-cc65-11e8-a60e-ef3a122d44d9)

图（3）第三层组合计算将问题规模减小到 1 个数字

从两个数字中任选两个进行无重复的排列，可以得到 $P_{2}^{2} = 2$ 个组合结果，也就是说总共有 2 × 4 = 8 个规模为 1
个数字的子问题，图（3）展示了其中一组，即 24/7 与 7
分别进行加、减、乘、除计算。此时问题的规模已经减小到可以直接得到结果的程度了，淡灰色标识的那个子问题结果是
24，就是我们要求解的结果。当然，从其他分支也能得到正确的结果，从图（1）到图（3）只展示了其中一个结果的生成过程。

以上就是我们介绍的穷举法 + 分治法解决 24
点计算问题的算法分析过程。前面提到过，这个问题的难点有两个，上述分析过程解决了第一个，即数字和运算符的穷举遍历问题。还有第二个问题，也就是将四则运算表达式作为结果输出的问题没有解决。可能大家已经从几个图上看到了，图的第三行就是最后要输出的中缀表达式，这是怎么做到的呢？其实很简单，我们给每个数字都指定了一个“出身”，所谓的“出身”就是描述这个数字的来历，或者是计算过程。每个数字的“出身”记录了这个数字的计算过程，当数字被带入到子问题的时候，这个计算过程也跟着被带入到子问题，并随着子问题的求解过程一步一步带到最后。对于原问题来说，4
个数字的出身就是数字本身，当两个数字参与一次计算称为一个结果数字时，就将这两个数字的计算过程作为结果数字的“出身”。为了简化算法实现，避免处理运算符的优先级，我们对每个运算过程都用了括号。

好了，根据上面的分析，我们已经明确了问题和子问题的定义，就是“用 m 个数排列组合计算 24 点（$1\leqslant m \leqslant
4$）”。所以我们的子问题的参数就是 m 个数，考虑用数组来组织这 m 个数。每个数除了数字本身，还有一个出身，用以下数据结构来描述这个“数”：

    
    
    typedef struct
    {
        double num;
        std::string num_str;
    }Number;
    

num_str 是这个数的“出身”，用字符串描述没问题，num 是数字本身，但是数据类型用了
double，这也是实际计算过程的需要，毕竟从上图中也能看到，我们的计算方法是支持分数形式的，中间计算过程会出现浮点数，最终子问题定义就是 Calc24()
函数的参数：

    
    
    void Calc24(const std::vector<Number>& nums)
    {
        //求解子问题
    }
    
    //原始问题的定义
    std::vector<Number> numbers = { { 3, "3" },{ 3, "3" },{ 7, "7" },{ 7, "7" } };
    Calc24(numbers);
    

随着子问题规模的减小，nums 数组的长度由 4 减小到 3，再减小到 2，直至减到 1，numbers
就是子问题的初始状态，也就是原始问题。考虑到一些读者不熟悉 C++，介绍一下上面的数组定义。首先 std::vector 定义了一个向量
vector，vector 的行为实际上就是数组，其内存结构是连续的，并且提供下标运算符 []，可以像访问原生数组一样使用
vector（当然，也可以使用迭代器）。`std::vector<Number>` 表示数组的每个元素是 Number 类型。Number
是个数据结构定义，它有两个成员，分别是 num 和 num_s。

### 算法实现

算法实现要解决的问题是将上述分析过程落地实现，完成 Calc24()
函数。本课程基础部分介绍分治法的时候，我提到过“递归作为一种算法的实现方式，与分治法是一对儿天然的好朋友”，这个问题我们也决定使用递归方式实现
Calc24() 函数。这意味着 Calc24() 函数要在内部构造子问题的`std::vector<Number>`数组，并将其作为递归调用
Calc24() 函数时的参数，从而实现对子问题的求解。

Calc24() 函数对子问题进行处理的时候，要对子问题规模是 1
个数的情况做处理，这实际上也是递归函数的退出（递归终止）条件。对于这个问题来说，当子问题的规模是 1 个数的时候，就要检查这个数是否是
24，如果是则输出一组结果，并退出递归处理；如果不是，说明这个穷举出来的结果是个无效结果，直接退出递归处理。这部分判断和处理的实现在第 4 行开始的 if
(count == 1) 处理流程里，比较简单，就不多说了。对于子问题规模大于 1 的情况，就要选两个数进行计算，对于 $P_{n}^{2}$
问题，常用的代码实现模式就是两重循环。

下一课我会介绍另一种常见的方法，但是那种方法不适合用递归的方式处理不同规模的子问题，所以 Calc24() 函数使用两重循环实现对 $P_{n}^{2}$
的处理。

代码的第 14 行和第 16 行的两个 for 循环就是处理 $P _{n}^{2}$ 的排列，因为不能有重复，所以当 (i == j)
的时候，要排除掉这种情况，就是 18 和 19 两行代码做的事情。第 21 行的 for 循环是对加、减、乘、除四种运算的枚举，也就是将前面两重 for
循环选出来的两个数进行四种运算，得到四个结果。acops 是个函数数组，每一个 op 是一种运算方式，负责将 nums[i]、nums[j]
进行计算，并将结果存入到 new_ num 中。第 27
行定义的`sub_nums`数组是子问题的描述，首先将前面计算的`new_num`加入到`sub_nums`数组中，然后将 nums
数组中没有被选中的数字也加入到`sub_nums`数组中，组成新的子问题。第 30 行的 for 循环就是将 nums
数组中没被选中的数加入到`sub_nums`数组中。子问题`sub_nums`数组准备好以后，在第 37
行递归调用`Calc24(sub_nums)`求解子问题。

对于第 30 行的 for 循环来说，当 nums 的规模是 4 个数的时候，这个 for 循环排除掉已经选中的 i 和 j
后，将剩下的两个数加入到`sub_nums`数组中，形成 3 个数的子问题。当 nums 的规模是 3 个数的时候，这个 for 循环将剩下的 1
个数加入到`sub_nums`数组中，形成两个数的子问题。当 nums 的规模是两个数的时候，这个 for 循环实际上空转了两次排除掉已经选中的 i 和 j
，没有任何数被加入到`sub_nums`数组中，最后得到只有 1
个数的子问题。用递归方式求解子问题，最难的部分是如何用一致的代码处理不同规模和属性范围的子问题。前面的两重 for
循环和对`sub_nums`数组的处理，都体现了这种思想。

    
    
    void Calc24(std::vector<Number>& nums)
    {
        std::size_t count = nums.size();
        if (count == 1) //当只有一个数时，说明计算完成，可以判断结果了
        {
            if (nums[0].num == 24)
            {
                std::cout << nums[0].num_str << " = " << nums[0].num << std::endl;
            }
            return;
        }
    
        //两重循环，从 nums 中找两个数的组合
        for (std::size_t i = 0; i < count; i++)
        {
            for (std::size_t j = 0; j < count; j++)
            {
                if (i == j) //排除相同的情况
                    continue;
    
                for (auto& op : acops) //对四种运算进行枚举
                {
                    Number new_num;
                    //运算可能失败，比如除数是 0 的情况，不再继续处理这个运算符，相当于剪枝效果
                    if (op(nums[i], nums[j], new_num))
                    {
                        std::vector<Number> sub_nums;//定义子问题
                        sub_nums.push_back(new_num);
                        //除了被选出来的两个数，将剩下的数加入子问题
                        for (std::size_t k = 0; k < count; k++) 
                        {
                            if ((k != i) && (k != j))
                            {
                                sub_nums.push_back(nums[k]);
                            }
                        }
                        Calc24(sub_nums); //解决子问题
                    }
                }
            }
        }
    }
    

现在说说 acops，它是一个计算函数的数组，定义了对两个操作数的加、减、乘、除四种运算。std::function
是个可调用对象包装器，这里包装的是一个这样的调用接口：

    
    
    bool (const Number&, const Number&, Number&)
    

这个接口有两个 const Number& 类型的入参，一个 Number& 类型的出参和一个 bool
类型的返回值，两个入参是参与计算的操作数，出参是计算的结果。四个操作符对应的可调用对象是用 lamda
表达式定义的操作函数。这些操作函数的的作用很简单，就是计算两个操作数，当然，还有很重要的一点，就是拼装计算结果的“出身”。前面分析算法的时候提到过，一个数的“出身”很重要，即使数字本身算对了，如果“出身”拼装的不正确，输出的结果也不正确。“出身”拼装很简单，就是将参与计算的两个数的“出身”用操作符连接在一起，然后两端加上一对儿括号，就得到结果数字的“出身”了。这里面只有除法比较特殊一点，因为被除数不能为
0，所以加了个判断。当其返回 false 的时候，相当于做了一次剪枝操作。

    
    
    std::function<bool (const Number&, const Number&, Number&)> acops[] = 
    {
        [](const Number& d1, const Number& d2, Number& dr) 
        { 
            dr.num = d1.num + d2.num; 
            dr.num_str = '(' + d1.num_str + '+' + d2.num_str + ')';
            return true; 
        },
        [](const Number& d1, const Number& d2, Number& dr) 
        { 
            dr.num = d1.num - d2.num;
            dr.num_str = '(' + d1.num_str + '-' + d2.num_str + ')';
            return true;
        },
        [](const Number& d1, const Number& d2, Number& dr) 
        {
            dr.num = d1.num * d2.num;
            dr.num_str = '(' + d1.num_str + '*' + d2.num_str + ')';
            return true;
        },
        [](const Number& d1, const Number& d2, Number& dr) 
        {
            if (d2.num == 0)
                return false;
            dr.num = d1.num / d2.num;
            dr.num_str = '(' + d1.num_str + '/' + d2.num_str + ')';
            return true;
        }
    };
    

为什么不直接在 Calc24() 函数里用 switch…case 或 if…else
直接进行加、减、乘、除计算，反而弄个可调用对象数组，这不是把问题搞复杂了吗？这正是我希望大家理解的地方，这种表结构的处理，也是一致性处理的常用技巧，你不觉得这样做
Calc24() 函数的实现很简洁吗？简洁的代码可以避免眼睛在无聊的琐碎代码上停留太长时间，有助于我们理解算法实现的重点。

### 一个数字的排列组合的技巧

上一课的实现部分我们介绍了用两重循环实现从 n（n > 2）个数字中任选两个数字进行组合的操作，实际上，对于 n
是已知常数的情况，可以用事先安排好组合顺序的方式，直接用一重循环完成选取两个数字组合，减少编码实现的复杂度。以本题为例，已知每次都是从 4
个数字中选择两个（不能有重复），计算 $P_{4}^{2}$ 的结果是 12，可选数字的位置组合分别是
{1,2}、{1,3}、{1,4}、{2,1}、{2,3}、{2,4}、{3,1}、{3,2}、{3,4}、{4,1}、{4,2} 和 {4,3} 共 12
组，有且只有这 12 组，不会再有别的了。每一组表示选择的两个数在数组结构中的位置索引，对数组来说，往往就是数组下标。{1,2}
表示数组中的第一个和第二个数字，对于编程实现来说，要考虑数组索引是从 0 开始的，以 C++ 为例，我们定义这个位置组合数组为：

    
    
    std::vector<std::pair<int, int>> posArray = 
    {
        { 0, 1 }, { 0, 2 }, { 0, 3 }, 
        { 1, 0 }, { 1, 2 }, { 1, 3 }, 
        { 2, 0 }, { 2, 1 }, { 2, 3 }, 
        { 3, 0 }, { 3, 1 }, { 3, 2 }
    };
    

std::vector 定义了一个数组，前面已经介绍过了，这个数组的数据元素类型是`std::pair<int, int>`，从名字可以看出来，这是两个
int 型数据组成的一个数字对，前一个数字的访问用 first 代替，后一个数字的访问用 second 代替。

使用的时候就可以这样使用：

    
    
        std::vector<int> numArray = { 3, 3, 7 ,7 };
        for (auto& pos : posArray)
        {
            //第一个操作数是 numArray[pos.first]
            //第二个操作数是 numArray[pos.second]
            int sum = numArray[pos.first] + numArray[pos.second];
        }
    

numArray 是一个由 int 型数据元素组成的数组，就是我们要枚举的对象数据，for 循环遍历 posArray 数组，对每一个 posArray
的元素（就是位置关系数字对），执行循环体内的操作。

类似这样的技巧有时也被称为“以空间换时间”的策略，有很多这样的技巧，不仅算法设计中常用，软件开发中也常用，了解一下，有益于开阔思路。另外，上述方法用
Java 实现起来差不多是这个意思：

    
    
    int[] numArray = { 3, 3, 7 ,7 };
    int[][] posArray = {
                            { 0, 1 }, { 0, 2 }, { 0, 3 }, 
                            { 1, 0 }, { 1, 2 }, { 1, 3 }, 
                            { 2, 0 }, { 2, 1 }, { 2, 3 }, 
                            { 3, 0 }, { 3, 1 }, { 3, 2 }
                        };
    
    for(int i = 0; i < 12; i++) {
        //第一个操作数是 numArray[posArray[i][0]]
        //第二个操作数是 numArray[posArray[i][1]]
        int sum = numArray[posArray[i][0]] + numArray[posArray[i][1]];
    }
    

24 点游戏的算法总少不了对数字的枚举加上对运算符的枚举，我们这一课介绍的实现算法虽然简洁，但是也包含了这两个内容，Calc24() 函数中前两个 for
循环实现了对数字的穷举，第三个 for
循环实现了对运算符的穷举。我们的算法还缺少一个很重要的内容，就是去除重复结果，去重的方法也很简单，只要再增加十行左右的代码就行了，这个就作为作业留给读者去实现了，我会在介绍课程后半部分的时候将答案上传到
GitHub 上。

### 总结

在本课程的基础部分介绍各种常见的算法模式时，已经多次提醒大家，这些模式通常都不是单独出现的，稍微复杂一点的问题，都可能同时用到其中的多个模式。这一课我们使用的解决方法就同时应用了穷举法和分治法，那么，问题来了，既然算法实现是穷举法
+ 分治法，那么穷举部分用的是深度优先遍历还是广度优先遍历呢？请大家在读者圈发表一下意见吧。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

