> 铺瓷砖、铺地板、在电路板上嵌入芯片等问题，都属于一类问题，基本上可以描述为在一个 N × M
> 的平面空间中摆放一些形状固定的物品，要求覆盖整个平面空间，问有多少种摆放方法。在某些情况下还会增加一点难度，比如在平面上标记一些位置为“坏”点，摆放物品时要避开这些位置等。这类问题传统上是使用状态压缩的动态规划方法解题，因状态递推关系复杂，常用深度优先搜索（DSF）辅助状态的遍历。近些年也流行使用轮廓线动态规划方法求解，但其本质上还是状态压缩。这一课我们就用传统的状态压缩动态规划方法解决铺瓷砖问题。

### 问题分析

铺瓷砖（地板）问题通常以格子为单位给出 N × M 这样的类似棋盘的平面空间，通常 N 或 M 中的一个明显小于另一个，比如本课要讲的题目：有一块面积为 N
× M （N ≤ 6、M ≤ 500）的房间，现在有面积为 1 × 2 和 2 × 1
的地板无数个，要给整个房间铺上地板，有多少种铺地板的方法？题目给出了一个例子，就是当 N = 4、M = 2 的情况，共有 5 种铺法：

![enter image description
here](https://images.gitbook.cn/aa9d47d0-e0ca-11e8-af35-6d3000480069)

图（1）4 × 2 的面积铺地板的 5 种方法

当看到题目中给出的某个维度明显偏小的时候，就应该知道这可能要用到状态压缩了。为什么这么说呢？因为题目的状态往往是呈几何级数增加的，以铺瓷砖问题为例，状态个数是
$2^N$ 个，如果 N
太大，用于表示压缩的状态的维度会变得非常大，大到失去状态压缩的意义，出题的人会考虑到这一点的。状态压缩不一定必须配合动态规划方法，很多算法实现都会用到状态压缩的思想，但是在算法题目上遇到这种情况，基本上
90% 的概率是要用状态压缩的动态规划方法了。

![enter image description
here](https://images.gitbook.cn/b7e16de0-e0ca-11e8-a9c1-438b4e57b867)

图（2）铺地板问题状态定义示意图

#### 状态定义

假设 N 是两个条件中数值较小的那个，如图（2）所示是建立行和列的模型。从图（2）可以看出，在第 i 行铺地板，其铺设状态只受第 i 行和第 i − 1
行铺设状态的影响，与其他行的状态无关。当考虑在第 i 行、第 j 列铺设地板时，会遇到两种情况，第一种情况是位置 [i,j]
是空的，没有被覆盖。此时可以选择用 2 × 1 形状的地板竖着铺，如图（2-a）所示，也可以选择用 1 × 2
形状的地板横着铺，如图（2-b）所示。第二种情况是位置 [i,j] 已经被覆盖，因为前一行竖着铺的地板已经覆盖了这个位置，如图（2-c）所示。

无论位置空还是不空，每一行都有 N 个状态（对应 N 个位置）可以决定这一行的地板铺设。如果用动态规划法解决这个问题，状态的定义要包含行的信息 i
，还要包含这 N 个位置的状态，其状态模型应该是这个样子的：

$$ d[i,j _{1},j_ {2},…,j_{N}] = ….. $$

对于这么多状态的维度，数据模型要用到 N + 1
维数组来存放状态，不仅空间巨大，而且状态递推关系（状态转移方程）也会非常复杂，算法实现也很困难。这时候就要用到状态压缩了，观察图（2），每一行地板的覆盖状态如果用
0 和 1 表示（等会儿解释为什么会有 0 ），呈现一个由 0 和 1 组成的序列。当 N = 6 的时候，序列长度就是 6，比如第一行是
<110011>，第二行是 <001111>。

我们采用按整数比特位方式压缩这些由 0 和 1 组成的状态序列，将其视为二进制整数，并转化成 10 进制数表示，第一行的状态 110011
对应的压缩后的状态就是 51（0 × 33），第二行的状态 001111 对应压缩后的状态就是 15（0 × 0F）。6 位二进制数组成的状态空间总共有
64个（$2^N$），不算太大（这就是题目给出的 N
都是很小的值的原因，太大了这里也会膨胀），状态定义处理起来也就简单很多了。压缩后的状态模型就变成了这个样子：

$$ d[i, state] = …… $$

对于这样一个压缩后的状态 state 值，可以使用位操作很方便地计算出对应位置的占用情况，比如将其与 0 × 00000001 进行与操作，得到的结果就是
state 对应的这一行的第 1 列的占用情况。状态递推计算时，只要改变对应的位的值，就可以得到一个新的状态，使得递推关系式的计算也非常简单。

#### 状态转移

状态压缩后的状态模型是 $d[i, state]$，这个状态表示什么意义呢？$d[i, state]$ 表示的意义是当第 i 行的状态变成 state
的时候，已经有多少种铺地板的方法。$d[i, state]$ 的值受第 i − 1 行的状态（prev）和本行的铺地板动作共同影响，第 i − 1 行总共有
$2^N$ 个状态（其实每一行都有这么多状态），可能存在多个不同的 prev 状态通过变化（横着铺、竖着铺或者不铺）都变成 state
状态的情况，所以要对所有变换成 state 状态的情况求和。根据以上分析，完整的递推关系式（状态转移方程）就是：

![enter image description
here](https://images.gitbook.cn/accae110-eb9d-11e8-9425-4353d4a3006e)

这个状态递推关系式有一个关键点，那就是前一行有多个状态都可能演变成第 i 行的 state 状态，这是理解这个状态转移方程的核心点。

好了，现在说说为什么同样是覆盖了地板，有的位置是 0、有的是 1 的问题。这其实是与状态变换有关，当几个 prev 状态都能产生新的 state
状态时，怎么知道这个 state 到底是上一行横着铺产生的，还是竖着铺产生的？这就引入了 0
，如图（2）所示，当在某一行的一个位置横向铺了一块地板的时候，我们将当前位置和当前位置的下一列（同一行）的位置都设置为
1，表示位置已经覆盖了地板。当在某一行的一个位置竖向铺了一块地板的时候，我们将这个位置设置为 0。

注意，此时仅仅是将这个位置设为 0，并不设置下一行对应列的状态；当处理到下一行的时候，如果发现它的上一行对应位置是
0，我们就知道这是上一行竖着铺了一块地板，那么将这一行的对应位置设置为 1，表示这个位置实际被占用了。

这个操作是怎么实现的呢？举个例子，看图（2）中第 2 行的状态是
<001111>，表示当处理到第三行的时候，就表示第二行已经铺完地板了，其状态已经确定，此时我们只需将第二行的状态取反，就得到了第三行的初始状态
<110000>。这样做避免了在处理第二行的时候影响到第三行的状态，尤其是第二行还在尝试铺的过程中，状态随时变化的时候，不确定地改变第三行的状态，也会影响到无后向性要求。

#### 状态的初始值和结果

根据递推关系式，第 i 行的状态由第 i − 1 行的状态堆叠计算出来，那么第 1 行的状态自然就是用第 0 行的状态决定了。

问题是，第 0 行是个什么鬼，它不存在啊，虽然实际上没有第 0 行地板，但是并不影响第 0 行地板精神上存在。我们在计算之前，就假设第 0
行已经完全铺好地板了（每个位置对应的标志为都是 1），这一行就只有一个状态
<111111>。因为是我们人为摆出来的一个状态，没有其他变化，所以这个状态对应的铺地板的方法个数就是 1。也就是说，第 0 行的 <111111>
状态的值是 1，即 d[0,<111111>] = 1 或 d[0,63] = 1，这就是初始值。

像 Java 和 C++ 这样的编程语言，索引都是从 0 开始的，刚好可以顺势借用精神上存在的第 0 行，实际地板状态就从第 1
行开始。根据这个递推关系，当铺设到第 M 行的最后一个状态时（就是全是 1 的状态 <111111>），其状态值就是最终要求的结果，即 d[M,
<111111>] 或 d[M, 63] 就是结果。

#### 如何计算每一行的状态

根据前面的分析，每一行的状态空间有 $2^N$ 个状态，状态值的范围是 0 ~ $2^N - 1$，对于 N = 6 的情况，状态值的范围就是 0 ~
63。需要注意的是，对不同的行来说，每一行的实际有效状态个数并不相同，也就是说，并不是 $2^N$
个状态都是有效状态。根据本行的铺设情况，还有上一行的铺设情况，有些状态是不会出现在本行的。那么如何遍历本行的有效状态呢？

根据上面“状态定义”的分析，对每一个位置铺设地板，实际有三种情况，第一种情况是如果位置被覆盖就不铺地板，直接后移一列继续处理；第二种情况是如果位置为空，就尝试铺横向地板，然后移动两列再继续处理；第三种情况是如果位置为空，就尝试铺竖向地板，然后移动一列再继续处理。

从这个描述来看，这是一个天然的穷举搜索策略，大家“玩”算法，要有这种敏感度，并且对于本问题来说，每次尝试用各种方法铺完一行（就是处理到第 N
列的时候），实际上就得到了一个状态，类似 <001100> 或 <111100> 这样的状态值（注意 0
是竖向铺地板的情况）。此时就需要将前一行的状态值累加到这一行的这个状态上。为什么呢？是因为前一行的 prev
状态，经过一番尝试，能得到当前行的这个状态，而这正是状态递推关系式所描述的状态转移。

为了遍历每一行的有效状态值，我们采用深度优先的穷举搜索策略，并且使用递归的方法实现这个穷举搜索算法，具体的实现过程将在下面展开介绍。对每一行的状态值的累加计算，体现在对状态的穷举搜索过程中，即穷举搜索算法每得到一个完整的铺地板状态，就根据状态递推公式进行一次状态值的累加，搜索完所有的状态，实际上也就完成了对每个状态值的累加。

因此，这个算法将看不到类似于多项式累加计算那样的直接递推关系计算，而是将递推关系的累加隐含在深度优先的穷举搜索过程中了，这个需要读者结合下面的具体代码实现自己体会。

### 算法实现

#### 算法主体

根据上面“状态的初始值和结果”的描述，算法开始之前要对第 0 行的最终状态设置初始值 1。最终状态就是每个位置都是 1 的状态，这个值就是 $2^N -
1$。

接下来就是从第 1 行到第 M 行，逐行递推计算每一行的有效状态，以及有效状态的值，实际上，当 $d[i, state]$ 的值不是 0
的时候，就说明这是一个合法状态，即从 i − 1 行的某个状态能变化（通过相应的铺地板的方法）到这个 state 状态。如果 $d[i, state]$
的值是 0 ，则说明从 i − 1 行的所有合法状态中，没有哪个状态能变化到 state
状态。因此，我们采用的方法是遍历前一行的所有合法状态，从前一行的合法状态开始搜索，看看在这个合法状态的基础上，当前行能产生多少个合法状态。

    
    
    long long MondriaanDream(int n, int m)
    {
        long long d[MAX_M][MAX_STATE];
    
        memset(d, 0, sizeof(d));
    
        int finalState = (1 << n) - 1; //全是 1 的铺满状态
    
        d[0][finalState] = 1;  //赋初值
        for (int i = 1; i <= m; ++i)
        {
            for (int state = 0; state < (1 << n); ++state) //2^n 个可能的状态
            {
                //这里理解的关键点：state 是作为上一行的状态枚举的
                //这一行的起始状态需要根据 state 取反            
                if (d[i - 1][state] > 0) //值处理前一行的有效状态
                {
                    state_dfs(n, d, i, 0, state, ~state & finalState);
                }
            }
        }
        return d[m][finalState];
    }
    

MondriaanDream()
函数的实现和上述描述基本一致，只有少数地方需要解释。第一个地方是当前行搜索的初始状态，前面讲过，只需对前一行的状态取反就可以得到当前行的初始状态，代码中和
finalState 做“与”操作的目的是确保状态值只有 N 个有效的二进制位，因为 finalState 的二进制形式就是 N 个
1。第二个就是返回最终的结果，这个结果就是第 M 行的 finalState 状态的值。

#### 铺地板状态的深度优先搜索

前面介绍算法原理的时候提到过，state_dfs()
函数会使用递归方式实现。我们已经讲过很多递归程序如何设计递归函数了，这里又是一个“同一问题结构变形模式”的递归程序，问题的状态还是那个 d，列的规模还是那个
N，变化的是每次对应的行 i 不一样。先来看看递归退出条件，很显然，对每一行都是从第 1 列开始，当搜索完第 N
列时就该结束了。这就是退出条件，退出时的操作就是进行一次状态累加计算（将 i − 1 行的 prev 状态累加到第 i 行的 state 状态上）。

递归子结构的主体就是对 [i,j] 位置尝试铺地板，当这个位置对应的状态位是 1 的时候（前一行的地板是竖着铺的），则直接跳到 j + 1
列继续。当这个位置对应的状态位是 0 的时候，则分别尝试横着铺和竖着铺一块地板，并根据铺的方式跳到 j + 1 列或 j + 2
列继续。因此，这个递归函数的结构应该是这个样子：

    
    
    void state_dfs(...i, j, state, ...)
    {
        if(j == n)
        {
            d[i, state] += d[i - 1, prev];  //累加状态
            return
        }
    
        if(state的第 j 列是 1)   //跳过一列，state 没变化
        {
            state_dfs(...i, j + 1, state, ...)
        }
        if(state的第 j 列是 0)   //尝试竖着铺，state 的 j 列置 0，也就是没变化
        {
            state_dfs(...i, j + 1, state, ...);
        }
        if(state的第 j 列是 0 并且 j < n - 1) //如果空间够，尝试横着铺，state 的 j 列和 j + 1 列置 1
        {
            state_dfs(...i, j + 2, state 的j列和j+1列置1, ...);
        }
    }
    

在以上伪代码流程中，需要注意铺设地板后递归调用自身进行下一个位置的处理时，传递给递归函数的 state 参数要设置正确的状态位。竖着铺不用设置，因为本身就是
0 了，横着铺的时候，连续设置两列的状态为 1。

接下来分析递归函数的参数，除了之前分析必然需要的行数 i，当前要处理的列数 j，当前铺到第 j 列的状态 state 之外，问题的状态表 d
要传递给递归函数，列的规模 N 也要传递给递归函数。还有一个很重要的信息，就是 i − 1 行的状态 prev，也要传递给递归函数（其实 prev
状态只在状态累加的时候才用到）。这个递归函数的原型就确定了：

    
    
    //i：第几行，j：第几列，prev 是 i-1 行的状态，state 是 i 行的状态
    void state_dfs(int n, long long d[][MAX_STATE], int i, int j, int prev, int state)
    

列数 j 从 0 开始，每次加 1 或加 2，当 j == N 时，说明最后一列（N − 1 列）也处理完了，所以递归退出条件就是 if(j ==
n)。判断 state 的某一列是否是 1，一般先将 1 左移若干位，得到一个只有那一位是 1，其他位都是 0 的掩码，然后将 state
与掩码做与操作，判断结果是否等于 0 即可。其实没有必要每次都先移位得到掩码，这个掩码可以事先计算好，用一个掩码数组存放，利用数组的下标技巧，直接得到掩码。

    
    
    int bitMask[MAX_N] = {0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080};
    
    //要判断 j 列是否是 1，直接用：
    if(state & bitMask[j]) 
    { ...  }
    

递归函数的参数确定了，递归函数的细节部分就可以实现了，就是一些位操作，不多说了：

    
    
    void state_dfs(int n, long long d[][MAX_STATE], int i, int j, int prev, int state)
    { 
        if (j == n)   // j==n 表示已经越界了，不需要继续递归了
        {
            d[i][state] += d[i - 1][prev]; //前 i-1 行的 prev 状态经过变化后能够变成 i 行的 state 状态
            return;
        }
    
        //如果这个位置已经被上一列所占用，直接跳过
        if ((bitMask[j] & state) > 0)
        {
            state_dfs(n, d, i, j + 1, prev, state);
        }
        //如果这个位置是空的，尝试放一个 1 x 2 的（竖排）
        if ((bitMask[j] & state) == 0)
        {
            state_dfs(n, d, i, j + 1, prev, state);
        }
        //如果这个位置以及下一个位置都是空的，尝试放一个 2 * 1 的（横排）
        if ((j < n - 1) && !(state & bitMask[j]) && !(state&bitMask[j + 1]))
        {
            state_dfs(n, d, i, j + 2, prev, state | bitMask[j] | bitMask[j + 1]);
        }
    }
    

### 总结

这一课我们以铺地板问题为例，介绍了状态压缩动态规划法的应用。在看这一课之前，最好先看一下[第4-4课：状态压缩与动态规划](https://gitbook.cn/m/mazi/columns/5b6d05446b66e3442a2bfa7b/topics/5beb7ecf2c33167c317c9867)的内容，先理解一下状态压缩的目的，理解了目的，也就能理解这个题目中为什么强调
N 不超过 6 了。同时，也要掌握一个技巧，就是给你一个题目，其中某个维度的参数异常小，看起来还像是动态规划，就可以考虑用状态压缩动态规划了。

解决铺地板问题，现在还很流行另一种状态压缩动态规划法，就是轮廓线动态规划法，大家可以搜索一下这个算法的资料，比较一下与本课的传统实现的差异。对于轮廓线动态规划法解决铺地板问题的实现，大家可以在读者圈里或群里发表自己的意见。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

