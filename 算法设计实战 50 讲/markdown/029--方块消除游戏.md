>
> 前面基础部分我们介绍过简单的串模型的动态规划，在这个系列中，我们又介绍了区间动态规划模型、状态压缩动态规划模型和线性动态规划模型。我们用的算法实现都是尽量使用状态递推关系式直接用递推的方法，大家可能都忘了“备忘录（或状态记忆）”也是动态规划，这一课我们将讲解如何用这种方法来求解方块消除游戏的算法实现。

### 问题介绍

Jimmy 最近迷上了一款叫做“方块消除”的游戏。游戏的规则是：n
个带颜色的方块排成一列，颜色相同的方块连成一个区域（如果两个相邻的方块颜色相同，则这两个方块属于同一个区域）。游戏时，可以选择一个区域消除，如果消除区域的方块数为
x，则可以得到 $x^2$ 的分数。方块消除后右边的方块自动向左移动。游戏虽然很简单，但是要得高分也不容易，那么问题来了，最高可以得多少分？

这个游戏的有趣之处在于消除方块后自动移动方块，方块移动可能会拼成新的连续区域。消除两个独立的相同颜色方块，可以得 $1^2+1^2=2$
分，如果这两个独立的同色方块能连成一个连续的区域，则消除这个连续区域可得 $2^2=4$ 分。因此，尽可能的形成连续的区域进行消除，才是得高分的途径。

![enter image description
here](https://images.gitbook.cn/de03df40-ebaf-11e8-930f-6d8fe3f71eb4)

图（1）消除方块问题示意图

假如给出的颜色方块的序列如图（1）所示，这个序列能得的最高分是 $4^2+3^2+2^2=29$ 分，两个蓝色方块最后消除。

### 问题分析

用动态规划法求解问题，首先需要确定子问题和最优子结构的状态定义。这个问题的关键是让后面的方块或区域能和前面的同色方块或区域连成连续的区域，因此我们考虑最优子结构的构成就是“前面”和“后面”两部分。这其实也是动态规划问题确定状态的一种常用思想，就是说状态定义不针对某个阶段，而是针对这个问题之前的最优决策定义状态，然后结合后面的部分做当前问题的最优选择，这样做的好处是在很多情况下分解的子问题天然具有无后向性。[第4-7课](https://gitbook.cn/m/mazi/columns/5b6d05446b66e3442a2bfa7b/topics/5bfb59c7ae0e5f436e35c14f)介绍的投资问题就是这种思想，不考虑具体的某个项目决策的最大收益，而是考虑前
i 个项目的整体最大收益，解决了子问题的无后向性问题。

#### 状态和状态递推关系

针对这个问题的建模，我们先对颜色编号（信息数字化处理），给不同的颜色分配不同的数字编号，将计算机无法直接处理的颜色方块序列变成了 1 2 2 2 2 3 3
3 1 这样的数字序列。然后对这个数字序列做一下预处理，将其分成四个区域（blocks），每个区域用 color 属性表示颜色编号，用 len
属性表示区域长度，可得 {1,1}、{2,4}、{3,3} 和 {1,1}。假设我们用 clolor[i] 表示第 i 个区域的颜色，用 len[i]
表示第 i 个区域的长度，用 m 表示颜色区域的数量（对于本问题，m = 4）。根据这个模型，子问题的状态可以定义为 $d[i,j,k]$，表示区域 i
和区域 j−1 之间的颜色区域和经过一系列消除动作后，最后的 color[j] 与后续的 k 个和 color[j] 相同颜色方块连成的新区域
${color[j]、len[j]+k}$ 共同消除后的最高得分。

k 的意义在于根据前面区域 i 和区域 j−1 之间的颜色区域消除动作的选择不同，k 的值也有相应的变化。这里状态描述里的“前面”就是区域 i 和区域
j−1 之间的颜色区域，“后面”就是 color[j] 与后续的 k 个和 color[j] 相同颜色方块连成的新区域 ${color[j],
len[j]+k}$、$d[i][j][k]$ 的决策就有两个选择。

（1）将区域 ${color[j], len[j]+k}$ 消除，状态转移方程就是：

$$ d[i,j,k] = d[i][j-1][0] + (len[j] + k)^2 $$

（2）暂时不消除区域 ${color[j],
len[j]+k}$，而是将其连接到前面的某个颜色相同的区域上，形成更大的区域。注意这里并不是立即连接，而是不消除这块区域，等着其他消除动作完成后，让这块区域和前面那个区域之间的方块都消完后再连接成连续区域。
**这个“等其他消除动作完成”是通过递推关系实现的，就是等其他子问题求解完成**
。理解这一点很重要，我当初就是颇费周折才想通这一点的。假设前面那个颜色相同的区域是 $p(i \leq p < j)$，则状态转移方程就是：

$$ d[i,j,k] = d[i,p,len[j]+k] + d[p+1,j-1,0] $$

**因为区域 ${color[j]、len[j]+k}$ 连接到前面的 p 区域上了，所以区域 p + 1 和 j−1
之后就没有相同颜色的区域了，因此对应状态的 k 就是 0 了。**

显然，我们要的是这两个选择中的最大值作为最后的得分，那么此问题的状态转移递推关系式就是：

![enter image description
here](https://images.gitbook.cn/19804ed0-f2e2-11e8-9048-db873aaf0d56)

#### 初始状态和结果

对于任何一个颜色区域 i，如果前面没有颜色方块可消除，则其得分是 0，这就是初始值，即 $d[i,i-1,0] =
0$，最后的结果就是全部颜色区域的消除得分，自然就是 $d[1,m,0]$ 了，它表示的是包括第一个颜色区域和最后一个颜色区域的完整问题的状态。

### 算法实现

前面说了，我们要用备忘录（或状态记忆）方法实现这个动态规划算法。返回看看刚分析的“状态递推关系”就知道了，这里面有递归，用递归方法实现状态的递推计算是很自然的选择了。根据递推关系式，这个递归函数的参数实际也定了，就是
i、j 和 k，不妨这样定义这个递归函数：

    
    
    int dp(int i, int j, int k)
    

在算法开始之前，需要将原始输入的数据做个处理，即按照颜色分成颜色区域块，dp() 函数假设这个处理已经完成了，即 color 数组和 len
数组已经整理好了。dp() 函数的退出条件就是 i 和 j 相同的时候，此时直接计算区域 i 的得分就是状态 $d[i,j,k]$ 的得分。

dp() 函数的递归子结构主体首先要判断当前状态 $d[i,j,k]$ 是否已经被求解过，如果已经被求解过，则直接返回状态值
$d[i,j,k]$。判断子问题状态是否被求解过的方法就是看其值是否大于 0，当然，为了配合这个判断，在算法开始之前需要将所有的子问题状态值都初始化为 0。

dp() 函数的递归子结构主体接下来是按照递推关系式求解 $d[i,j,k]$
的值，求解分两步，第一步先用第一种方法求解一个值，然后再用第二种方法继续求解，并根据从中选择最大的值作为 $d[i,j,k]$
最终的结果。如果之前的问题分析都看懂了，这个函数其实也没啥好说的了，看代码吧。

    
    
    int dp(int i, int j, int k)
    { 
        if (i == j)
        {
            d[i][j][k] = (len[j] + k)*(len[j] + k);
            return d[i][j][k];
        }
    
        //备忘录状态查询
        if (d[i][j][k] > 0)
        {
            return d[i][j][k];
        }
    
        //暂时先取第一种方式的结果作为 d[i][j][len] 的值
        d[i][j][k] = dp(i, j - 1, 0) + (len[j] + k) * (len[j] + k);
    
        //按照第二种方式计算，并根据情况更新 d[i][j][len] 的值
        for (int p = i; p < j; p++)
        {
            if (color[p] == color[j])
            {
                int tmp = dp(i, p, len[j] + k) + dp(p + 1, j - 1, 0);
                if (tmp > d[i][j][k])
                {
                    d[i][j][k] = tmp;
                }
            }
        }
    
        return d[i][j][k]; 
    }
    
    //在准备好 color 数组和 len 数组得情况下求解内容中给出的例子
    int score = dp(1,4,0); //29
    

### 总结

说实话，按照我的理解，这个题目用动态规划方法有点“为赋新词强说愁”的感觉，状态定义十分的难以用语言表达，如果读者能理解这个状态定义，估计以后再复杂的状态定义也不在话下了。另外，即使用了动态规划方法，整个算法的时间复杂度仍然是
$O(n^4)$ 级别的。

但是作为一个动态规划的典型问题，对这个问题的理解能极大地提高对动态规划方法的理解。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

