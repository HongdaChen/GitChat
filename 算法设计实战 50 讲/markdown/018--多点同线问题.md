>
> 这一课我们介绍一个计算几何方面的穷举类算法问题。计算几何类的问题也是算法问题中一个大的分类，并且在很多其他算法中都会用到一些几何公式。比如三角形剖分问题中如果是按照三角形的面积做最优剖分，则需要用到根据三角形的边长求面积的海伦公式。这一课我们用到的几何内容不多，只用到了求直线斜率的公式，主要还是为了演示穷举法的应用；同时还会介绍到一个用一遍扫描统计出有序序列中哪个值出现次数最多的代码技巧，以及快速排序在实际问题中的应用方法。

### 问题的提出

一个几何平面上有 N 个点，根据欧氏（欧几里得）几何原理，每两个点可以连成一条直线，N
个点可以连成很多条直线。当然，也会有多个点共线的情况出现，现在我们的问题是，在这 N
个点中，找出哪两个点组成的直线上包含最多的点，也就是找出含有最多点的那条直线。

![enter image description
here](https://images.gitbook.cn/ac166300-cfa2-11e8-a32a-8d282c39c2f0)

图（1）多点共线问题示意图

如图（1）所示，在这么多直线中，绿色标识的那条直线包含了四个点，是包含最多点的直线。算法比赛中这个题目给出所有点的坐标，要求算法只输出包含最多点的那条直线上所包含的点的个数即可，所以最后的结果只是算法实现上复杂一点，数据模型其实非常简单。我们课程的主要目的是演示算法的分析、数据模型构建和编程实现算法的过程，以及在这个过程中分析和思考问题的方法，所以，我们修改一下题目要求。首先为每个点增加一个编号，然后要求在输出信息时，输出最多共线点的个数以及这些点的信息，包括点的编号信息和坐标值。增加的这些要求意味着什么？意味着我们需要在算法实现的过程中，小心地维护一组最多点的信息列表，以便最后输出结果时输出题目要求的内容。不仅如此，算法过程中的各种处理，比如按照直线斜率的排序，都比原题目复杂一点。

### 问题分析

现在开始分析这个问题。题目要求的结果是共线的点，但是题目给的信息只有点，所以要先想办法弄出直线才行。根据几何知识，任意两个点可以组成一条直线，所以只需要将这
N 个点两两组合，就可以得到 N * (N − 1) 条直线。直线有了，剩下的事情就是判断其他的点是否在这条直线上。所以，总结起来，这个算法的实现方法就是：

  * 从 N 个点中选择两个点 $(x _{1}, y_ {1})$ 和 $(x _{2}, y_ {2})$，构成一个两点式直线方程：$\frac{y-y _{2}}{y_ {1} - y _{2}} = \frac{x-x_ {2}}{x _{1} - x_ {2}} $；
  * 对剩下的 N − 2 个点，依次带入直线方程，确定是否在直线上，得到一个共线的点的记录；
  * 重复上面步骤，直到所有点的组合都穷举一遍；
  * 比较所有共线点的记录，输出最多点的那个记录。

这个算法需要处理 N * (N − 1) * (N − 2) 次点与直线关系的判断，整体的算法时间复杂度是
$O(N^{3})$。如果点的数量不多，这个算法实现方案还能应付，但是在 OJ（Online Judge）上提交这个实现方案，基本都会超时。

现在换个思路再分析这个问题。是否一定要先有直线才能判断多点共线问题？肯定不是，因为直线还有一个特性，就是直线的斜率。根据直线的公理，斜率相等的直线是平行线，那么，如果这些斜率相等的直线都经过同一个点呢？那当然就是共线了。所以思路来了，我们以点为对象进行穷举，计算每个点与其他点组成的直线的斜率，斜率相等的那些点肯定就是共线的点了。以图（2）为例，我们选择
K 点，然后计算 K 点与其他各点组成的直线的斜率，可能有很多个斜率，只要相等的，肯定是共线的（因为它们都经过 K 点）。

![enter image description
here](https://images.gitbook.cn/56a25c20-cfa3-11e8-a32a-8d282c39c2f0)

图（2）以 K 点为原点，计算其他各点的斜率示意图

从图（2）上看到，经过 K 点的共线情况最多是 3 点共线，有三种情况都是 3 点共线。是否这个题目的最终结果就是最多 3
点共线呢？不一定，还要继续看看其他点的情况。比如图（3）所示，选择 A 点作为原点，计算 A 点与其他点的斜率，可以看出来，有一个 B、A、F 和 H
四个点共线的结果，这肯定由于 K 点的情况。至于最终的结果，要穷举完所有的点才能下结论。

![enter image description
here](https://images.gitbook.cn/78455a30-cfa3-11e8-a32a-8d282c39c2f0)

图（3）以 A 点为原点，计算其他各点的斜率示意图

根据以上分析，新的算法实现方法可以总结为：

  * 从 N 个点中选择一个点作为原点 $(x _{0}, y_ {0})$；
  * 计算其他 N - 1 个点与原点的斜率 $$k = \frac{y _{i} - y_ {0}}{x _{i} - x_ {0}}​$$
  * 统计上一个操作得到的 N -1 个斜率值中相同斜率的个数，记录相同斜率最多的那一组结果；
  * 重复前面的操作，直到处理完所有的点，比较每个点得到的记录，取最多的那一组作为最终的结果。

其中第 3 步的描述可能有点难以理解，它的大致意思是这样的：假如有 10 个点，对于第 1 个点，计算其余 9 个点与这个点组成的直线斜率，得到 9
个斜率值：

![enter image description
here](https://images.gitbook.cn/424ed700-d5ff-11e8-9e01-715fb65748a3)

统计这 9 个斜率值，我们发现 9.82 出现了 2 次，15.21 出现了 3 次，72.12 出现了 2 次，其他的值都只出现了 1 次。所以编号为
2、5 和 9 的 3 个点斜率值都是 15.21，加上作为原点的第 1 个点，得到的最高记录是 4 个点共线。我们将这四个点的信息作为第 1
个点的最高记录保存起来，准备与其他点统计到的最高记录比较，最后选择最多的那个结果作为最终的结果。

### 数据模型设计

数据模型是结合问题来考虑怎么设计的，这个问题给我们的信息是点的个数和每个点的坐标，所以，我们首先要考虑的事情就是如何设计数据结构存储这些信息，并且在算法计算的过程中，能够方便地引用这些信息。平面上的点由横坐标
x 和纵坐标 y 组成，通常会用一个数据结构来描述点：

    
    
    typedef struct
    {
        double x;
        double y;
    }Point;
    

平面坐标是实数系，所以这两个坐标值都用浮点数表示。进一步考虑，用何种数据结构存储所有点的信息呢？这些点是离散的，表示离散信息常用的数据结构有数组、链表、集合和哈希表。对于这个问题，最好使用线性数据结构，并且使用集合和哈希表开销有点儿大，所以先排除集合和哈希表。记得我们给这个问题增加的一点难度吗？就是我们要输出最多共线点的那些点的信息，这个信息中就包括点的编号。基础部分提到过的数组下标的技巧大家没有忘记吧，这里又要用了。如果我们给每个点用数字编号，那么可以利用数组下标以
O(1) 时间复杂度直接根据编号得到其对应的点的坐标信息，所以，我们用数组。

上面“问题分析”中介绍算法过程的第 3
步，需要计算每个点与原点所组成的直线的斜率，以便找出斜率相同的那些点。这里就需要能够在计算的过程中，存储每个斜率值所对应的点。我们用数字编号表示点，定义
Scope 数据结构表示斜率值和点的关系：

    
    
    typedef struct
    {
        double k;
        int p_idx;
    }Slope;
    

基本上，这个题目的数据模型还是非常简单的，两个数据结构的设计也都是算法设计中的常用考量，就是把一组相同的属性组织在一起，便于整体维护和访问。比如点的坐标，用
Point 对象来组织，要比用两个数组分开存储横坐标和纵坐标要好。

### 算法实现

这个问题的模型很简单，算法实现也不复杂，但是算法实现的过程中还是有很多需要考虑的地方。之所以选这个题目作为例子，是因为设计算法实现的过程中常遇到的情况，这个例子就有好几个，包括浮点数的处理和用一遍扫描统计出有序序列中哪个值出现次数最多的代码技巧。

#### 浮点数的处理

又遇到浮点数了，基础部分我们讲过浮点数处理需要注意的地方，这里再强调一次：不要对两个浮点数直接判等（或判不相等），除非你明确知道你想做什么。简单来说，就是不要用
== 运算符直接判断两个浮点数是否相等（或者用 !=
运算符直接判断两个浮点数是否不相等）。很多读者不明白为什么不能直接判等，这里再啰嗦一下，计算机存储浮点数用的是二进制形式，它和逻辑上理解的十进制小数存在表达误差，也就是说有的十进制小数无法用二进制小数精确表达。本来应该相等的两个浮点数由于计算机内部表示的原因可能略有微小的误差，这时用
== 判断，计算机会认为它们不相等，所以，你所希望的“等于”可能永远都不可能发生。有人会说，我一直用 == 判断浮点数，也没什么问题啊？一般包括 0
在内的整数，0.2、0.65
这样的小数，计算机还是能精确表达的，这种情况下判等也不会出错，这就是我说“除非你明确知道你想做什么”这句话的原因。常在河边走，哪能不湿鞋？你总会遇到无法用二进制小数精确表达的浮点数的情况的，所以，
**不要对两个浮点数直接判等，除非你明确知道你想做什么**
。另外，计算机表示的浮点数有效数位比较多，在某些条件下，直接判等的要求非常苛刻，比如迭代法中的迭代收敛条件，如果用判断最近两次迭代值相等作为迭代精度要求的退出条件，对于一些收敛比较慢的迭代算法来说，基本上就相当于死循环了。你会发现经过漫长的迭代之后，小数点后面
XX 位还是不相同的。

一般情况下，对于浮点数，只要在精度要求的误差范围内，就可以认为是相等了。常用的判断浮点数相等的方法就是：

    
    
    const double EPS = 1e-8; //定义本问题的浮点数精度范围
    
    bool IsEqualFloat(double v1, double v2)
    {
        if (std::fabs(v1 - v2) < EPS)
            return true;
    
        return false;
    }
    

精度值 EPS 可以根据问题的要求做调整，对于本问题，我们认为小数点后面 8 位有效数字相同，就满足等于的条件了。

#### 斜率计算

斜率计算就是应用斜率公式计算出两个点所在直线的斜率，但是需要对斜率无穷大的情况做特殊处理。几何意义上如果两个点的横坐标相同，则其斜率为无穷大，这又遇到一个问题，计算机无法表示无穷大，同时也不能承担计算过程中出现除以
0
所产生的异常。基础部分我们介绍过这种情况的建模方法，一般是用一个问题域不可能出现的大数来表示无穷大（或者用问题域不可能出现的小数来表示无穷小）。这里我们用
double 类型的浮点数能表达的最大值来表示无穷大，计算斜率的算法代码实现就考虑了这种情况：

    
    
    //#define DBL_MAX         1.7976931348623158e+308 /* max value */  
    
    double CalcSlope(const Point& p0, const Point& p1)
    {
        if (IsEqualFloat(p0.x, p1.x)) //点的 x 坐标相等，斜率为无穷大
        {
            return DBL_MAX; //用浮点数的最大值代表无穷大
        }
    
        return (p1.y - p0.y) / (p1.x - p0.x);
    }
    

#### 算法分析第三步的处理

算法分析的第三步，我们需要对计算出来的 N − 1 个斜率值进行统计，看看哪个斜率值出现的次数最多。一般的处理方法是：

  1. 准备一张表记录各个斜率值出现的次数，初始化时这张表是空表；
  2. 对每一个斜率值做 3 或 4 的处理；
  3. 如果这个斜率值已经存在表中，则直接修改表中对应项的计数值 +1，并记录这个斜率值对应的点的信息；
  4. 如果这个斜率值不存在，则将其增加到表中，将计数值置为 1，并记录这个斜率值对应的点的信息；
  5. 遍历这 N − 1 个斜率值，重复第 2 ~ 4 步，直到每个斜率值都统计过一遍；
  6. 最后遍历统计表，找出计数值最高的斜率值和其对应的所有点的信息（也可使用排序）。

上述方法的问题是需要额外的存储空间存储这张表，并且最终还是要对表中的数据做一次遍历。对于这种统计哪个值出现次数最多的问题，这里介绍一种直接排序，然后一次遍历得到结果的技巧，这个技巧所采用的方法不需要额外的存储空间，并且这个方法是个惯用方法，我在很多算法题目中都看到过，读者可以将其作为一种实现模式记下来，以后遇到此类问题可以直接拿来用。这个技巧的处理方法如下。

  1. 首先对这 N − 1 个斜率值进行排序（升序或降序都可以）。
  2. 准备好四个标志变量，分别是：`max_len` 表示已经找到的最多斜率值相同个数，`max_start_pos` 表示已经找到的最多相同斜率值的第一项在排序后列表中的位置，len 表示当前正在处理的斜率值的相同个数，`start_pos` 表示当前正在处理的相同斜率值的第一项在排序后列表中的位置。这四个标志变量的初始值分别是 `max_len=0`、`max_start_pos=0`、len=1、`start_pos=0`。
  3. 从排序后斜率值中的第 2 项开始，依次与前一项比较，做 4 或 5。
  4. 如果某项的值与前一项相同，则 len 值加 1。
  5. 如果某项的值与前一项不相同，则判断 len 是否大于 `max_len`，如果是，则用当前的 len 和 `start_pos` 值更新 `max_len` 和 `max_start_pos`，即 `max_len = len`，`max_start_pos = start_pos`；如果 len 小于 `max_len`，则不做更新，但是要重置当前扫描状态，即`start_pos`赋值为当前扫描的位置，同时 len 赋值为 1。
  6. 如果斜率值都处理完，返回 `max_len` 和 `max_start_pos` 作为结果，如果没有处理完，则重复步骤 3-5。

我们接着用“问题分析”给的那个斜率表中的例子，对其按照升序排序后，得到的结果如下。

![enter image description
here](https://images.gitbook.cn/6d9d1cf0-d5ff-11e8-8a0f-73e7a686ef18)

  1. 初始值：`max_len=0`、`max_start_pos=1`、len=1、`start_pos=1`。
  2. 处理第 2 项，其值为 9.82，与前一项（第 1 项）相同，则 len 值 +1，此时 len=2。
  3. 处理第 3 项，其值为 15.21，与前一项（第 2 项）不相同，此时 len（2）值大于 max_len（0），执行替换，替换后`max_len=2`，`max_start_pos=0`（因为`start_pos = 0`），然后将 `start_pos` 赋值为当前位置 3，将 len 赋值为 1。
  4. 处理第 4 项，其值为 15.21，与前一项（第 3 项）相同，则 len 值 +1，此时 len=2。
  5. 处理第 5 项，其值为 15.21，与前一项（第 4 项）相同，则 len 值 +1，此时 len=3。
  6. 处理第 6 项，其值为 36.34，与前一项（第 5 项）不相同，此时 len（3）值大于 `max_len（2）`，执行替换，替换后 `max_len=3`，`max_start_pos=3`（因为 `start_pos = 3`），然后将 `start_pos` 赋值为当前位置 6，将 len 赋值为 1。
  7. 处理第 7 项，其值为 72.12，与前一项（第 6 项）不相同，此时 len（1）小于 max _len（3），不执行替换，然后将 start_ pos 赋值为当前位置 7，将 len 赋值为 1。
  8. 处理第 8 项，其值为 72.12，与前一项（第 7 项）相同，则 len 值 +1，此时 len=2。
  9. 处理第 9 项，其值为 124.54，与前一项（第 8 项）不相同，此时 len（2）小于 max _len（3），不执行替换，然后将 start_ pos 赋值为当前位置 9，将 len 赋值为 1。
  10. 结束处理，此时 `max_len=3`，`max_start_pos=3`，即最相同的斜率值是从（排序后列表的）第 3 项开始的那个斜率，长度为 3 项。

结合之前的处理方法来说明上述例子的展示，这个技巧的算法实现应该不难理解：

    
    
    typedef struct
    {
        int start_idx;
        int count;
    }Slope_Rec;
    
    Slope_Rec GetMaxPointList(const std::vector<Slope>& slopes)
    {
        int max_len = 0;
        int max_start_pos = 0;
    
        int len = 1;
        int start_pos = 0;
        for (int s = 1; s < slopes.size(); s++) //从第2项开始
        {
            if (!IsEqualFloat(slopes[s].k, slopes[s - 1].k)) //是否相同
            {
                if (len > max_len) //是否需要更新 max_len 和 max_start_pos
                {
                    max_len = len;
                    max_start_pos = start_pos;
                }
                start_pos = s; //赋值当前位置统计下一个
                len = 1;
            }
            else
            {
                len++;
            }
        }
    
        return { max_start_pos, max_len };
    }
    

#### 对快速排序的演示代码进行改造

如果直接使用编程语言的便利设施，对斜率列表进行升序排序，只需要一行代码即可：

    
    
    std::sort(slopes.begin(), slopes.end(), 
              [](const Slope & s1, const Slope & s2) { return s1.k < s2.k; });
    

但是很多读者希望我多介绍一些基础的内容，所以这里我将基础部分介绍过的快速排序算法改造一下，使之适合本问题的数据模型，用于替换标准库的排序算法。基础部分介绍分治法我给出了一个快速排序的例子算法实现，那个实现和数据结构书中的实现别无二致，弄个数组，然后排排序，用于演示算法原理。但是现实中的大部分问题都不是简单的整数数组，而是数据表，表中的每一项都是一个数据集合，对整个数据表进行排序和对数据排序有稍微的差别，好在基本排序的原理是不变的，变的只是对数据结构的处理差异。排序都是基于关键字进行的，集合中关键字之外的属性都是跟随属性，随着记录的移动来移动它们就行，所以要先确定关键字。关键字就是要做数据比较的那个属性，对于
Slope 集合的排序，关键字就是斜率 k。这里要说明一下，更一般的考虑，是将排序设计成抽象接口，就像上面给出的 std::sort()
算法一样，但那不是本课程考虑的内容，读者可自行发挥。这里我们考虑的是如何改造数据接口定义，将理论上的通用算法应用到解决具体的问题上。

首先改造用于交换数据元素的 exchange() 函数，这里要交换的就不是两个整数了，而是两个 Slope 数据集合。其实，也很简单：

    
    
    void exchange(std::vector<Slope>& slopes, int m, int n)
    {
        Slope tmp = slopes[m];
        slopes[m] = slopes[n];
        slopes[n] = tmp;
    }
    

然后是 partion() 函数，需要修改的地方不多，只是比较部分强调是对关键字 k 进行比较：

    
    
    int partion(std::vector<Slope>& slopes, int p, int r)
    {
        Slope x = slopes[r];
        int i = p;
        for (int j = p; j < r; j++)
        {
            if (slopes[j].k < x.k) //只比较关键字
            {
                if (i != j)
                {
                    exchange(slopes, i, j);
                }
                i++;
            }
        }
        exchange(slopes, i, r);
        return i;
    }
    

最后的函数，貌似只需要改 slopes 就可以了：

    
    
    void quick_sort(std::vector<Slope>& slopes, int p, int r)
    {
        if (p < r)
        {
            int mid = partion(slopes, p, r);
            quick_sort(slopes, p, mid - 1);
            quick_sort(slopes, mid + 1, r);
        }
    }
    

使用改造后的快速排序算法代替前面使用 STL 算法库的例子：

    
    
    std::vector<Slope> slopes;
    
    quick_sort(slopes, 0, slopes.size() - 1);
    

#### 算法主体

StraightLine() 函数的第 3 行和第 6 行又看到了熟悉的两重循环结构，还有第 8 行的 if (i == j) 的跳过处理，这是典型的从 N
个目标中任选 2 个（不能重复）的处理模式，要记下来啊。第 6 行的内层循环计算编号 i 的点与其他点组成的直线斜率，并存储在 slopes 数组中。第
15 行排序，不解释了，第 17 行求 slopes 中的最大相同点信息，前面解释过原理了，这里也不再啰嗦。返回值 pts
中存放算法最终要返回的结果，pts 只记录点的编号，外层在循环过程中，这里的结果会被不断地更新，直到算法完成，pts 里面的值才是最终的结果。

第 18 到 28 行的代码，就是对 pts 进行更新处理，如果 posi 返回的结果优于 pts
中已经存的结果，则进行依次更新。更新的步骤是先清除之前的记录，然后将当前处理的点加入记录（ i 对应编号的点），毕竟这个点也是共线的点嘛。接着从
slopes 数组中逐项添加斜率相同的点，slopes 已经排序，并且 posi 返回的是其中最好的一组结果的开始位置和长度，直接复制数据就可以了。

    
    
    void StraightLine(const std::vector<Point>& points, int n, std::vector<int>& pts)
    {
        for (int i = 0; i < n; i++)
        {
            std::vector<Slope> slopes;
            for (int j = 0; j < n; j++)
            {
                if (i == j)
                    continue;
    
                double k = CalcSlope(points[i], points[j]);
                slopes.push_back({ k, j });
            }
    
            quick_sort(slopes, 0, slopes.size() - 1); //排序
    
            Slope_Rec posi = GetMaxPointList(slopes);// 取当前最大记录
            if (posi.count > pts.size()) //与已经保存的其他点的最大记录比较
            {
                //需要更新最大记录
                pts.clear();
                pts.push_back(i); //先将原点加入
                //再将斜率表中的其他点加入（都是斜率相同的点，p_idx 记录的是点的编号）
                for (int p = posi.start_idx; p < (posi.start_idx + posi.count); p++)
                {
                    pts.push_back(slopes[p].p_idx);
                }
            }
        }
    }
    

### 总结

通过这一课的题目，读者应该学到几点，首先，判断点是否在直线上，不是一定要先弄出直线方程，然后再将点的坐标带入方程计算，还可以用共点且斜率相等的方法判断；其次是浮点数处理的一般原则；还有就是如何改造你在数据结构课上学到的快速排序算法，使其与实际问题的数据模型相结合，解决实际的排序问题；最后，是一个用一遍扫描统计出有序序列中哪个值出现次数最多的代码技巧。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

