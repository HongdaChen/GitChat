>
> 在自然语言识别领域中，中文的分词技术绝对是一个很有意思的话题，英文本身是以单词为基础，单词之间以空格隔开，不存在分词的问题，但是汉语有这个问题。关于分词有很多可玩的地方，比如之前很火的一个对对联的小程序，给出上联可以自动对出下联，对上联的识别肯定是建立在正确的分词基础上的。这一课我们介绍一种理论简单、实现也简单的分词方法，当然，效果也就那样了，不过，拿来玩玩还是可以的。

### 最大匹配法

中文的分词技术，大致可分为几类，一类是基于词典、字库的匹配分词方法；一类是基于统计学的分词方法，在词典、字库的基础上增加词频统计信息；还有一类是基于对语言知识理解的基础上的分词方法，包括各种机器学习类分词算法。这里要讲的最大匹配法就是第一类方法。

既然最大匹配算法是基于词典或字库的算法，那么最大匹配算法就需要一个包含所有汉语词汇的词典，每当需要确认一个词的时候，就要查一遍词典，效率自然比较低，因此最大匹配法一般用于算法学习，或者在一些算法题目中出现。根据分词算法匹配的方向，最大匹配法可分为正向最大匹配法（Maximum
Matching）和逆向最大匹配法（Reverse Maximum Matching）。

#### 正向最大匹配算法

假设最大匹配算法的词典中最长的词有 k 个汉字字符，则正向最大匹配算法的基本思想是：每次从被处理的句子中取前 k
个汉字作为匹配字符串，用这个匹配字符串查词典，如果词典中存在这个词，则查找成功，将匹配的词从句子中切分出来；如果查找失败，即找不到这样一个有 k
个字的词，则将匹配字符串中最后一个字去掉，将剩下的 k−1 个字组成的词作为匹配字符串，继续查词典；如果还是查找失败，则再去掉最后一个字，将剩下的 k−2
个字组成的词作为匹配字符串，继续查词典。如此重复，直到匹配成功，切分出一个词，完成一轮匹配，然后再从句子中取前 k
个字继续处理（匹配到的词已经从句子中摘除了），直到完成整个句子。

整体的算法流程如下：

  * （1）待处理句子是否为空，如果为空，转（5）结束，否则转（2）继续处理；
  * （2）从前向后从待处理的句子中取 k 个字作为匹配字符串，k 是词典中最长词条中汉字的个数；
  * （3）从词典中查找匹配字符串，如果找到，就将此匹配字符串切分为一个词，并将这个词从句子中切掉，转（1）继续处理，如果没有找到匹配，转（4）继续处理；
  * （4）如果匹配字符串不为空，则将匹配字符串最后一个字删除，转（3）继续处理，否则转（5）结束处理；
  * （5）如果待处理的句子不为空，则返回失败，否则，返回成功，并输出切分的词。

接下来，我们举个例子来说明一下上述算法流程，假设要处理的句子是“计算机编程有意思”，并且假设有一个很全面的词典，词典中最长的词条是 5
个汉字。按照上述算法流程对这个句子进行处理：

  * 原始句子 S1=“计算机编程有意思”，匹配字符串 S2，从 S1 中取前 5 个字，赋值给 S2，即 S2=“计算机编程”；
  * 用 S2 匹配词典，没有找到匹配，去掉最后一个字，S2=“计算机编”；
  * 用 S2 匹配词典，没有找到匹配，去掉最后一个字，S2=“计算机”；
  * 用 S2 匹配词典，找到一个匹配的词“计算机”，从 S1 中切分出“计算机”这个词，S1=“编程有意思”，从 S1 中取前 5 个字，赋值给 S2，即 S2=“编程有意思”；
  * 用 S2 匹配词典，没有找到匹配，去掉最后一个字，S2=“编程有意”；
  * 用 S2 匹配词典，没有找到匹配，去掉最后一个字，S2=“编程有”；
  * 用 S2 匹配词典，没有找到匹配，去掉最后一个字，S2=“编程”；
  * 用 S2 匹配词典，找到一个匹配的词“编程”，从 S1 中切分出“编程”这个词，S1=“有意思”，从 S1 中取前 3 个字（剩下 3 个字），赋值给 S2，即 S2=“有意思”；
  * 用 S2 匹配词典，没有找到匹配，去掉最后一个字，S2=“有意”；
  * 用 S2 匹配词典，没有找到匹配，去掉最后一个字，S2=“有”；
  * 用 S2 匹配词典，找到一个匹配的词“有”，从 S1 中切分出“有”这个词，S1=“意思”，从 S1 中取前 2 个字（剩下 2 个字），赋值给 S2，即S2=“意思”；
  * 用 S2 匹配词典，找到一个匹配的词“意思”，从 S1 中切分出“意思”这个词，S1=“”，结束处理。

#### 逆向最大匹配算法

逆向最大匹配法和最大匹配法的原理一样，只是对字符串的处理方向不一样。逆向最大匹配法从被处理句子的末端开始匹配扫描，每次取最末端的 k 个字（k
是词典中最长的词的字数）作为匹配字符串。用这个匹配字符串查词典，如果词典中存在这个词，则查找成功，将匹配的词从句子中切分出来。如果匹配失败，则去掉匹配字段最前面的一个字，将剩下的
k−1 个字组成的词作为匹配字符串，继续查词典。如果还是查找失败，则再去掉匹配字段最前面的一个字，将剩下的 k−2
个字组成的词作为匹配字符串，继续查词典。如此重复，直到匹配成功，切分出一个词，完成一轮匹配。然后再从句子中取最末端的 k 个字继续处理，直到完成整个句子。

可以看出来，逆向最大匹配算法在匹配字符串的处理方法上与正向最大匹配算法刚好相反，整体的算法流程如下：

  * （1）待处理句子是否为空，如果为空，转（5）结束，否则转（2）继续处理；
  * （2）从后向前从待处理的句子中取 k 个字作为匹配字符串，k 是词典中最长词条中汉字的个数；
  * （3）从词典中查找匹配字符串，如果找到，就将此匹配字符串切分为一个词，并把这个词从句子中切掉，转（1）继续处理，如果没有找到匹配，转（4）继续处理；
  * （4）如果匹配字符串不为空，则将匹配字符串最前面一个字删除，转（3）继续处理，否则转（5）结束处理；
  * （5）如果待处理的句子不为空，则返回失败，否则，返回成功，并输出切分的词。

接下来还是用“计算机编程有意思”这句话作为例子，介绍一下逆向最大匹配算法的处理过程。同样假设有一个很全面的词典，词典中最长的词条是 5
个汉字，按照上述算法流程对这个句子进行处理：

  * 原始句子 S1=“计算机编程有意思”，匹配字符串 S2，从 S1 中取后 5 个字，赋值给 S2，即 S2=“编程有意思”；
  * 用 S2 匹配词典，没有找到匹配，去掉最前面一个字，S2=“程有意思”；
  * 用 S2 匹配词典，没有找到匹配，去掉最前面一个字，S2=“有意思”；
  * 用 S2 匹配词典，没有找到匹配，去掉最前面一个字，S2=“意思”；
  * 用 S2 匹配词典，找到一个匹配的词“意思”，从 S1 中切分出“意思”这个词，S1=“计算机编程有”，从 S1 中取后 5 个字，赋值给 S2，即 S2=“算机编程有”；
  * 用 S2 匹配词典，没有找到匹配，去掉最前面一个字，S2=“机编程有”；
  * 用 S2 匹配词典，没有找到匹配，去掉最前面一个字，S2=“编程有”；
  * 用 S2 匹配词典，没有找到匹配，去掉最前面一个字，S2=“程有”；
  * 用 S2 匹配词典，没有找到匹配，去掉最前面一个字，S2=“有”；
  * 用 S2 匹配词典，找到一个匹配的词“有”，从 S1 中切分出“有”这个词，S1=“计算机编程”，从 S1 中取后 5 个字赋值给 S2，即 S2=“计算机编程”；
  * 用 S2 匹配词典，没有找到匹配，去掉最前面一个字，S2=“算机编程”；
  * 用 S2 匹配词典，没有找到匹配，去掉最前面一个字，S2=“机编程”；
  * 用 S2 匹配词典，没有找到匹配，去掉最前面一个字，S2=“编程”；
  * 用 S2 匹配词典，找到一个匹配的词“编程”，从 S1 中切分出“编程”这个词，S1=“计算机”，从 S1 中取后 3 个字（剩下 3 个字），赋值给 S2，即 S2=“计算机”；
  * 用 S2 匹配词典，找到一个匹配的词“计算机”，从 S1 中切分出“计算机”这个词，S1=“”，结束处理。

#### 算法分析

由于汉语中偏正结构较多，一般来说，使用逆向最大匹配算法比正向最大匹配算法的准确率高一点，在不考虑其他辅助方法的情况下，单纯使用正向最大匹配的错误率为
1/169，单纯使用逆向最大匹配的错误率为
1/245（我不是语言专家，以上数字来自网络）。当然，这些都是相对的，比如这句话：南京市长江大桥，正向最大匹配算法切分的结果是：

南京市 / 长江 / 大桥

逆向最大匹配的结果是：

南京 / 市长 / 江大桥

是否有人叫“江大桥”呢？很有可能，但是显然南京市的市长不是江大桥，这正是最大匹配法的软肋（无论是正向还是逆向），因此实用的分词算法都不会单纯使用词典匹配的方法。

### 计算机的字符编码

因为要处理汉字了，所以这里要说说 C++ 的字符编码，也就是各种乱码问题，先来看一段代码：

    
    
    //C++ 代码：    
        std::string test_string = "我是猪";
        std::reverse(test_string.begin(), test_string.end());
        std::cout << test_string << std::endl;
    
    //C 代码:
        char s[] = "我是猪";
        strrev(s);
        printf("%s\n", s);
    

std::reverse() 是标准库的算法，就是将容器中的元素逆序，对于 std::string
字符串来说，就是将字符串逆序，那么你是不是开心地认为输出结果是：“猪是我”？但是实际情况是：

![enter image description
here](https://images.gitbook.cn/04be49e0-13ec-11e9-9eb4-ed144f53659c)

图（1）带有汉字的 C++ 字符串的逆序

这就是传说中的“乱码”，因为在 C/C++ 语言中，默认的字符串存放格式是 MBCS 格式，即 Multi-Byte Chactacter
System（多字节字符系统），可以理解这是一种字符编码格式。这种字符串中的英文字符，或标准 ASCII 码表中小于 128
的可见字符，占一个字节，对于像汉字这样的字符集中的字符，一个汉字占两个字节（一般是汉字的区位码）。

MBCS 区分 ASCII 和汉字的方法就是判断一个字节的最高位是否为 1，如果不是，说明这个字符是个标准 ASCII 表中的字符（因为可见字符的
ASCII 码小于 128），占一个字节；如果一个字节的最高为位是 1，则说明这个字节和后面的一个字节一起组成一个 16 位的字符，也就是一个汉字。

这样大家就能理解我们按字节逆序一个字符串，会导致乱码的原因了吧，因为汉字的两个字节被拆乱了。有一些不靠谱的资料也会提到类似“一个英文字符占一个字节、一个中文字符占两个字节”之类的信息，你要知道，只有
MBCS 格式的字符串才是这样，其他格式的字符串就不一定了，比如各种 Unicode 编码格式。

Unicode 编码诞生的目的是为了解决各种语言的文字统一编码问题，最初的 Unicode 编码是 16 比特编码，也就是不管什么文字，都用 16
比特进行统一编码。也就是说，不管什么字符，都用 2 个字节表示，对于英文字符 A，其编码就是 0x0041，这样编在字符串中，0x00
会被认为是字符串的结束标志，因此在处理字符串时，一定要知道其编码格式才能正确处理，否则就会出现各种异常现象。

实际上，Unicode 编码后来还发展了很多格式，除了 UTF-16，还出现了能表示更大字符集的 UTF-32，还有为了提高字符存储效率的变长字符编码
UTF-8，这一课的算法要处理汉字，我们选择了最简单的 16 比特编码宽字符集。在 C 和 C++ 语言中，它的数据类型是
wchar_t，标准库中对应的字符串是 std::wstring。再看这段代码：

    
    
        std::wstring test_string = L"我是猪";
        std::reverse(test_string.begin(), test_string.end());
        std::wcout << test_string << std::endl;
    

这样就能输出我们希望的“猪是我”了。

### 算法实现

#### 词典和词典匹配

最大匹配算法无论是正向还是逆向，其实现都很简单，唯一需要啰嗦的就是词典的组织了。关于词典实际上有很多高效的查找和匹配算法，这里用最简单的代码实现一种根据词条长度分类管理词典的方法，词典匹配的时候，并不需要完整的遍历所有的词，如果匹配字符串只有两个字，就没有必要遍历一个字的单词和超过两个字的词。因此，按照词条长度分类管理是首先会想到的方法。

按照词条长度分类管理有很多种方法，这里为了用尽量少的代码演示算法，我用了
std::map，当然，也可以用数组来组织，然后利用数组下标的技巧管理各种长度的词条。我这样组织词典的数据结构：

    
    
    typedef struct
    {
        int max_len;
        std::map<int, std::vector<std::wstring>> words;
    }WORD_DICT;
    

每个长度的词条组织在一个 `std::vector<std::wstring>` 中，这是一个字符串数组，基于这个模型的词条匹配算法大致是这样实现的：

    
    
    bool LookupDict(const WORD_DICT& dict, std::wstring& word)
    {
        int length = word.length(); //根据词长选择对应的词集
        for (auto& ws : dict.words.at(length))
        {
            if (ws.compare(word) == 0)
            {
                return true;
            }
        }
    
        return false;
    }
    

dict.words.at(length) 得到长度 length 对应的那个
`std::vector<std::wstring>`，然后用一个循环遍历这个 `std::vector<std::wstring>`，对每一个词条与
word 进行匹配 ，找到就返回 true，否则返回 false。

#### 正向最大匹配算法实现

从算法流程的描述可以看出来，这个算法整体框架是个两重循环，第一层循环是对被处理字符串（s1）是否处理完的判断和处理，第二层循环是对匹配字符串（s2）的判断和处理。为了使代码更容易理解，我们将对匹配字符串（s2）的处理提取到一个独立的函数中，对匹配字符串（s2）的处理就是查词典，如果查不到就去掉最后一个字，然后再查，直到
s2 成为空串。

    
    
    std::pair<bool, std::wstring> MatchWord(std::wstring& s2, const WORD_DICT& dict)
    {
        while (!s2.empty())
        {
            if (LookupDict(dict, s2)) //查词典
            {
                return { true, s2 };
            }
            else
            {
                s2.pop_back(); //从 s2 中删除最后一个字
            }
        }
    
        //s2 都空了也没匹配到词？可能是词典有问题
        return { false, L"" };
    }
    

如果匹配字符串最终能匹配到一个词，就返回这个匹配到的词，返回的结果在 `std::pair<bool, std::wstring>` 的 second
属性中。

最后，正向最大匹配算法的实现：

    
    
    bool MaxMatching(const std::wstring& sentence, const WORD_DICT& dict, std::vector<std::wstring>& words)
    {
        std::wstring s1 = sentence;
    
        while (!s1.empty())
        {
            int s2_len = (s1.length() > dict.max_len) ? dict.max_len : s1.length(); //剩下的句子够长就取前 5 个字，不足 5 个字就全取出来
            std::wstring s2 = s1.substr(0, s2_len);
            auto mr = MatchWord(s2, dict);
            if (!mr.first)
            {
                return false;
            }
    
            words.push_back(mr.second); //匹配到一个词
            s1 = s1.substr(mr.second.length()); //将这个词从句子前面切分出来
        }
    
        return true;
    }
    

对待处理的句子 sentence 的分词结果存储在 words 中，这是一个字符串数组，依次存放切分出来的词。

#### 逆向最大匹配算法实现

逆向最大匹配算法基本框架和正向最大匹配算法一样，只是处理的细节不同，主要就是一些字符串处理函数的使用与正向最大匹配算法的使用不同。

    
    
    std::pair<bool, std::wstring> ReverseMatchWord(std::wstring& s2, const WORD_DICT& dict)
    {
        while (!s2.empty())
        {
            if (LookupDict(dict, s2)) //查词典
            {
                return{ true, s2 };
            }
            else
            {
                s2 = s2.substr(1); //从 s2 中删除第一个字
            }
        }
    
        //s2 都空了也没匹配到词？可能是词典有问题
        return{ false, L"" };
    }
    
    bool ReverseMaxMatching(const std::wstring& sentence, const WORD_DICT& dict, std::vector<std::wstring>& words)
    {
        std::wstring s1 = sentence;
    
        while (!s1.empty())
        {
            int s2_pos = (s1.length() > dict.max_len) ? s1.length() - dict.max_len : 0; //这里不是长度了，是子串的开始位置
            std::wstring s2 = s1.substr(s2_pos); //从 s2_pos 开始的子串
            auto mr = ReverseMatchWord(s2, dict);
            if (!mr.first)
            {
                return false;
            }
    
            words.push_back(mr.second); //匹配到一个词
            s1 = s1.substr(0, s1.length() - mr.second.length()); //将这个词从句子中切分出来
        }
    
        return true;
    }
    

### 总结

这节课介绍了一种基于词典的分词算法，原理很简单，算法实现也很简单，只要词典给力，切分的效果还行。如果要提高切分的准确性，需要引入更复杂的理论，常见的方法就是在词典的词频上做文章，此类方法也叫“基于词的频度统计的分词方法”，其原理就是在句子的上下文中，相邻的字同时出现的次数越多，就越可能构成一个词，因此字与字相邻出现的概率或频率能较好地反映词的可信度。常见的统计模型有
N 元文法模型（N-gram）、隐马尔科夫模型（Hidden Markov Model，HMM）等，有兴趣的读者可找相关的资料研究研究。

中科院计算机所的张华平博士曾经发布过一套名为 ICTCLAS
分词系统的开源代码库，大家可以找来研究研究，看看工程上可用的分词系统是如何工作的，它的算法内核是怎么实现的。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

