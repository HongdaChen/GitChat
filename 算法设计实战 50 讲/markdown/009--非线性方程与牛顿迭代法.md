>
> 在数值分析领域中，人们通常使用迭代法、逼近法和做图等方法来求解一些复杂问题的近似解，其中迭代法是一类利用递推公式或循环算法通过构造序列来求问题近似解的方法，把这种迭代求解数学问题的方法直接体现在算法中，就可以认为是设计领域中的迭代法。1-2
> 至 1-4
> 课介绍了迭代法的原理以及将迭代的思想应用到算法设计中，需要确定三个关键点，这三个关键点确定后，算法的轮廓就出来了。这一课我们以二分逼近法和牛顿迭代法（Newton's
> Method）两个算法为例，再次讲解一下如何结合题目的特点用迭代法设计出对应的算法实现。

### 代数法求解低阶非线方程

用代数方法求一元非线性方程的解的方法有很多，常用的方法有开平方法、配方法、因式分解法、公式法等，近似求解的方法有作图法以及各种迭代法。像开平方法、配方法和因式分解法这样的代数方法只适用于一些特殊的一元非线性方程，使用范围有限。而公式法则只适用于低阶方程，到目前为止，除了少数特殊形式的五阶一元非线性方程之外，五阶及五阶以上的非线性方程被认为是没有求解公式的。

代数法求解方程虽然准确性好、精度高，但是不利于编制计算机程序，所以在数值分析领域，常用各种迭代法求解一元非线性方程。迭代法方法简单，适合计算机求解，甚至可以被固化到硬件芯片中，计算效率并不比代数法差。常用的求解一元非线性方程的方法有二分逼近法和牛顿迭代法，这一课就分别介绍如何设计和实现这两种迭代法的程序代码。

### 二分逼近法

先介绍一下二分逼近法的数学原理。对于实数域的函数 $f(x)$，如果存在实数 $k$，使得 $f(k) = 0$，则 $x = k$ 就是函数 $f(x)$
的零点。如果函数 $f(x)$ 是连续函数，且在区间 [a,b] 上是单调函数，只要 $f(a)$ 和 $f(b)$ 异号，就说明在区间 [a,b]
内一定有零点，此时就可以使用二分逼近法近似地找到这个零点。假设在上述区间上，$f(a) < 0，f(b) > 0$，则可按照以下过程实施二分逼近法：

(1)如果 $ f((a+b)/2) = 0$，则 $(a+b)/2$ 就是零点；

(2)如果 $ f(a)\cdot f((a+b)/2) < 0$，则零点在区间 $[a, (a+b)/2]$ 上，令 $b =
(a+b)/2$，继续从第(1)步开始判断；

(3)如果 $ f(a)\cdot f((a+b)/2) > 0$，则零点在区间 $[(a+b)/2, b]$ 上，令 $a =
(a+b)/2$，继续从第(1)步开始判断。

从上述过程可以看到，每次运算之后，区间范围就缩小一半，呈现线性收敛速度。由以上分析可知，数学意义上的二分逼近法可以采用迭代法的思想设计算法实现。

#### 二分逼近法算法实现

回忆一下我们在基础部分讲的迭代法的三个要点，它们分别是迭代变量、迭代递推关系公式和迭代终止条件。首先确定迭代变量，迭代变量是由迭代关系式确定的。一般情况下，迭代变量就是计算结果
x，但是二分逼近法的迭代关系式不是计算结果 x 的迭代关系，而是逼近区间 $[a, b]​$ 的关系，所以这个算法的迭代变量就是表示区间范围的 $a​$ 和
$b​$ 两个变量。接下来是确定迭代递推关系，其递推关系公式就是前面描述的实施过程中的(2)和(3)两步给出的 $a​$ 和 $b​$
两个量的递推更新计算方法，即：

$[a, b] = \left\\{\begin{matrix} [a,\frac{(a+b)}{2}] & f(a)\cdot
f(\frac{(a+b)}{2}) < 0\\\ \\\ [\frac{(a+b)}{2},b] & f(a)\cdot
f(\frac{(a+b)}{2}) > 0 \end{matrix}\right.$

最后是迭代退出条件，退出条件其实就是：$f((a+b)/2) = 0$。但是因为浮点数精度很高，在计算机系统中直接按照 $f((a+b)/2) = 0$
判断是很难的，有时候进行很多次迭代也无法满足这个条件，更何况由于数据存储方式的原因，计算机无法对两个浮点数直接做相等的判断，通常只要
$f((a+b)/2)$ 在精度允许的范围内逼近 0 时就可以结束二分逼近过程，将 $(a+b)/2$ 作为零点，在精度和计算速度二者之间取折中。除了判断
$f((a+b)/2)$ 的值，还可以根据区间 $[a, b]$ 的大小确定结束条件，在精度允许的范围内，只要区间范围小于精度阈值，也可以直接取
$(a+b)/2$ 作为零点。确定以上三个条件，用迭代法实现二分逼近法求解一元高次方式的算法实现就很简单了：

    
    
    const double PRECISION = 0.000000001;
    
    typedef double (*FunctionPtr)(double);
    
    double DichotomyEquation(double a, double b, FunctionPtr f)
    {
        double mid = (a + b) / 2.0;
        while((b - a) > PRECISION)
        {
            if(f(a) * f(mid) < 0.0) //应用迭代递推关系
            {
                b = mid;
            }
            else
            {
                a = mid;
            }
            mid = (a + b) / 2.0; //更新迭代变量
        }
    
        return mid;
    }
    

DichotomyEquation() 函数的 a 和 b 两个参数是区间范围 $[a,b]$，f 是求根方程 $f(x) = 0$ 中 $f(x)$
的具体实现，对于 $f(x) = 2x^{2} + 3.2x - 1.8$，需要这样提供 f 参数：

    
    
    double func(double x)
    {
        return (2.0*x*x + 3.2*x - 1.8);
    }
    

二分法的局限性就是不能计算复根和重根，需要借助其手段确定零点所在区间。设方程为 $f(x) = 2x^{2} + 3.2x - 1.8$，求根精度是
PRECISION = 0.000000001，在 [-0.8,8.0] 区间上求解 $x$ = 0.440967364，while 循环共做了 34
次循环迭代。

除了求解非线性方程，二分逼近法还可以用来求解平方根（或 n 次方根），对于 $x^{2} = n$，只需将其转化为方程 $f(x) = x^{2} -
n$，就可以将求平方根转化成求这个方程的解。同样的道理，我们下面要介绍的牛顿迭代法也可以做类似的事情。

### 牛顿迭代法

牛顿迭代法又称为牛顿－拉弗森方法（Newton-Raphson
Method），它是一种在实数域和复数域上近似求解方程的方法。既然是迭代法，那么牛顿迭代法的算法实现肯定适合用迭代法模式。

![enter image description
here](https://images.gitbook.cn/d8cbeb30-b284-11e8-a795-a516a53f2f5b)

图（1） 牛顿迭代法原理示意图

牛顿迭代法使用函数 $f(x)$ 的泰勒级数的前面几项来寻找方程 $f(x) = 0$ 的根，先介绍一下牛顿迭代法的原理。首先，选择一个接近函数
$f(x)$ 零点的 $x _{0}$ 作为迭代初始值，计算相应的 $f(x_ {0})$ 和切线斜率 $f'(x _{0})$（这里 $f'(x)$
是函数 $f(x)$ 的一阶导函数）。然后我们经过点 ($x_ {0}$，$f(x _{0})$) 做一条斜率为 $f'(x_ {0})$ 的直线，该直线与
x 轴有一个交点，可通过以下方程的求解得到这个交点的 x 坐标：

$$ f(x _{0})= (x_ {0}-x)\cdot f'(x_{0}) $$

求解这个方程，可以得到：

$$ x = x _{0} - f(x_ {0})/f'(x_{0}) $$

我们将新求得的点的 $x$ 坐标命名为 $x _{1}$，通常 $x_ {1}$ 会比 $x _{0}$ 更接近方程 $f(x) = 0$
的解。因此我们现在可以利用 $x_ {1}$ 开始下一轮迭代。根据上述方程中 $x _{1}$ 和 $x_ {0}$ 的关系，可以得到一个求解 $x$
的迭代公式：

$$ x _{n+1} = x_ {n} - f(x _{n})/f'(x_ {n}) $$

这就是牛顿迭代公式。目前已经证明，如果 $f(x)$ 的一阶导函数 $f'(x)$ 是连续函数，并且待求的零点 $x$ 是孤立的，则在零点 $x$
周围存在一个区间，只要初始值 $f'(x_{0})$ 位于这个区间，牛顿法迭代必定收敛。并且，只要
$f'(x)≠0$，牛顿迭代法将具有平方收敛的性能。这意味着每迭代一次，结果的有效数字将增加一倍，这比二分逼近法的线性收敛速度快了一个数量级。

#### 导函数的求解与近似公式

牛顿迭代公式中需要计算函数的导数，直接根据原函数推出一阶导函数，然后计算导函数的值有点困难，一般都是利用导数的数学原理，使用近似公式直接求函数在某一点的导数。导数的数学定义是：当函数
$y = f(x)$ 的自变量 $x$ 在一点 $x _{0}$ 上产生一个增量 $Δx$ 时，函数输出值的增量 Δy 与自变量增量 Δx 的比值在
$Δx$ 趋于 0 时的极限值。如果这个极限值存在，则这个值就是 $f(x)$ 在 $x_ {0}$ 处的导数，记做
$f'(x_{0})$。用公式定义即为：

$f'(x_{0}) = \lim_{\Delta x \to 0}\frac{\Delta y}{\Delta x} = \lim_{\Delta x
\to 0}\frac{f(x_{0}+\Delta x) - f(x_{0})}{\Delta x}$

极限是在无穷小或无穷大的尺度上考察函数的一些特性，在计算机上无法表达无穷小和无穷大，只能在数据能表达的合法范围内，在满足计算精度的情况下通过最小值来近似模拟。如果无法精确计算导数
$f'(x _{0})$，我们仍然采用近似计算方法得到一个满足精度的模拟值。根据导数的数学定义，如果不考虑极限，这个值就是 $Δy/Δx$ 的值，在 $x_
{0}$ 附近一个非常小的尺度上选择 $Δ$，可以得到近似的导数值。我们选择按照以下近似公式计算导数值：

$f'(x_{0}) = \frac{f(x_{0} + 0.000005) - f(x_{0} - 0.000005)}{0.00001}$

计算函数 f 在 $x$ 附近的一阶导数值的算法可定义为：

    
    
    double CalcDerivative(FunctionPtr f, double x)
    {
        return (f(x + 0.000005) - f(x - 0.000005)) / 0.00001;
    }
    

#### 牛顿迭代法算法实现

根据牛顿迭代法的迭代关系公式，牛顿迭代法的迭代变量就是要求的结果 $x$
，迭代的初始值可以选择一个比较接近近似解的值，对于单调区间来说，这个值可以是任意值，甚至可以是区间边界值，迭代递推关系就是上面数学原理部分给出的迭代公式，迭代终止条件就是找到一个精度符合要求的近似解。判断迭代变量是否就是符合精度的解的方法就是计算最近两个迭代的值，看其差值是否小于迭代精度差值的要求。根据迭代递推关系，用循环实现迭代递推最简单。设计算法时，为了防止因为迭代不收敛导致的死循环，一般还可以增加一个迭代退出条件，即设置一个迭代次数上限。

    
    
    double NewtonRaphson(FunctionPtr f, double x0) 
    {
        double x = INVALID_VALUE;
        int count = 0;
        do
        {
            double x1 = x0 - f(x0) / CalcDerivative(f, x0); //应用迭代递推关系
            if (fabs(x1 - x0) < PRECISION)
            {
                x = x1;
                break;
            }
            x0 = x1;  //更新迭代变量
            count++;
        } while (count < MAX_RUN_LOOP);
    
        return x;
    }
    

参数 $x_{0}$ 是迭代初始值。选择与上面相同的例子函数，并将迭代初始值设置为区间最大值 8.0，使用牛顿迭代法也只需要 7
次迭代，就可以得到和二分逼近法精度一样的近似解。选择初始值 -8.0 从另一个方向计算，还可以得到另一个解 $x$ =
-2.040967365，计算这个解也只需要 6 次迭代，可见牛顿迭代法的收敛速度是超线性的。

### 总结

使用迭代法，需要首先确定问题是否存在迭代关系，如果存在迭代关系，就尝试确定迭代算法需要的三个关键要素，这三个要素确定了，算法的框架就有了，剩下的问题就是确定用何种代码结构实现的迭代递推关系以及如何更新迭代变量。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

