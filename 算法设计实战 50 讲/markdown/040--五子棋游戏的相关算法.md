>
> 五子棋的复杂程度要超过之前介绍的奥赛罗棋，它不仅规则多，概念也多，比如“冲二”、“冲三”、“活二”、“三三禁手”、“四四禁手”等，对这些模型的判断其算法非常重要，如果不能正确判断这些模型，估值函数就无法实现。这一课我们将介绍一些五子棋游戏的算法，当然，也包括棋盘的数据模型设计。

### 棋盘模型

五子棋（Five In a Row，FIR）流行非常广泛，在不同的国家有不同的名称，标准的五子棋棋盘是 15 × 15 大小，用数字 1 ~ 15
标识棋盘的行，用字母 A ~ O 标识棋盘的列，棋子和围棋一样有黑白两种颜色，一般可以用围棋的棋盘玩五子棋。下棋的双方轮流在 15 × 15
条线的交叉点上落子，先在横、竖和斜线方向上形成五子连线的一方获胜。

上一课介绍奥赛罗棋游戏的棋盘数据模型时，使用了 Warren Smith
棋盘状态模型，现在五子棋游戏也继续使用这个模型，五子棋游戏的棋盘和奥赛罗棋游戏的棋盘有很大的差异，需要对 Warren Smith
的模型做适当的修改。标准的五子棋游戏是 15 × 15 的棋盘，但是我们演示 AI 算法的程序使用 9 × 9
的小棋盘，一方面是为了便于展示算法的实现效果，另一方面是加快计算机“象棋”的速度，毕竟棋盘减小了，需要的计算量会呈几何级数减少。9 × 9 的小棋盘用
Warren Smith 模型表示，需要一个长度为 111 的一维数组表示黑白棋的棋盘与棋子状态，其中 81 个是棋盘上的位置，30
个是标志位或哨兵位。111 个数组元素中前 10 个和后 11 个是标志位，中间每间隔 9 个 x 位置插入一个标志位
d，这个模型各个位置的逻辑结构如下面的阵列所示：

    
    
    d d d d d d d d d d 
    d x x x x x x x x x 11 
    d x x x x x x x x x 21
    d x x x x x x x x x 31
    d x x x x x x x x x 41
    d x x x x x x x x x 51
    d x x x x x x x x x 61
    d x x x x x x x x x 71
    d x x x x x x x x x 81
    d x x x x x x x x x 91
    d d d d d d d d d d d
    

字符 d 标识的是插入的标志位，用特殊值 DUMMY 表示。"字符 x 标识的是棋盘上棋子状态，算法用 PLAYER_A 和 PLAYER_B
分别表示双方的棋子，用 PLAYER_NULL
表示空位置。棋盘大小调整了，方向数组的步进量也需要调整。五子棋的搜索方式比较简单，它是从一个位置开始，沿着横、竖和两条斜交叉线方向上前后搜索是否有连续出现的情况，因此方向步进数组只需
4 个步进值即可，在某个方向上正向搜索则累加步进值，反向搜索则累减步进值。根据 Warren Smith 模型的关系，适用于 9 × 9
棋盘的方向步进数组调整如下：

    
    
    const int dir_step[] = {1, 9, 11, 10};
    

模型中的元素与实际棋盘上的行和列的坐标换算关系也调整为：

    
    
    square(row,col) = board[11+col+row×10]   （0<= row,col <=8）
    

### 各种棋型算法

作为一种策略类的游戏，五子棋也有很多“型”，有的是判断棋局形式的“型”，按照五子棋的术语一般称为“冲四”、“活三”等。五子棋和多数棋类游戏一样，也有先手优势，有一些先手型基本上是必赢的棋型，为了公平游戏，要禁止先手玩家下这些棋型。因此，在五子棋里还有一些禁手型，常见的禁手型按照五子棋的术语一般称为“三三禁手”、“四四禁手”等。

在五子棋中，单个的棋子对对手是没有威胁的，从“冲二”和“活二”开始，对手两个连在一起的棋子就开始形成威胁。三个连在一起的棋子威胁更甚一步，如果不及时干预，形成四连子就非常危险了，如果对手形成了“活四”，除非你这手也有“冲四”或“活四”可以直接赢棋，否则就只能投子认输。五子棋游戏算法，需要能够判断这些棋型，这一节将介绍几种常见的棋型判断算法。

#### 五子连线

五子连线是判断输赢的基本型，玩家每次落子，都要从落子位置进行搜索，看看是否在某个方向上连成五子，如果是的话，就要直接判赢，并结束比赛。这个检查算法的原理很简单，就是从落子位置开始，在一条线上沿正向和反向分别搜索与落子棋子相同的棋子个数，如果从正、反两个方向搜索到的相同棋子个数之和大于或等于
5，则判定有棋手完成了五子连珠。方向是通过什么决定的呢？当然是步进值了，不同的步进值代表不同的方向。

    
    
    bool GameState::CheckLinefive(int cell, int dir_step, int player_id)
    {
        int count = 1;
        int ct = cell - dir_step;
        while(m_board[ct] == player_id)
        {
            count++;
            ct -= dir_step;
        }
    
        ct = cell + dir_step;
        while(m_board[ct] == player_id)
        {
            count++;
            ct += dir_step;
        }
    
        return (count >= 5);
    }
    

向前后两个方向搜索，可能遇到自己的棋子，也可能遇到对手棋子、空位置、或边界（哨兵位），不管这些，while(m_board[ct] ==
player_id) 的判断总是能够安全地退出循环。CheckLinefive()
只是完成了一个方向上的搜索，用方向数组做个循环就可以判断在各个方向上是否有五连子了。

    
    
    bool GameState::CheckFiveInRow(int cell, int player_id)
    {
        for(int i = 0; i < DIR_COUNT; i++)
        {
            if(CheckLinefive(cell, dir_step[i], player_id))
            {
                return true;
            }
        }
    
        return false;
    }
    

#### 扫描线的数据模型

![](https://images.gitbook.cn/840bfc10-078a-11e9-846c-df2cdd71336c)

图（1）棋盘线与数据模型位置关系示意图

五子棋的棋型识别是基于横线、竖线和正反两条斜线共四个方向的扫描线，横线和竖线比较规整，但是正反两条斜线比较难处理，这正是我们放弃二维棋盘模型的原因。根据数据模型定义，将扫描线定义为一个起点和一个方向步进量组成的二元组，起点是棋盘上的点对应的数据模型中的位置（一维数组的下标），步进量是根据方向而定的一个偏移量，这个偏移量可以参考
dir_step 数组。扫描的方法就是从起点开始，通过叠加步进量移动到下一个点，逐次叠加步进量直到遇到哨兵位，这期间的点就是这条线上的点。

图（1）是棋盘上的线与数据模型的位置关系示意图，图中每个圆圈代表 9 × 9
棋盘上的一个位置，圆圈中的数字是这个棋盘位置在数据模型中的位置。从图中可以看到，九条横线的起点分别是 11、21、31、41、51、61、71、81、91
这九个点，其方向步进量是 1；九条竖线的起点分别是 11、12、13、14、15、16、17、18、19 这九个点，其方向步进量是 10。

> 斜线需要注意一下，四个角上的斜线如果棋子总数小于 5 是可以排除掉的，因为这些线上肯定构不成五子连珠。

以正斜线为例，16、17、18、19 这四个起点开始的斜线，总棋子数小于 5（16 这个点开始的斜线只有 16、27、38、49
四个点，其他点则更少），不值得展开扫描，同理，61、71、81、91 这四个点也不用扫描。因此，正斜线方向的起点是
11、12、13、14、15、21、31、41、51 这九个点，其方向步进量是 11，同理，反斜线方向的起点是
15、16、17、18、19、29、39、49、59 这九个点，其方向步进量是 9。

按照这个思路，我们先给出扫描线的数据模型：

    
    
    typedef struct tagLines
    {
        int line_s[MAX_LINE_S]; //起点数组
        int off_dir; //步进量
    }LINES;
    

根据这个数据模型，可以事先准备好扫描线表：

    
    
    LINES line_cpts[4] = 
    {
        { {11,21,31,41,51,61,71,81,91},  1  },
        { {11,12,13,14,15,16,17,18,19},  10 },
        { {11,12,13,14,15,21,31,41,51},  11 },
        { {15,16,17,18,19,29,39,49,59},  9  }
    };
    

根据这个数据模型和扫描线表，对棋盘的分析和评估就转化为对所有扫描线的分析：

    
    
    int GameState::SearchPatterns(EvaluatorData &ev_ata)
    {
        for(int i = 0; i < COUNT_OF(line_cpts); i++)   //每个方向
        {
            for(int j = 0; j < MAX_LINE_S; j++)   //每个方向 9 条线
            {
                AnalysisLine(line_cpts[i].line_s[j], line_cpts[i].off_dir, ev_ata);
            }
        }
    
        return 0;
    }
    

#### “冲”和“活”

棋型两端有界的棋称为“冲”，根据相连棋子个数可有“冲二”、“冲三”、“冲四”等棋型，图（2）就是黑棋“冲四”的两种棋型，与黑棋的一端直接接触的要么是白旗、要么是边界。要形成“冲”，还有一个条件，就是两个边界之间的棋子和空位数量之和不能少于
5 个，这很容易理解，假如两个边界之间即使全部是己方棋子，也不能形成五子连线，那这棋型就没有任何意义了。

![enter image description
here](https://images.gitbook.cn/932afca0-078a-11e9-846c-df2cdd71336c)

图（2）“冲四”棋型示意图

“活”的定义是棋型的两端都是无界约束（两端不和对手的棋子或边界直接接触），对于图（2）的棋型，如果两端不是白棋活边界，就成了“活四”，而图（3）则是“活三”的两种形式。除了两端是无界约束，“活”对相连棋子的个数，以及两端空位的数量也有要求。以图（3-a）所示的“活三”为例，除了要求两端为空位外，还要求其中一端至少有两个空位，即要求空位数至少有三个。图（3-b）所示的“跳活三”是另一种情况，加上中间空位也是至少需要三个空位。

![enter image description
here](https://images.gitbook.cn/9fe9c610-078a-11e9-ac74-815ffe53df3d)

图（3）“活三”棋型示意图

对“冲”的判断算法就是沿着扫描线开始扫描每个位置，当发现从某个位置开始己方棋子已经形成二连子棋型，则判断起始位置是否封闭，如果是则设置标志
pre_close = true，然后继续扫描并且记录己方棋子数和空位置数，直到遇到边界或对方棋子为止。在扫描过程中得到的己方棋子数和空位数之和只要大于
5，即可标记为“冲”，其中己方棋子个数就是“冲”数。

对“活”的判断算法与“冲”的判断算法类似，也是沿着扫描线开始扫描每个位置，当发现从某个位置开始己方棋子已经形成二连子棋型，则判断起始位置是否封闭，如果是则设置标志
pre_space = true，然后继续扫描并且记录己方棋子数和空位置数，如果遇到某个空位置时，己方棋子数和空位数之和大于
5，则标记为“活”，己方棋子的个数为“活”数。

对“冲”和“活”的判断，已体现在 AnalysisLine() 函数中，该函数比较长，大家可以通过 GitHub 更新代码，了解实现细节。

### 估值算法

在识别出棋型的基础上，就可以给不同的棋型指定评估分数，然后按照一定的计分规则给一个棋局打分，从而完成棋局估值的量化计算。一般来说，形成五连子就是胜局，可以给一个很高的分数，标识这是个胜局。除了胜局，还有一些必胜局，比如“活四”、两个“冲四”或者“冲四”+“活三”这种棋型，即使对手干预，下一手（或两手）后必然能形成胜局的情况，也给一个比较高的分数。除此之外，对各种有利的棋型也给予不同的计分，整体的计分规则如下：

  * 五子连珠计 10000 分
  * “活四”、“双冲四”、“冲四活三”这三种情况分别计 9900 分
  * “双活三”、“双冲四”这两种情况分别计 9800 分
  * “活三冲三”、“冲四活三”这两种情况分别计 9700 分
  * “冲三”一次计 300 分
  * “活二”一次计 200 分
  * “冲二”一次计 50 分

除此之外，我们的估值算法还考虑位置分，对于五子棋游戏来说，边是比较差的位置，靠近边的一侧发展受限，除非迫不得已或谦让对手，一般情况下棋手都不会先靠边上落子。但是计算机“傻”，特别是在开局阶段，棋盘上的子很少，棋型的估值贡献为
0，此时计算机就会随机落子，有可能会落在边上。为了告诉计算机在这种情况下如何处理，我们给棋盘的每个点设置了位置分，边界上的点位置分是
0，越靠中间位置分越高，告诉计算机如果不知道怎么落子的时候，就往中间位置放。

    
    
    int posValue[BOARD_CELLS] = 
    {
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,1,1,1,1,1,1,1,0,
        0,0,1,2,2,2,2,2,1,0,
        0,0,1,2,3,3,3,2,1,0,
        0,0,1,2,3,4,3,2,1,0,
        0,0,1,2,3,3,3,2,1,0,
        0,0,1,2,2,2,2,2,1,0,
        0,0,1,1,1,1,1,1,1,0,
        0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0
    };
    

评估分超过 9000
的都是必胜棋局，在这种情况下根据棋手的情况直接返回分数，在其他情况下统计包括位置分在内的棋型得分。在上一节“棋型算法”介绍的棋型计算基础上，评估算法的实现就非常简单了，此处就不再列出代码，代码在
WzEvaluator 估值算子中，大家可以通过 GitHub 更新代码，了解实现细节。

### 禁手判断

“禁手”是一种特殊的棋型，如果将“禁手”理解为在一个可以落子的位置周围几个特定位置上不能同时有己方棋子，那么对“禁手”建模就非常简单了。以图（4）的“禁手”示意图为例，如果黑棋想在
x 位置落子，需要判断在几个黑棋位置是否都有黑棋，这些位置与 x
位置存在某种关系，根据棋盘数据模型，这种关系就是方向步进偏移。以图（4-a）左侧的“四四禁手”示意图为例，x 位置左侧的三个黑棋位置与 x
的方向步进偏移分别是 −1、−2 和 −3，x 位置下方的三个黑棋位置与 x 的方向步进偏移分别是 10、20 和 30。

![enter image description
here](https://images.gitbook.cn/af616df0-078a-11e9-ac74-815ffe53df3d)

图（4）“禁手”棋型示意图

根据上面的描述，我们将“禁手”的数据模型定义为：

    
    
    typedef struct tagForbiddenItem
    {
        int off_step[MAX_FORBIDDEN_PATTERN];
        int off_cnt;
    }FORBIDDEN_ITEM;
    

其中数组 off_step[] 记录了“禁手”棋型所限制的位置相对偏移量，off_cnt
是“禁手”棋型中限制位置的个数。根据这个数据模型，图（4-a）左侧的“四四禁手”可以量化为以下数据模型：

    
    
    { { -1,-2,-3,10,20,30 },  6 }
    

利用这个模型，判断“禁手”的算法实现就非常简单了，就是对于一个给定的位置，看看它周围偏移量对应的位置上是否有己方棋子。IsMatchSingleForbidden()
函数中 match_cnt 记录匹配的棋子个数，如果 match_cnt 与这个“禁手”模型中的棋子个数相等，则说明符合该“禁手”模型，是一个“禁手”。

    
    
    bool GameState::IsMatchSingleForbidden(FORBIDDEN_ITEM& item, int cell, int player_id)
    {
        int match_cnt = 0;
        for(int j = 0; j < item.off_cnt; j++)
        {
            int cf = cell + item.off_inc[j];
            if((cf >= 0) && (cf < BOARD_CELLS))
            {
                match_cnt += ((m_board[cf] == player_id) ? 1 : 0);
            }
        }
    
        return (match_cnt == item.off_cnt);
    }
    

根据五子棋规则，预先将各种“禁手”组织成一个“禁手”表，判断每个“禁手”模型相关位置上的己方棋子是否与“禁手”模型匹配，只要有一个“禁手”模型匹配，就说明这个落子违反禁手规则，不允许在这里落子。

    
    
    FORBIDDEN_ITEM forbidden_patterns[] = 
    {
        { { -1,-2,-3,10,20,30 }, 6 },
        { { -1,-10,1,2,10,20 },  6  },
        { { -10,-11,11,20 },     4  },
        { { -1,1,-10,10 },       4  }
    };
    

### 总结

这一课介绍了五子棋的一些相关算法，包括各种棋型和禁手的判断算法，作为一个复杂棋类游戏的一部分，这些算法都是基础，结合这些算法，加上之前介绍的搜索算法、哈希算法和置换表算法，能够帮助大家理解
GitHub 上的具体实现代码。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

