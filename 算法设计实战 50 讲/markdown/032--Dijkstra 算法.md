> Dijkstra
> 算法是有中文名字的，一般叫做“迪杰斯特拉算法”，该算法是求解单源最短路径问题的经典算法，算不上高效，但确实是最简单的算法。Dijkstra
> 算法并不难，很多算法书都有详细的说明，但是这些书基本上都是对着一个类似图（1）这样的图作为例子来演示算法。如果要理解算法的原理，通常这样做也就足够了，但是要实现一个可用的算法解决实际问题，还需要跨过几个门槛才行。首先要解决数据模型的问题，即需要定义一个能参与到算法运算中的数据结构，存放初始值、结果和运算过程中产生的中间数据；其次是将文字描述的算法原理解释成程序代码；最后是将运算结果转化成人类能理解的方式，或按照题目要求的方式输出出来。

![](https://images.gitbook.cn/adb439b0-f6a0-11e8-8ba9-9139bf384e15)

图（1）Dijkstra 算法示例

本课首先介绍一下算法的原理，但这不是本课的重点，本课的主要内容是引导读者从一个文字描述的算法理论开始，逐步分析、建模，最终将理论翻译成算法代码。在这个过程中，介绍分析的方法、建模需要考虑的问题以及算法实现用到的技巧，最后通过两个典型的算法比赛题目，验证我们所讲的建模和分析方法是否能解决最短路径问题的题目。

### Dijkstra 算法分析与设计

这里简单讲一下 Dijkstra 算法原理的分析，以及如何设计适合 Dijkstra 算法的数据模型。因为 Dijkstra
算法的原理不是重点，很多算法书都会详细介绍并进行正确性的证明，所以此处仅仅是用我的理解把原理描述出来，如果看其他的资料感觉晦涩，不妨看看我的描述是否更好理解一点。

#### Dijkstra 算法原理分析

Dijkstra 算法原理其实很简单，对于一个带权有向图 G=(V,E)，其中任意两个相连顶点 Vi 和 Vj
间的距离用权重表示为：w(Vi,Vj)，那么对于任意一个顶点到其他顶点的最短路径求解过程的描述如下。

（1）准备一个集合 T 存放当前已经找到最短路径的顶点集，再准备一个数组 dist 存放起始点到各个顶点的最短路径，即 dist[Vx] 表示起始点到顶点
Vx 的最短路径值。

（2）将 T 初始化为只包含起始点 S 的状态，即 T{S}，S 可以是任意一个顶点 Vx，比如 V1。初始化 dist 数组的值为起始点 S 到顶点 Vx
的边的权重，即 dist[Vx] = w(S,Vx)，如果起始点 S 到 Vx 没有路径相连（即不能直接到达），则将其值设置为无穷大。对于起始点 S，则设置
dist[S] = 0。

（3）对于所有不属于集合 T 的顶点 Vi，从 dist 数组中寻找最小值 dist[Vi]，这个最小值 dist[Vi] 就是起点到顶点 Vi
的最短路径，此时将顶点 Vi 加入到集合 T 中，完成一个顶点的选择。

（4）对于新加入的顶点 Vi，查看 Vi 能够到达的所有顶点，计算通过 Vi 到达其他顶点的路径长度是否比起始点直接到达该顶点的长度短，如果是，则替换
dist 数组中对应顶点的值。

（5）重复上述过程（3）、（4），直到集合 T 包含了所有顶点。

通过上述原理的描述，可以看出来这个算法需要遍历途中的所有顶点，并且是按照广度优先的方式遍历的。遍历采用的是迭代法，每个迭代完成一个顶点的处理，根据第（5）步的描述，这个迭代法可以用循环体的方式实现，其中第（3）和第（4）步是循环体的内容，第（5）是退出条件。根据第（3）步的描述，每次都从
dist 中寻找最小的那个值，说明此处使用了贪婪法的策略，即不考虑整体因素，就这一步来说，就只要最小的那个值。如果大家对这 5
个步骤的描述还有疑惑的地方，我们就以图（1）所示的有向图为例，给大家演示一下 Dijkstra 算法的求解运算过程：

![](https://images.gitbook.cn/d0970ac0-f6a0-11e8-84d7-dda2538adc04)

图（2）Dijkstra 算法求解运算过程

#### 准备数据模型

Dijkstra
算法适用于权值为非负数的有向图，要实现这个算法，绕不开图的定义，计算机的图论里一般采用两种方式描述图，一种是邻接表，另一种是邻接矩阵。通过对算法描述的理解，算法的第（2）步和第（4）步可能需要频繁地获取两个顶点之间的边的权重（距离）。如果采用邻接表的方式，则每次都要对邻接表进行遍历，会影响算法的效率；如果采用邻接矩阵的方式，则简单很多，矩阵中每个元素的值就是对应边的权重，算法实现的时候可以利用顶点下标直接从二维数组中获取该值。

每个适用 Dijkstra
算法的例题都有各自不同的描述方法，但是这些描述背后，无怪乎都是要提供算法所需的参数信息，而这些信息其实就是两个内容：问题抽象之后的那个“图”和求解最短路径的起始点。我们定义数据结构
Problem_T 用于描述问题：

    
    
    typedef struct
    {
        int vertexs;  //题目给出的实际顶点个数
        int w[MAX_VERTEX][MAX_VERTEX]; //图的权重矩阵，表示顶点间的距离
        int start_vertex;   //起始点编号
    }Problem_T;
    

选择了图的表示方法，有了 Problem_T 的定义，那么，现在问题来了，顶点怎么定义？显然，我们无法像图（1）那样让计算机处理 V1、V2
这样的名字，因此选择用数字给顶点编号，这也是算法中常用的问题抽象方法。我们的数据定义中使用了一维和二维数组，因为很多编程语言的数组下标都是从 0
开始的，所以顶点选择从 0 开始的数字进行编号，在代码处理上能带来很大的好处。

根据第（1）步的描述，实现 Dijkstra 算法还需要一个集合 T 和 dist 数组。集合可以用多种数据结构描述，C++ 和 Java 都支持
set，可以用于集合操作，但是对于这个算法来说，对集合 T 的操作很简单，就是存放所有已经知道最短路径的顶点，原本用数组表示集合 T
实现起来更简单。dist 原本用数组就可以简单描述，但是考虑到第（3）步中取最小值 dist[Vi] 时需要判断 Vi 是否已经在集合 T
中，此时如果用遍历集合 T 的方式判断每个 dist 对应的顶点是否已经在集合中，算法实现起来比较低效。为此，我们给每个 dist[Vi]
再附加一个属性，即除了表示起始点到 Vi 的最小距离值之外，再表示一下 Vi 是否已经在集合 T 中。很多编程语言的数组都不支持多值表达，因此我们将
dist 数组元素设计为一个数据结构：

    
    
    typedef struct
    {
        int value;
        bool is_in_t;
    }Dist_T;
    

综合以上描述，我们定义一个数据结构 Dijkstra_T，包含了 Dijkstra 算法所需要操作的全部数据：

    
    
    typedef struct
    {
        int vertexs;  //题目给出的实际顶点个数
        int T[MAX_VERTEX];  //集合 T
        int tc; //当前 T 中顶点个数
        Dist_T dist[MAX_VERTEX];  //dist 数组
    }Dijkstra_T;
    

#### Dijkstra 算法设计

Dijkstra 算法只是给出了理论上的原理，针对不同的具体问题，在实现上可能有细微的差异。结合 Dijkstra_T
的定义，我们可以设计出一个类似算法模板的实现，遇到具体问题，如果识别出来是求单源最短路径问题，只需根据题意对模型稍作修改，就可以套用 Dijkstra
算法求解，这也是很多人“玩” Online 算法比赛常用的套路。

定义了 Dijkstra_T 数据结构，Dijkstra 算法原理的第（1）步就完成了，接下来完成第（2）步，对 Dijkstra_T 数据结构中的 T 和
dist 进行初始化。初始化的工作相对比较独立，从代码实现的角度理解，用一个单独的接口函数完成数据初始化是一种比较好的代码风格。

    
    
    void init_dijkstra(Dijkstra_T *dj, Problem_T *p_data)
    {
        //将 T 初始化为只包含起始点 S 的状态，即 T{ S }
        dj->T[0] = p_data->start_vertex;
        dj->tc = 1;
    
        //初始化 dist 数组的值为起始点 S 到顶点 Vx 的边的权重，即 dist[Vx] = w(S, Vx)
        dj->vertexs = p_data->vertexs;
        for (int i = 0; i < dj->vertexs; i++)
        {
            dj->dist[i].is_in_t = false;
            //对无穷大的处理，已经隐含在邻接矩阵 w 的处理中了
            dj->dist[i].value = p_data->w[p_data->start_vertex][i];
        }
        //起始点特殊处理一下
        dj->dist[p_data->start_vertex].is_in_t = true;  //起始点初始化在 T 中了
        dj->dist[p_data->start_vertex].value = 0; //对于起始点 S，则设置 dist[S] = 0；
    }
    

init_dijkstra()
函数的代码比较简单，对照其中的注释，可以看出来第（2）步的文字描述是如何翻译成代码的。如果两个顶点不直接相连，算法原理的描述是用无穷大表示两个顶点的距离，这里需要说明一下对无穷大的处理方式。计算机无法表示无穷大和无穷小，一般的处理原则是用一个计算机能表达的特殊值代替无穷大或无穷小，很多人喜欢用“−1”这样的负数表示这个特殊值，以区别正数表示的距离值。实际上这是个不好的习惯，除非别无选择，否则尽量不要使用这种方法。好的做法是，使用一个明显超出问题域中各值范围的正整数值来表示无穷大的概念，这样选择可以很好地满足代码处理的一致性原则。邻接矩阵
w 中，如果两个顶点之间不直接相连，其对应的权值被设置为 INFINITE，INFINITE 是一个定义的常量：

    
    
    const int INFINITE = 108000; //十万八千里
    

使用 INFINITE 常量而不是“−1”这样的特殊值的好处就是不需要在代码中到处去做 if-else 这样的判断，无论那个距离，只要加上这个
INFINITE，都不可能是最小距离，在第（3）步做选择的时候自然就会被排除，算法代码不需要做特殊处理，也就显得十分简洁。对于常见的邮递员问题，汽车航行问题，这个值够大，但是如果你遇到的是星际贸易这样的问题，需要根据题意，谨慎地调整这个常量的值。

接下来是第（3）~（5）步的实现，这个是算法的主体部分。根据之前对算法原理的分析，算法的主题应该是一个循环结构，其中第（5）步给出了循环结束的条件，基本上这个循环结构应该是这样的：

    
    
        while (dj->tc < dj->vertexs) //直到集合 T 包含了所有顶点
        {
            //......
        }
    

第（3）步的操作中有一个约束条件，就是“对于所有不属于集合 T 的顶点 Vi”，根据我们的数据模型定义，只需要判断 `dist[i].is_in_t`
是否为 true 即可，不需要遍历集合 T
做判断。从这个例子可以看出来，设计算法时，数据模型的定义在很大程度上会影响算法的具体实现，甚至影响算法的效率。从线性表中找最大和最小值的方法在前面的课程中都有介绍，本例中使用只需增加一个对
`dist[i].is_in_t` 的判断即可。向 T 中添加顶点 Vi，就是在数组 T 的末尾增加元素，tc
值是数组中有效元素的个数，同时也是数组末尾的下标：

    
    
        dj->T[dj->tc] = min_vi;
        dj->tc++;
    

第（4）步是比较容易困惑的地方，首先第一句“对于新加入的顶点 Vi，查看 Vi
能够到达的所有顶点”，就常常让很多新手无法下手。其实，这就是对邻接矩阵的遍历操作。起点 Vi 是固定的，只要将 w 的第二维下标遍历一遍就可以了，只要小于
INFINITE，就说明 Vi 能到达这个顶点。现在看第二句话，假如从 Vi 到顶点 j 可以直达，那么“通过 Vi 到达其他顶点的路径长度”其实就是
dist[Vi] + >w[Vi][j]，“起始点直接到达该顶点的长度”就是 dist[j]，这句描述翻译成伪代码描述就是：

    
    
    IF (dist[Vi] + >wVi) < dist[j]
    　　dist[j] = dist[Vi] + >wVi
    END IF   
    

第（5）步做的事情其实就是根据实际情况更新各个顶点目前已经得到的 dist 距离。dist
中的距离是之前用贪婪策略得到的最短距离（局部最优解），实际可能并不是最短的距离，因为贪婪法一般都不可能直接得到全局最优解，所以对于 Dijkstra
算法来说，这个更新（替换）操作非常重要。

至此，我们已经完整地理解并翻译了全部算法原理描述的内容，看看最终的算法实现吧：

    
    
    void dijkstra(Dijkstra_T *dj, Problem_T *p_data)
    {
        while (dj->tc < dj->vertexs) //直到集合 T 包含了所有顶点，第（5）步描述的循环终止条件
        {
            //第（3）步
            //对于所有不属于集合 T 的顶点 Vi，从 dist 数组中寻找最小值 dist[Vi]
            int min_dist = INFINITE;
            int min_vi = -1;
            for (int i = 0; i < dj->vertexs; i++)
            {
                if (!dj->dist[i].is_in_t && (dj->dist[i].value < min_dist))
                {
                    min_dist = dj->dist[i].value;
                    min_vi = i;
                }
            }
    
            //将顶点 Vi 加入到集合T中，完成第（3）步
            dj->T[dj->tc] = min_vi; //新加入顶点 min_vi
            dj->tc++;
            dj->dist[min_vi].is_in_t = true;
    
            //第（4）步
            //对于新加入的顶点 Vi，查看 Vi 能够到达的所有顶点
            for (int j = 0; j < dj->vertexs; j++)
            {
                if (p_data->w[min_vi][j] < INFINITE) //从 min_vi 能直接到达 j
                {
                    int new_dist = dj->dist[min_vi].value + p_data->w[min_vi][j];
                    //从起点到 min_vi 的最小距离加上 min_vi 到 j 的距离之和小于从起点直接到 j 的距离
                    if(new_dist < dj->dist[j].value)
                    {
                        //替换 dist 数组中对应顶点的值
                        dj->dist[j].value = new_dist;
                    }
                }
            }
        }
    
    }
    

结合代码中的注释，对应算法原理的描述，对 Dijkstra 算法的实现是否一目了然了？

### Dijkstra 算法相关的典型例题

虽然我们有了一个符合 Dijkstra 算法原理的简单实现，但是要实用还有一段距离。这里我们通过两个曾经在算法竞赛中出现过的题目，介绍一下如何识别适用于
Dijkstra 算法的题目，并根据题目的描述修改数据模型定义，使之能解决对应的题目。

#### 宋江的困扰

一心想被招安的宋江终于如愿以偿，为了向朝廷递上投名状，宋江被高太尉忽悠去攻打方腊。从梁山到方腊路途遥远，中间间隔众多城镇，这些城镇之间要么是水路相连、要么是山路、要么是平康大道、要么是被山挡着，不能直接到达。梁山大军从一个城镇移动到另一个城镇需要的时间各不相同，如何用最短的时间抵达方腊，这个问题一直困扰着宋江，请你帮宋江解决这个问题吧，规划一条从梁山到方腊的路线，使得梁山大军能用最短的时间到达方腊。

测试数据的格式如下，第一行是一个数字，表示城镇的数量 n，2 ≤ n <
20；第二行是对应城镇的名称，中间用空格隔开；第三行是两个数字，分别表示梁山对应的编号和方腊对应的编号，城市编号从 0
开始；第四行是城镇之间交通信息的数量。之后紧跟着 M 行交通信息，每行有三个数字，分别是起点城镇的编号、终点城镇的编号和这两个城镇的交通时间，单位是天。

根据题目分析，这是个求最短路径的问题，每个城镇看作是图上的一个顶点，城镇之间的交通时间可视为边的权，这个数始终为正数，符合 Dijkstra
算法的要求，可以应用 Dijkstra 算法求解。确定了算法，接下来就看如何把题目描述的信息转化成算法要求的数据模型。Dijkstra
算法可以计算出从起始点到任意点的最短路径，把梁山作为起始点，找到方腊对应的 dist
值没有问题，但是这个题目要求输出从梁山到方腊的路线，这就需要我们修改数据模型的定义，增加最短路径的节点信息，最后在输出信息的时候，除了输出花费的行军时间，还要输出行军路线。

首先修改 Dist_T 数据结构的定义，增加路径信息 path，Dist_T 原本设计就是存放最终结果，路径信息放在这里最合适。

    
    
    typedef struct
    {
        int value;     
        int path[MAX_VERTEX];
        int pc;
        bool is_in_t;  
    }Dist_T;
    

接下来对第（2）步初始化的算法代码进行修改，增加 path 的初始化。path 初始化的原则是当存在从起始点到 Vi
的通路时（两个城镇没有被山挡着），则将起始点增加到 path 中，说明当前 dist[Vi] 的值是从起始点到 Vi
的距离，起始点是这条路径的第一个点。需要调整的代码如下：

    
    
            dj->dist[i].is_in_t = false;
            dj->dist[i].pc = 0;
            dj->dist[i].value = p_data->w[p_data->start_vertex][i];
            if (dj->dist[i].value < INFINITE)
            {
                dj->dist[i].path[0] = p_data->start_vertex;
                dj->dist[i].pc = 1;
            }
    

最后是修改算法第（4）步的内容，当满足“`(dist[Vi] + >w[Vi][j]) < dist[j]`”条件时，不仅更新 dist[j]
的值，同时更新 dist[j] 的路径信息。更新的方法是从 dist[Vi] 复制 Vi 的最短路径信息，再把 Vi 顶点附加在路径最后，表示是经过 Vi
这个顶点再到 j 的路径。修改后的代码如下：

    
    
        if (new_dist < dj->dist[j].value)
        {
            //替换 dist 数组中对应顶点的值
            dj->dist[j].value = new_dist;
            //从 min_vi 复制路径信息
            for (int k = 0; k < dj->dist[min_vi].pc; k++)
            {
                dj->dist[j].path[k] = dj->dist[min_vi].path[k];
            }
            dj->dist[j].pc = dj->dist[min_vi].pc;
            //附加新路径信息，即从 min_vi 到 j 这一段
            dj->dist[j].path[dj->dist[j].pc] = min_vi;
            dj->dist[j].pc++;
        }
    

最后，在算法的主体不变的情况下，修改结果数据模型定义，并少量修改代码，就可以得到一个针对本问题的算法。例如，题目给出一组测试数据如下：

    
    
    8
    梁山 尖庄 茅台 景德镇 雄安 敦煌 龙门 方腊
    0 7
    15
    0 1 20
    0 3 10
    0 5 30
    1 2 60
    1 4 50
    2 7 60
    3 1 100
    3 6 20
    4 2 90
    4 7 40
    5 3 50
    5 6 40
    6 1 70
    6 4 30
    6 7 80
    

算法最后输出的结果是：

    
    
    Total 100 days
    Path: 0（梁山）→ 3（景德镇）→ 6（龙门）→ 4（雄安）→ 7（方腊）
    

#### 考虑费用的最短路径问题

给你 n 个点、m 条无向边，每条边都有长度 d 和花费 p，给你起点 s、终点
t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。

**输入要求** ：输入 n、m，点的编号是1~ n，然后是 m 行，每行 4 个数 a、b、d、p，表示 a 和 b 之间有一条边，且其长度为 d，花费为
p，最后一行是两个数 s、t，起点 s，终点 t，n 和 m 为 0 时输入结束。

n 的取值范围为 (1,1000]，m 的取值范围为 (0,100000)，并且 s 不等于 t。

**输出要求** ：输出一行有两个数，最短距离及其花费，空格分隔。

很多读者一看到最短路径、最小花费，很容易将此题误判为“最小费用最大流”问题，其实不然，这道题本质仍然是求最短路径，只是增加了一个费用的判断条件，即在最短路径相同的情况下，选择花费最少的那条。根据题目要求，每条边除了表示距离的权重，还需要表示费用，这就需要调整邻接矩阵的数据结构设计。首先需要定义一个数据结构
Edge_T 存储每条边的两个属性，然后用这个数据模型重新定义邻接矩阵 w：

    
    
    typedef struct
    {
        int weight;
        int cost;
    }Edge_T;
    
    typedef struct
    {
        int vertexs;  //题目给出的实际顶点个数
        Edge_T w[MAX_VERTEX][MAX_VERTEX]; //图的矩阵，表示距离和开销
        int start_vertex;   //起始点编号
    }Problem_T;
    

根据题意，dist 也要增加一个表示当前最小费用的属性 cost（题目没有要求输出完整路径信息，因此不需要 path 属性）：

    
    
    typedef struct
    {
        int value;
        int cost;
        bool is_in_t;
    }Dist_T;
    

和上一个例题一样，设计好数学模型，定义好新的数据结构之后，就要修改代码，使之适应新的数学模型或数据结构定义。根据分析，需要修改的地方仍然是第（2）步数据初始化的地方和第（4）步修改最短路径信息的地方。初始化的修改很简单，就是增加对
dist 数据的 cost 元素初始化，如果从起始点到 Vi 存在有效路径，则 dist[Vi].cost 初始化为这条边的费用，否则将
dist[Vi].cost 初始化为 0。

    
    
        dj->dist[i].is_in_t = false;
        dj->dist[i].value = p_data->w[p_data->start_vertex][i].weight;
        dj->dist[i].cost = p_data->w[p_data->start_vertex][i].cost;
    

对第（4）步的修改，主要是对判断条件进行修改，原来的判断条件只是直接比较距离，现在需要在距离相等的情况下，增加对费用的判断。前面设计数学模型的时候，给
dist 数组增加了一个 cost 属性，这个属性承载着和 value
属性一样的使命，就是存放从起始点到当前顶点的最小费用。既然意义一样，那么两个属性的处理方式和判断最小值的依据也是一样的，理解了这一点，代码的修改就比较简单了：

    
    
        int new_dist = dj->dist[min_vi].value + p_data->w[min_vi][j].weight;
        int new_cost = dj->dist[min_vi].cost + p_data->w[min_vi][j].cost;
        //从起点到 min_vi 的最小距离加上 min_vi 到 j 的距离之和小于从起点直接到 j 的距离
        //或者距离相等，但是费用比较小
        if ((new_dist < dj->dist[j].value) || ((new_dist == dj->dist[j].value) && (new_cost < dj->dist[j].cost)))
        {
            //替换 dist 数组中对应顶点的值
            dj->dist[j].value = new_dist;
            dj->dist[j].cost = new_cost;
        }
    

问题的解决是不是比想象中简单？只要能理解题意，设计出合适的数学模型和数据结构，套用一下算法模板，一个看起来无从下手的问题解决了。很多“玩”算法 Online
Judge 的人，“玩”的就是这个套路。

### 总结

这一课我们根据对 Dijkstra
算法原理的理解，设计了一个简单的算法实现，并将这个算法实现作为模板，稍加修改就解决了两个常见的算法问题。在设计算法实现的过程中，介绍了针对 Dijkstra
算法建模需要考虑的细节问题，并对着代码讲解了如何将文字描述的算法原理翻译成算法代码，随后通过两个典型的应用 Dijkstra
算法的问题，介绍了如何根据具体问题修改数据模型（模型修改的原则），以及在新的数学模型基础上如何调整算法实现并解决问题的过程。希望读者通过这一课的学习，了解
Dijkstra 算法几个关键步骤是如何实现的，并学会最短路径问题的建模方法，今后遇到此类问题时能独立解决问题。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

