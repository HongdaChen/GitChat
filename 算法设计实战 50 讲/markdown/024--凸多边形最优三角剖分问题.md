>
> 凸多边形上的最优三角剖分问题也是动态规划经典题目，此类问题基本上都是在一个给定的凸多边形上规划三角形分割，使得剖分后得到的一系列三角形的某种结果最优，比如三角形的面积之和最大（或最小），或者是三角形的各边权重之和最大（或最小）等等。这一课，我们要介绍的题目是要求根据三角形的权重之和最小来剖分多边形，结合这个题目，希望大家能掌握如何分析此类问题，并用动态规划的方法设计出求解此类问题的算法实现。

### 子问题的定义

先来解释一下题目中提到的“三角形权重之和”是什么意思。边的权是图论中的一个很重要的概念，实际上就是为边赋予一个人为指定的属性，常用来表示边代表的两点的距离，或者两点之间的各种开销。这个题目中说的权实际上更简单，就是多边形每条边的一个附加属性。一个三角形的权重就是组成三角形的三条边的权重之和，而题目中的“三角形权重之和”表示的是多边形拆分成的一系列小三角形的权重之和。

如图（1）所示，把一个凸多边形分割成多个三角形有多种剖分形式，根据题目给出的条件，每种分割方法得到的三角形的权重之和也各不相同。用动态规划方法解决算法问题，首先要确定子问题和各决策阶段状态的定义，然后是给出最优子结构的性质。每个决策阶段的状态，实际上就是子问题在这个决策阶段的解，这个阶段的最优解一般是根据最优子结构的性质由之前各阶段的解和当前的最优决策堆叠出来。所以，用动态规划法解决算法问题的关键是识别出子问题并给出决策状态的定义。

![enter image description
here](https://images.gitbook.cn/a3f20a40-e0ae-11e8-929c-a1457f9bb795)

图（1）多边形分割示意图

《如何理解动态规划法》这一课我们介绍可一种分析定义子问题的方法，就是确定问题的规模，通过缩小问题规模的方式确定子问题，这里不妨应用一下。

首先看问题的解，问题的解是按照三角形剖分后的多边形具有最小的三角形权重和，这句话有点拗口，我们就用多边形的最小权重这个概念来代替前面那句话。那么在某个决策阶段的子问题的状态就是当前子问题定义的多边形（规模较小的多边形）的最小权重，于是缩减问题的规模就是选择多边形中的某几个点组成一个小多边形（子多边形）。

既然原始问题中多边形是由 N 个顶点，那么子问题是否可以定义为“由 i 个点组成的多边形”，其中 i 的取值范围是：$0\leqslant
i\leqslant N$，用状态 $d[i]$ 表示由 i 个顶点组成的多边形的最小权重值。

请大家思考一下，这样定义子问题是否合适？显然不合适，因为这样定义的子问题不满足无后向性，为什么这么说呢？举个“栗子”，请看图（1）中的多边形例子，由 $V
_{0}$、$V_ {1}$ 和 $V _{2}$ 三个点组成的子问题的状态 $d[3]$ 和由 $V_ {4}$、$V _{5}$ 和 $V_ {6}$
三个点组成的子问题的状态 d[3] 在后续的状态演化过程中的结果肯定不一样，那就意味着虽然之前的搜索通过两个不同的路径都到了 $d[3]$
状态，但是却是两个不同的 $d[3]$，其后续得到的结果也不一样，这就不满足无后向性原则了。按照无后向性原则，不管之前通过什么途径到了 $d[3]$
状态，其后续演化的结果应该是不变的。

这样定义子问题的错误在于只看到了问题规模的一部分，没有看到问题的全部。对于凸多边形问题，因为任意两个顶点之间的边的权重是不一样的，所以每个顶点之间都是不一样的，不同简单地只关注顶点的数量。基于这一点考虑，子问题中除了应该含有顶点数量的信息，还应该包含顶点信息。

如果原始问题的规模是“由顶点 $V _{0}$ 到 $V_ {7}$ 组成的多边形”，那么子问题可以考虑成“由顶点到 $V _{i}$ 到 $V_ {j}$
组成的多边形”，其中 i 和 j 的范围是：$1 \leqslant i < j \leqslant
N-1$，这样定义的子问题既考虑了顶点的数量，又包含了顶点信息。既然子问题需要两个变量描述，那么我们考虑子问题的状态用 $d[i][j]$
表示子问题“由顶点 $V _{i}$ 到 $V_ {j}$ 组成的多边形”的最小权重。当然，这样定义子问题的前提是要求多边形的顶点从 i 到 j
之间的顶点是连续的，但这并不妨碍我们解决这个问题。

在分割多边形子问题的时候，只要保证顶点 i 和顶点 j
之间的连线始终是分割三角形的一条边，就可以使得被此三角形分割的两个小多边形的顶点也是连续的，大家可以参考图（2）的最优子结构示意图来理解这一点。

为什么说做了这个约束仍然不影响对问题的解决呢？原因就在于动态规划法对这个问题的解决思想本质上还是遍历，对每个子多边形的遍历有多种顺序，但是只要按照一种顺序遍历就可以了，不需要处理所有的遍历顺序，因为它们最终都会在遍历其他子多边形的时候被重复遍历到。所以我们要求子多边形的起始点必须是分割三角形的一条边其实是约定了一种遍历顺序，被忽略的其他顶点之间的边会在遍历其他子多边形的时候被处理，并不会漏掉任何一种状态。

当然，这个约束条件也简化了算法程序的实现难度，毕竟用二维数组直接表示一个状态，要比用顶点的集合映射一个状态要简单很多。

### 子问题最优子结构

定义了子问题，接下来就要分析最优子结构的性质了。所谓最优子结构的性质，其实就是确定是否能找出一种决策方法，该方法能够根据前一个阶段或前几个阶段的子问题的状态，通过某种策略或方法得到当前阶段的状态，并使得当前的状态是最优的。我们首先假设在某个决策阶段的一个三角形分割形式如图（2）所示，当前要决策的状态是
$d[1][7]$（后面会解释为什么这个状态是 $d[1][7]$，而不是 $d[0][7]$），由 $V _{0}$ 和 $V_ {7}$
两个顶点组成的边，可以和其他 6 个顶点（$V _{1}-V_ {6}$）中的任意一个组成一个三角形，从而将多边形分割成一个三角形加上两个小多边形的状态。

假设我们选择 $V _{4}$，则得到三角形 $V_ {0}V _{4}V_ {7}$ 和两个小多边形 ${V _{0},V_ {1},V _{2},V_
{3},V _{4}}$ 和 ${V_ {4},V _{5},V_ {6},V _{7}}$，根据之前对子问题和状态的定义，我们用 $d[1][4]$ 和
$d[5][7]$ 分别两个小多边形的最小权重，用 $w(0,4,7)$ 表示三角形 $V_ {0}V _{4}V_ {7}$ 的权重，则选择顶点 $V
_{4}$ 时，计算出来的权重值就是：$d[1][4]+d[5][7]+w(0,4,7)$。同样，当选择顶点 $V_ {3}$
时，计算出来的权重值就是：$d[1][3]+d[4][7]+w(0,3,7)$。

**为了使子问题的结果最优，子问题的最优子结构就应该是将 $V _{1}-V_ {6}$ 这6个顶点都尝试一遍，然后选择结果最小的那个权重值作为状态
$d[1][7]$ 的值**，假如按照顶点 $V_{3}$ 的分割能使得 $d[1][3]+d[4][7]+w(0,3,7)$ 的值在所有 6
个结果中是最小的，则最后状态 $d[1][7]$ 的值就是：$d[1][3]+d[4][7]+w(0,3,7)$。

![enter image description
here](https://images.gitbook.cn/b33a3db0-e0ae-11e8-a875-ef65cef42b08)

图（2）最优子结构示意图

### 状态递推关系和边界值

![enter image description
here](https://images.gitbook.cn/bf264dd0-e0ae-11e8-9779-eba8c6b4eb65)

图（3）递推关系示意图

假如采用从 0 开始的数字为每个多边形的顶点编号，对于一个凸N边形来说，其顶点集合是 ${V _{0},V_ {1},V _{2},…V_
{N-1}}$。我们用状态 $d[i][j]$ 表示子问题“由顶点到 $V _{i}$ 到 $V_ {j}$ 组成的多边形”的最小权重，则 i 和 j
的有效值范围是：$1 \leqslant i < j \leqslant N-1$。

当问题规模最小的时候，即子多边形只有 $V _{1}$ 和 $V_ {2}$ 两个顶点（只有 1 条边的“多边形”），它其实是从前一个多边形 ${V
_{0},V_ {1},V _{2}}$ 被三角形 $V_ {0}V _{4}V_ {7}$ 分割出来的，根据我们的分割原则，$V _{1}V_ {2}$
是选中的一条边，$V _{1}$ 就是被选中的 k 点（k=1）。被分割出来的两个多边形分别是 ${V_ {1}}$ 和
${V_{2}}$，只有一个顶点的“多边形”（即有 0 条边的“多边形”），因为没有任何边，所以其权值是 0，这可看作是一种边界条件。最终状态
$d[1][2]$ 的值可由以下关系给出：

$$ d[1][2] = d[1][1] + d[2][2] + w(0,1,2) $$

多边形在分割之前至少要有三个顶点，顶点 $V_{0}$ 是隐含在所有的状态中的，因此任何显式包含 0 的状态都是非法值，比如
$d[0][1]$、$d[2][0]$、$d[0][2]$ 之类的状态都是非法状态，最小的有效状态就是 $d[1][2]$，整个问题的最优解就是状态
$d[1][N-1]$。

当子问题的规模变成 ${V _{1},V_ {2},V _{3}}$ 三个点的时候，此时分割多边形就有两个选择，如图（3-b）所示，可以选 $V_ {1}$
作为 k 点分割多边形，也可以选择 $V_{2}$ 作为 k 点分割多边形。

首先选择 $V _{1}$ 作为 k 点的情况（k=1），多边形被分割为三角形 $V_ {0}V _{1}V_ {3}$ 和两个多边形 ${V _{1}}$
与 ${V_ {2},V_{3}}$，此时状态值的计算方法是：$d[1][1] + d[2][3] + w(0,1,3)$。

接下来选择 $V _{2}$ 作为 k 点（k=2），多边形被分割为三角形 $V_ {0}V _{2}V_ {3}$ 和两个多边形 ${V _{1},V_
{2}}$ 与 ${V_{3}}$，此时状态值的计算方法是：$d[1][2] + d[3][3] + w(0,2,3)$。根据我们的最优选择策略，最终状态
$d[1][3]$ 的值将选择 d1 和 d2 中较小的那一个，即：

![enter image description
here](https://images.gitbook.cn/c769ebf0-e62b-11e8-a027-a90b327bea9a)

根据上述分析，对于一般子多边形 ${V _{i},V_ {i+1},…,V _{j}}$，如图（3-c）所示，通过任意一个 k 点（$i\leqslant
k {i-1},V _{i},…,V_ {k}}$、${V _{k},V_ {k+1},…,V _{j}}$ 和三角形 $V_ {i-1}V _{k}V_
{j}$，此时状态 $d[i][j]$ 的递推计算方法如下所示：_

![enter image description
here](https://images.gitbook.cn/6abe9ab0-e63d-11e8-9404-598148498eff)

结合之前提到的边界值：

$$ d[i][j] = 0 \qquad \qquad i = j $$

就构成了完整的递推关系，并且最终的状态 $d[1][N-1]$ 就是问题的最优解。

### 算法实现说明

既然式区间动态规划，实现上基本上就是《如何理解动态规划法》里提到的三重循环模式，对照这个模式，很容易就可以做出代码实现。第一层循环穷举的是子多边形的规模，毫无疑问，子多边形最少有两个顶点（不包括编号是
0 的顶点），最多则是 N-1 个点（同样不包括编号是 0 的顶点），第一层循环遍历子多边形规模：

    
    
    for (int r = 2; r < N; r++)
    

对于每种规模的子问题，还要进一步确定子多边形包含哪些顶点，这也是一层遍历，多边形起点 $V _{i}$ 从 1 开始遍历，终点 $V_ {j}$
则由起始点和子多边形规模r决定，这是第二层遍历：

    
    
    for (int i = 1; i < N - r + 1; i++)
    int j = i + r - 1;  //确定 Vj,r 是子问题规模
    

对于已经确定的子多边形 ${ V _{i},…V_ {j}}$ 继续遍历顶点
k，根据递推公式计算状态值，并选择最小的一个作为子多边形的权重，这也是递推表达式中那个 min 的体现。k 的取值是从 i 到 j（不包括
j），这是第三层循环：

    
    
    for (int k = i; k < j; k++)
    

完整的算法实现请参考 polygon_triangulation() 函数的代码，需要说明一下 RESULT 数据结构的定义。$d[N][N]$
是记录子问题的决策状态，和之前分析的递推关系一致，$k[N][N]$ 是个稀疏矩阵，主要是记录子多边形 ${ V _{i},…V_ {j}}$
最终选定的作为最优分割的顶点 k。记录这个 k 值的目的是为了最后能反向回溯整个决策过程，输出三角形剖分的结果，毕竟 $d[1][N-1]$
中只是记录了最优的权重值。

    
    
    typedef struct
    {
        int d[N][N];  //d[i][j] 表示多边形 {Vi - Vj} 的最优权值
        int k[N][N];  //k[i][j] 记录 Vi 到 Vj 最优三角剖分的中间点 K
    }RESULT;
    
    
    
    void polygon_triangulation(RESULT *result)
    {
        int min_d;
    
        //初始化边界值
        for (int m = 1; m < N; m++)
        {
            result->d[m][m] = 0;
        }
    
        //开始规划
        for (int r = 2; r < N; r++) //子多边形规模遍历
        {
            for (int i = 1; i < N - r + 1; i++) //子多边形遍历，确定起始点 Vi
            {
                int j = i + r - 1;  //确定 Vj,r 是子问题规模
                //遍历从 Vi 到 Vj 的点（不包括 Vj）, 找最小权重值分割的k点
                min_d = INFINITE; 
                for (int k = i; k < j; k++)
                {
                    //递推计算
                    result->d[i][j] = result->d[i][k] + result->d[k + 1][j] + triangle_weight(i - 1, k, j);
                    if (result->d[i][j] < min_d) 
                    {
                        min_d = result->d[i][j];
                        result->k[i][j] = k;  //记下这个分割点
                    }
                }
                result->d[i][j] = min_d;
            }
        }
    }
    

用动态规划方法设计算法，如果只考虑各个决策阶段的状态，最终只能得到一个最优的解（最终的状态），要想得到决策结果，就需要在动态规划决策过程中，记录决策点信息，并在算法结束后输出这些决策点信息，这是动态规划算法设计需要考虑的细节。对于本问题，决策信息就是每次根据子问题
${ V _{i},…V_ {j}}$ 选择的那个 k 点，我们把这个点的位置记录到 $k[i][j]$ 中，最后反向搜索一下
$k[N][N]$，逐个找出各个阶段的决策点信息，并输出出来，形成最终的决策结果。

是的，这是个递归实现，大家可以用前面介绍的递归程序设计方法理解这个算法实现，记住无非就是递归三要点。

    
    
    void trace_result(RESULT *result, int i, int j)
    {
        if (i == j)
        {
            return;
        }
    
        trace_result(result, i, result->k[i][j]);    //输出一个子多边形的剖分结果
        trace_result(result, result->k[i][j] + 1, j);    //输出另一个子多边形的剖分结果
    
        //输出当前三角形，k[i][j]是动态规划去搜索过程中记录下的最优剖分点
        std::cout << "triangle: { V" << i - 1 << " V" << result->k[i][j] << " V" << j << " }" << std::endl;
    }
    
    trace_result(&result, 1, N-1); //递归输出决策结果
    

### 总结

我一直说动态规划是一种高效的穷举搜索算法，在这个例子中再次得到了印证。从第二节的分析可以看到，选择当前阶段最优解的时候，是先选择一条边，然后把除这条边之外的所有其他顶点都遍历了一遍，分别与这条边构造成一个三角形，并把多边形分成两个小多边形，最后从这些遍历得到的子问题的分解关系中选择权值最小的那个分解方式作为这个阶段的最优解。

凸多边形的最优三角形剖分问题都可以用本课给出的算法框架求解，只需做很少的修改。假如问题变成求剖分后的三角形面积最大的剖分方式，则只需将计算三角形权重的函数改成计算三角形面积的函数，同时将递推关系中的选择最小值的处理改成选择最大值的处理就可以了。根据边长计算三角形面积可以使用海伦公式，这里就不赘述了。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

