>
> 动态规划理论最早被提出来的时候，是用来解决资源的有效分配问题。这一课要介绍的投资问题，有个通用的模式，那就是总资源量有限，要分配给若干个项目，每个项目都有一个投入与收益的关系，最终的问题是求如何规划在不同项目上的投资，使得收益能够最大化。

### 问题分析

这一类问题有很多，我们找了个典型的例子，即项目投资问题。假设有数量为 M 的资金，计划用于 N
个投资项目，每个项目投入的资金和获得的回报用一张二维表记录，比如 f[i, x] 表示第 i 个项目投入 x 万元时能获取的收益。最后的问题是如何在这 N
个投资项目上分配这 M 万元的资金，使得最后的收益最大化。比如有 600 万元，投资 3 个项目，每个项目的投资收益如下表所示：

![enter image description
here](https://images.gitbook.cn/eb8bacc0-eba9-11e8-af4c-6f74b09e97f2)

显然，投资和收益不是线性等比例关系，否则的话，把钱全投到收益比最高的那个项目上就行了，也没啥好规划的了。这个算法也可以用穷举法，因为 N
不是固定的值，所以穷举时可以考虑用递归的方式实现，但是这一课我们考虑用动态规划法来设计这个算法。

投资 N
个项目，看起来好像是毫无关系的离散事件，但是因为投资的总钱数是固定的，这就使它们有了关系。如果我们换个角度看投资的项目，把所有的投资看作是一个求最优解的操作，把对每个项目的投资看作这个操作的一个阶段，就成功地将其转换成了多阶段决策问题。如果要考虑用动态规划解决这个多阶段决策问题，就需要首先证明每个阶段的决策能满足无后向性的要求。在这之前，先要确定决策状态的定义。

状态里肯定要有一个量是标识决策阶段（也就是当前决策的项目）的，不妨用 i 表示决策阶段。肯定还要有一个量是标识投资的钱数，如果我们定义 j
为当前项目（阶段）i 投入的钱数，那么状态 $d[i,j]$ 就表示项目 i 投入 j
万元获取的最大收益。现在考虑一下这个状态的定义是否满足无后向性，我们假设给第 2 个项目投入 2 百万元时获取的最大收益为 $d[2,2]$，这个
$d[2,2]$ 包含两部分收益，一部分是第 2 个项目投 2 百万元获得的 85 万元固定收益，另一部分是给另两个项目投入剩下的（M −
2）百万元获取的收益。很显然，这（M − 2）百万元在第 1 个项目中有很多种投资方法，每种方法获取的收益都不一样，这会使得通过不同的 d[1,x]
计算出来的 $d[2,2]$ 各不相同，后续依赖 $d[2,2]$ 的决策就如同建立在浮沙之上，因此不满足无后向性要求。

单独对第 i 个项目定义状态不能满足无后向性要求，现在换个思路，我们将前 i 个项目合在一起考虑，即定义状态 $d[i,j]$ 为给前 i 个项目投入 j
万元时能获得的最大收益。前 i 个项目无论怎么分配这 j 万元投资，总能得到一个确定的最大收益，并且这个最大收益在到达 $d[i,j]$
状态后不会因为之前的分配方式不同而变化，后续做决策时也不会变化，因此满足无后向性要求。

### 递推关系

给前 i 个项目投入 j 万元能获取的最大收益包含两部分，一部分是给第 i 个项目投入 k 万元获得的收入，另一部分是给前 i−1 个项目投入 j−k
万元获得的收入。其中第二部分是不包含第 i 个项目的前 i−1 个项目投入 j−k
万元获得的收益，这其实就是我们定义的子问题的状态，看出来了吗，这就是递推关系。给第 i 个项目投多少才能使得 d[i,j] 获得最大值呢？对第 i
个项目来说，无法决策，按照惯例，那就枚举一遍，然后取个最大值吧，这就是本问题的状态递推关系：

![enter image description
here](https://images.gitbook.cn/4de569f0-f123-11e8-9b37-ef47d15a14c0)

根据子问题的状态定义，给前 i 个项目投入总数为 j 万元的钱，因此第 i 个项目能投入的钱 k 的范围就是 [0,j]。k=0 说明第 i
个项目不投钱，钱 j 全投入前 i−1 个项目，k=j 说明前 i−1 个项目不投钱，j 万元全部投入第 i 个项目。

下面我们用一个直观的例子来解释一下这个状态递推公式，仍然以上面表中的数字为例。假设 A
项目的投资决策状态已经确定（实际上就是初始值，后面会介绍），现在确定对于前 2 个项目投入 3 百万元所能获得的最大收益 $d[2,3]$。根据 k
的遍历，首先我们设 k=0，也就是说，给第 2 个项目分 0 元资金，剩下的 3 百万全部投入第 1 个项目，此时计算：

$$ d[2,3] = f[2][0] + d[1,3] = 0+105 = 105 $$

继续假设 k=1，即给第 2 个项目分 1 百万，剩下的 2 百万投给第 1 个项目，此时计算：

$$ d[2,3] = f[2][1] + d[1,2] = 64 + 80 = 144 $$

继续假设 k=2，即给第 2 个项目分 2 百万，剩下的 1 百万投给第 1 个项目，此时计算：

$$ d[2,3] = f[2][2] + d[1,1] = 85 + 60 = 145 $$

继续假设 k=3，即给第 2 个项目分 3 百万，给第 1 个项目投 0 元，此时计算：

$$ d[2,3] = f[2][3] + d[1,0] = 110 + 0 = 110 $$

最后我们取最大值 145 作为 $d[2,3]$ 的状态值。j 的有效范围是 0 ~ 6 百万，其他的状态 $d[2,j]$
的值可参考上述分析过程同理计算。当 $d[2,j]$ 的所有值都计算出来以后，就可以进一步递推计算 $d[3,j]$ 的值，以此类推。

这个递推关系也是一个很典型的递推关系公式，大家只要遇到这种有 max 或 min
的关系式，都意味着在堆叠计算状态的时候，需要对某个关系做遍历（穷举）。类似的递推关系在区间动态规划的递推关系式中我们也遇到过，在算法实现的表现形式上，就是在
i 和 j 两种循环再增加一个 k 的循环。

### 初始值和结果

结果很容易理解，当状态递推到项目 i=n，投资额 j=m 的时候，就是最后求的最优解，即 $d[n][m]$ 就是最后要求的最大收益值。

初始值其实就是当问题的规模只有一个项目的时候的投资收益值，也就是第一个项目的投资收益值。对第 1
个项目投资的时候，不需要考虑其他项目的“干扰”，直接用题目给出的投资收益数组赋值即可。即：

$$ d[1,j] = f[1][j] \: \: \: \: \: 0 \leq j \leq m $$

前面模拟递推计算 $d[2,3]$ 时用的 $d[1,j]$ 的值，就是直接引用的 $f[1][j]$。

### 实现算法

前面提到过，这个问题的状态递推关系式与区间动态规划的模式很像，实际上，它们的算法实现确实也很像。第一层循环是项目 i 的循环（前 i
个项目的意思），也就是决策阶段的循环；第二层循环是投资额度的循环，即给前 i 个项目投 j 万元；第三层循环是如何将 j 分给当前项目 i 和前 i−1
个项目的一个穷举遍历循环，目的是求各种分配方法的最大收益。

算法实现需要注意的就是数组下标 0 和 1 的问题，上述分析的 $d[1,j]$，代码对应的是
$d[0][j]$。另外，为了方便引用数组下标计算，我们直接用投入资金的百万计数作为数组的下标，比如 $d[1][3]$ 表示给前两个项目投入 3 百万，0
则特别表示投资是 0，刚好一举两得。

    
    
    // n 个项目，投资 m 百万元 
    int investment(int n, int m, int d[][MAX_M], int max[][MAX_M])
    {
        //初始化（也就是只有一个项目的情况）
        for (int x = 0; x <= m; x++)
        {
            d[0][x] = f[0][x];  // 投资第一个项目 
            max[0][x] = x; //标记函数初始化
        }
    
        for(int i = 1; i < n; i++) // 投资前 i 个项目 
        { 
            for(int j = 0; j <= m; j++) // 前 i 个项目总投入的钱数 j 
            { 
                for(int k = 0; k <= j; k++) // 投资当前项目的钱数（第 i 个项目）
                { 
                    int tmp = f[i][k] + d[i - 1][j-k]; 
                    if(tmp > d[i][j]) //d[i][j] 初始化都是 0
                    { 
                        d[i][j] = tmp; // 更新当前的最优解 
                        max[i][j] = k; // 更新标记函数 
                    } 
                } 
            } 
        } 
    
        return d[n - 1][m];
    }  
    

所有动态规划算法实现都存在一个问题，就是结果输出不直观的问题，毕竟，决策过程隐藏在递推关系计算过程中，不到最后，谁也不知道决策的结果是什么。好在决策点是可以知道的，这是递推关系式所确定的，我们可以在递推计算的过程中保存决策点的决策信息，等计算完成后根据最后一个最优解对应的决策点信息反推这个最优解之前的每一步决策过程，从而输出最优解的结果。

那么，这个问题的决策点信息是什么呢？那就是当对第 i 个项目（阶段）决策时，记录投资金额为 j 时应该给项目 i 分配的投资额
k。这句话怎么理解呢？就是一句话，当我们递推计算出状态 $d[i,j]$ 的最优解时，对应记录下此时给第 i 个项目分配的投资额，也就是第三层循环遍历的那个
k 值。也就是说，如果状态 $d[i,j]$ 是某个阶段的最优解，那么给项目 i 分配的投资额是 k，给前 i−1 个项目分配的投资额是
j−k。相应地，为了与状态的记录一致，我们用投资标记 $max[i,j]$ 记录这个 k 值。

既然 $d[n][m]$ 是问题的最优解，那么投资标记 $max[n,m]$ 就是给第 n 个项目分配的投资额，因此前 n−1 个项目分得的投资额就是 m
− $max[n,m]$。根据递推关系，此时 $d[n-1][m-max[n,m]]$ 就是前 n−1 个项目获得的最好收益，而
$d[n-1][m-max[n,m]]$ 状态对应的投资标记 $max[n-1,m-max[n,m]]$ 就是给第 n−1
个项目分配的投资额。以此类推，直到推出给第 1 个项目分配的投资额为止。

很显然，这是个递归的过程，是的，对于决策过程的反推基本上都是递归过程，适合用递归程序实现决策结果的反推输出，在前几课中大家已经看到有好几个这样的例子了。当然，也不全都需要递归程序，这个算法的结果反推就没有用递归方法，大家可以自己体会一下。

    
    
    void print_result(int n, int m, int max[][MAX_M])
    {
        int invesment[MAX_N] = { 0 };
    
        invesment[n - 1] = max[n - 1][m];
        for (int i = n - 2; i >= 0; --i) 
        {
            int t = 0;
            for (int j = n - 1; j > i; --j) 
            {
                t += invesment[j];
            }
            invesment[i] = max[i][m - t];
        }
    
        for (int x = 0; x < n; x++)
        {
            printf("Invest %d for project %d\n", invesment[x], x + 1);
        }
    }
    

### 总结

这个问题的动态规划解法有点类似区间动态规划的思想，就是在状态递推计算的过程中增加一个枚举遍历。区间动态规划枚举遍历的是区间的分割点，这个问题枚举的是当前给第
i
个项目投入的资金数。从状态的递推关系式也可以看出来，两者的递推关系式中都有在若干个不同的状态递推结果中求最大值的要求，这就需要对这些递推结果遍历一下，求最大值。

好了，这一课的题目来了，那就是试试能否用穷举法求解这个问题。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

