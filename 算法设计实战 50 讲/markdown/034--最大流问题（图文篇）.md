>
> 原计划这一课是要讲解最小费用最大流问题，但是图文课每一篇如果字数太多会给手机阅读带来困难，加上读者圈朋友的反馈希望多讲一些基础的内容，因此这一课我们降低点难度，只讲最大流问题。最小费用最大流问题，其实也是在最大流问题的基础上加入类似最短路径算法（SPFA）这样的思路，叠加形成算法，最后的总结部分我会简单介绍一下在最大流算法的基础上实现最小费用最大流问题的两种常用方法，但是这一课，我们只讲最大流问题。

### 网络流和最大流

最大流问题的典型例子有物流配送、输水管路等。比如这个题目：某地区的自来水供应是由地下的水管网路组成，两个地点之间由粗细不一的水管连接，粗水管的输水能力大，细水管的输水能力小，请规划一个合理的水量和管路组合，使得从水源地到目的地能够获得最大的水量。

![enter image description
here](https://images.gitbook.cn/b06e42a0-fc1c-11e8-9fb2-0bb0adb1f496)

图（1）输水管路和最大输水量示意图

我们以《算法导论》一书中的图为例来解释一下上面的问题，如图（1-a）所示，假设图中 0 号顶点为水源地，5
号顶点为目的地，每条边都有两个数字描述，斜杠左边的数字是这条管路当前的输水量，斜杠右边的数字是这条管路的水管的容量；图（1-b）是我们选择给每条管路分配的输水量，这样分配的结果是从水源地到目的地的输水量达到最大值
23。那么是不是随便选择一下管路都能获得输水量的最大值呢？当然不是，如果规划得不合理，会造成细水管被撑满，而粗水管只有很少流量的情况，这时候显然是得不到最大值的。

#### 流网络的定义

流网络（Flow Networks）指的是一个有向图 G = (V,E)，其中每条边 (u,v) ∈ E 均有一非负容量 c(u,v) ≥ 0。如果
(u,v) ∉ E 则可以规定 c(u,v) = 0，流网络中有两个特殊的顶点：源点 s （source）和汇点
t（sink）。为方便起见，假定每个顶点均处于从源点到汇点的某条路径上，也就是说，对每个顶点 v，都存在一条从 s 出发，经过 v 到达 t
的路径。因此，图 G 为连通图，且 |E| ≥ |V| −1。

在类似这样的流网络中寻找某种最大收益的问题，就是最大流问题，最大流问题一般都要求满足以下三个条件：

  * 假设一条边 (u,v) 当前实际输送物品的量为 f(u,v)，则 f(u,v) < c(u,v)；
  * 流量对称，假设边 (u,v) 输送物品的量是 f(u,v)，则肯定有相同的物品能从 v 点退回到 u 点，即 f(u,v) = -f(v,u)；
  * 流量平衡，即除了源点和汇点，其他点都不能暂存物品，也就是说流入一个点多少物品，就得有多少物品从这个点流出；特别地，从源点输出物品的数量与汇点收到的物品数量相等。

#### 最大流问题的意义

以输水问题为例，直觉上把所有的水管都撑满，自然就能得到最大输水量，实际情况却不是这样的，我们以只有四个顶点的一个小网络为例，解释一下最大流问题的意义。

![](https://images.gitbook.cn/c5cbc5f0-fc1c-11e8-8f61-f977f7ec6009)

图（2）最大流选择过程示意图

如图（2-a）所示，由顶点 0、1、2 和 3 组成的有向图中，0 是源点，3 是汇点。如果第一次选择通路为 0→1→3 这条管路，能通流的最大值是
5，此时各个管路的情况如图（2-b）所示；接下来再选择 0→1→2→3 这条管路，发现还可以扩容 3 个流量，如图（2-c）所示；最后发现，选择 0→2→3
这条管路，还可以再扩容 1 个流量，如图（2-d）所示，最终这个图中的最大流量就是 9。

图（2）所演示的只是我们选择管路的一种方法，当然还有其他选择管路的方法，图（3）就演示了另一种选择方法，如图（3-a）所示，我们第一次选择 0→1→2→3
这条管路，能通流的最大值是 4；接着选择 0→1→3 这条管路，发现能扩容 4
个流量，如图（3-b）所示，此时已经不能再选择其他管路扩容流量了，最终得到的最大流量是 8。可以看出来，这种选择并没有充分利用管路的容量，管路 1→3
就只使用了总容量的 4/5。

![](https://images.gitbook.cn/d51c5dd0-fc1c-11e8-8f61-f977f7ec6009)

图（3）不是最大流量的一个选择过程

由上述分析可知，流网络不是随随便便就能获得最大流，在选择通路的时候，要考虑容量、流量和选择顺序等多个因素，才有可能得到最后的最大流结果。

### 最大流算法原理

最大流问题最常用的经典算法是 Ford-Fulkerson 算法和 Edmonds-Karp
算法，严格来说，这两种算法都不是具体的算法，而是方法，或者可以理解为算法流程。这两种算法的实现思想都是在流网络中每次都选择最优的增流路径，逐步扩大流量，直到不能再选择增流路径为止，最后得到的流量就是最大流。

这两种算法的区别就是选择增流路径的方式，Ford-Fulkerson
算法采用深度优先搜索算法搜索增流路径，选择到一个路径就使用这条路径，必要时回溯；Edmonds-Karp
算法则采用广度优先搜索算法搜索增流路径，然后通过比较选择使用最短的那条增流路径。

#### 残量网络（Residual networks）和增流路径

残量网络是指给定的流网络中，各条路径上剩余的容量组成的流网络。对于一条路径 (u,v)，如果其容量是 c(u,v)，当前的流量是 f(u,v)，则其剩余容量
r(u,v) = c(u,v)−f(u,v)。每条边上的剩余容量组成的流网络就是残量网络，简单理解，就是 c 代表的容量网络减去 f
代表的流量网络，剩下的就是残量网络。

举个“栗子”吧，仍然以图（1）所示的流网络为例，假设某一时刻已经选择的增流路径如图（4-a）所示，则其对应的残量网络就是图（4-b）所示的流网络。注意图（4-b）中各边的容量已经被调整为
c(u,v)−f(u,v)的值，红色边是反向弧，下一节介绍反向弧。

![enter image description
here](https://images.gitbook.cn/e3517390-fc1c-11e8-aae4-7b05c4e3ac9c)

图（4）残量网络和反向弧示意图

对于一个流网络 G(V,E) 和已知的流 f，增流路径 p 是其残量网络 G−f 中的一条从 s 到 t
的路径。在不影响反向边容量规则的条件下，可以向这条路径压入流量，从而增加整个网络的流量值。在“最大流问题的意义”这一节，我们所选择的扩容管路，其实就是增流路径。对于图（4-b）所示的残量网络中，还可以选择的一条增流路径就是
0→2→4→3→5 这条路径，还可以扩容的流量是 3。

#### 反向弧

图（3）展示了一种得不到最大流结果的增流路径选择过程，因为一开始选择了 0→1→2→3 这条路径，使得我们没办法再通过 0→2
这条路径增加流量，只能继续通过 0→1 这条路径增加流量，而这条路径最多只能再增加 4 的流量，因此最终只得到了 8，没有得到最大值
9。那么问题来了，在选路径的时候，如何在已经选择 0→1 的时候，下一个点选择 3，而不是 2 呢？显然，我们可以用穷举，把 2 和 3
都选择一下，然后通过回溯比较，得到最优的结果。当然，如果真是这样，这里介绍的两个算法也就称不上是著名算法了。Ford-Fulkerson 算法和
Edmonds-Karp
算法都是利用了反向弧，巧妙地解决了选择错误路径的问题，使得无论最初的选择怎样糟糕，最后都有机会被纠正回来，最终得到正确的最大流结果。

前面提到过，流网络的三大特点之一就是流量对称，物品能被原路退回的方向就是流量方向的反向弧。反向弧与流量方向对应，无论是否有反向边，反向弧都假设存在，反向弧与流量方向一样，也有容量。假设流量方向的容量是
c(u,v)，则其反向弧的容量就是 c(v,u)。每当边 (u,v) 被选入一条增流路径时，假设增加了 delta 的流量，则相应的流量方向的容量要减去
delta 进行修正，即 c(u,v) = c(u,v)−delta。同时，对应的反向弧方向的容量就要加上 delta 进行修正，即 c(v,u) =
c(v,u) + delta。

特别地，当流网络中顶点 u 和 v
本身就存在双向连通的边的时候，那么每个流量方向的反向弧的容量与相反的那个流量方向的容量叠加，统一视为反向弧的容量。如图（4-b）所示的顶点 1 和 2
之间本身就存在双向连通的边，当 (2,1) 方向流量增加 1 后，其对应的容量 c(2,1) 就由 4 变成了 3，而反向弧 (1,2) 方向的容量就变成了
11，其中 10 是边 (1,2) 本身就有的容量。

那么反向弧是怎么起到纠正结果的作用呢？我们仍然以图（5-a）所示的小流网络为例，假设已经错误地选择了 0→1→2→3
这条路径，此时的残量网络和反向弧的容量如图（5-b）所示。为了更好地说明反向弧对物品输送的影响，我们对图中的数字表达的意义做了调整，每条边对应的两个数字中，斜杠左边的是当前已经输送的物品量，斜杠右边的数字是当前边的剩余容量。剩余容量随着物品输送会减少，二者的和就是对应的边的原始容量。观察图（5-b），我们发现可以利用反向弧的存在，选择
0→2→1→3 这条路径，流量是 2，正好抵消了选择 0→1→2→3 这条路径时从边 (1,2) 过来的 4 个单位流量中的 2 个，相当于退回去了 2
个单位的流量，于是退回去的这两个单位的流量就可以选择走 (1,3) 这条边到达汇点，相当于纠正了最初的那个错误选择。选择 0→2→1→3
这条路径之后，残量网络的结果就如图（5-c）所示。这时候我们发现，根据各边的残余容量，只有 0→1→3 这条路径上还有剩余容量，并且剩余容量是
3，于是我们选择这条路径，总流量就再增加 3，如图（5-d）所示，此时再也找不到增流路径了，最后的结果就是 9，也就是我们已知的最大流量。

![](https://images.gitbook.cn/f0a291f0-fc1c-11e8-bbcf-cbd4eb4d6c32)

图（5）反向弧作用示意图

这就是反向弧的意义，利用反向弧的反向抵消作用，隐含着起到流量退回并重新选择路径的作用。

#### 算法思想

两种最大流算法的基本思想是一样的，就是在流网络以及流网络得到的残量网络中选择一条从源点到汇点的增流路径，根据增流路径计算最大流。算法的整体步骤是：

（1）从残量网络中寻找一条从源点到汇点的增流路径；

（2）求出该增流路径上的最小流量值，使路径上各边的容量都减去这个值，并在各边对应的反向弧的容量上都加上这个值；

（3）重复（1）、（2），直到无法再找到增流路径，将每次得到的流量值累加，结果就是最大流的值。

由此可见，这两种算法本质上都是使用了迭代的方法，初始时，图中的有向边的流量初始化为 0，即 f(u,v) =
0。每次迭代搜索到一条增流路径来增加流量，同时修改残量网络中该边的剩余容量 c(u,v) ，以及反向弧的剩余容量
c(v,u)。重复这一过程，直到找不到新的增流路径为止。

### 最大流算法实现（Edmonds-Karp 算法）

前面已经提到过 Ford-Fulkerson 算法和 Edmonds-Karp
算法的细微差别，我们以第一节给出的《算法导论》书中的这个题目为例，介绍一下如何实现 Edmonds-Karp 算法。

首先要定义数据模型表达流网络和残量网络。从算法原理上描述，我们需要维护每条边和它对应的反向弧的容量。这是一个以边为中心的算法，因此用邻接矩阵表达流网络和残量网络所代表的图。邻接矩阵除了描述对应顶点之间是否有边的关系之外，还可以承载一个重要的属性，就是对应边的剩余容量。

    
    
    typedef struct
    {
        int node;
        int c[MAX_GRAPH_NODE][MAX_GRAPH_NODE];
    }MF_GRAPH;
    

#### 寻找增流路径

大家记住，对一个图进行广度优先搜索，你需要一个栈或队列存储当前图中搜索到的，但是还来不及展开搜索的顶点。除此之外，还需要为每个顶点设置一个标志，标记它是否已经被访问过。我的习惯是在模型上给每个顶点用数字编号，用队列存储搜索过程中的顶点，用
visit[] 数组作为访问标志。

正如 find_augmenting_path() 函数所示，这是我惯用的广度优先搜索算法模式。这个函数的意义就是从给定的源点 s 开始，广度优先搜索与 s
相连的顶点，只要这些顶点还没有被访问过，并且对应边还有剩余容量，就将这个顶点入队；然后对队列中的顶点依次重复上述搜索过程，直到到达汇点 t；到达汇点 t
说明找到了一条从源点到汇点的路径，并且这条路径上的每条边都还有剩余容量。

path[] 数组存储增流路径上的顶点关系，path[]
数组没有用顺序存储顶点的方式，而是利用搜索算法过程中的顶点关系，借助于链表的思想存储顶点之间的关系。简单的说就是 path[]
的每个元素对应的下标是边的终点，数组元素的值是边的起点。根据这个关系，可以从汇点 t
向前反推出增流路径上的各个顶点。举个“栗子”，假如某次搜索得到了一条增流路径 0→1→3，则对应数组中的值是 path[3] = 1，从汇点 3
可以得到顶点 1，此时 path[1] = 0，根据顶点 1 可以得到起点 0，这就是 path[] 数组的存储方式和反推过程。

    
    
    bool find_augmenting_path(MF_GRAPH& g, int s, int t, int path[])
    {
        std::queue<int> q;
        bool visit[MAX_GRAPH_NODE] = { false };
    
        q.push(s); //源点入队
        visit[s] = true; //设置访问标志
        while (!q.empty())
        {
            int current = q.front(); //从队列中去一个顶点
            q.pop();
            for (int i = 1; i <= g.node; ++i) //遍历这个顶点和其他顶点的关系
            {
                if (!visit[i] && (g.c[current][i] > 0)) //没有访问过，并且对应边有剩余容量
                {
                    visit[i] = true;
                    path[i] = current;
                    q.push(i);
                    if (i == t) //遍历到汇点了？得到结果
                    {
                        return true;
                    }
                }
            }
        }
    
        return false;
    }
    

找到一条增流路径后，这条路径到底能增加多少流量呢？能增加的流量取决于这条路径上剩余容量最小的那条边的剩余容量。根据前面对 path[]
的理解，遍历路径上的每条边，找出此条增流路径的增加量 delta：

    
    
    int get_min_delta(MF_GRAPH& g, int s, int t, int path[])
    {
        int delta = 0x7FFFFFFF; //通过比较求最小值时的常用伎俩
    
        int i = t;
        while (i != s)
        {
            if (delta > g.c[path[i]][i])
            {
                delta = g.c[path[i]][i];
            }
    
            i = path[i];
        }
    
        return delta;
    }
    

#### Edmonds-Karp 算法

edmonds_karp() 函数的 while 循环执行迭代过程，每次找到的增流路径增加量就叠加到变量 max_flow
上，当无法找到增流路径的时候，返回得到的 max_flow。

modify_residual_networks() 函数负责根据 delta
对增流路径上的每条边进行剩余容量修正。无论是有向图中的正向边还是反向弧，不加区分，只根据当前增流路径的方向执行剩余容量的加和减修正。当然，在搜索增流路径的时候，也是不区分有向图中的正向边和反向弧的，这一点需要结合“反向弧”这一节的介绍自己体会这个算法的巧妙之处。

    
    
    void modify_residual_networks(MF_GRAPH& g, int s, int t, int path[], int delta)
    {
        int i = t;
        while (i != s)
        {
            g.c[path[i]][i] -= delta;
            g.c[i][path[i]] += delta;
            i = path[i];
        }
    }
    
    int edmonds_karp(MF_GRAPH& g, int s, int t)
    {
        int max_flow = 0;
        int path[MAX_GRAPH_NODE] = { 0 };
    
        while (1)
        {
            //memset(path, 0, sizeof(path)); //这里可以清 0，也可以不清 0
            if (!find_augmenting_path(g, s, t, path))
            {
                break;
            }
            int delta = get_min_delta(g, s, t, path);
            modify_residual_networks(g, s, t, path, delta);
            max_flow += delta;
        }
    
        return max_flow;
    }
    

最后，用我们的算法对问题求解，得到了期望的最大流值 23。

### 总结

这一课我们介绍了用 Ford-Fulkerson 算法和 Edmonds-Karp 算法求解最大流问题的算法原理，并给出了一个 Edmonds-Karp
算法的实现过程。但是有个问题没有解释，那就是凭什么说用这种方法求的结果就是最大流？这个证明就需要用到流网络的割这个概念，以及最小割原理，有兴趣的读者可以查阅相关的资料了解其证明过程。

和大多数图论的算法一样，最大流问题的算法模板也是“玩算法”必备之物。当然，前提还是要弄懂算法的原理，因为实际应用的时候，少不了是要根据题目的条件重新设计数据模型的。只要弄懂原理，改改模型，套个模板，算法实现就有了。

最后说说最小费用最大流问题，最小费用最大流问题，其实就是在最大流问题的基础上叠加一个开销最小化的条件。解决最小费用最大流问题，一般有两种常用的方法：一种是先用最大流算法算出最大流，然后根据给出的最小边费用条件，检查是否有可能在流量平衡的前提下通过调整各条边上的流量，使总费用得以减少；使用迭代的方法，每次调整一点（减少一点总费用），然后在这个基础上再调整一点，直到无法调整为止，就得到最小费用的最大流。

另一种方法是按照最大流算法的思路，从零开始构建最大最小流；一开始用零流量作为初始流，费用自然也是零；然后像最大流算法一样，开始找从源点到汇点的增广链，只是在寻找增广链的时候考虑费用问题，要求找到的增广链是所有增广链中费用最小的一条。如果能找到这样的增广链，就在增广链上增加流量，然后继续寻找最小费用的增广链，一直迭代下去，直到找不到增广链为止，得到的就是最小费用最大流。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

