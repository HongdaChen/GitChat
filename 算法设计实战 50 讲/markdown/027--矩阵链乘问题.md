>
> 这一课介绍的矩阵链乘问题，是区间类型动态规划的典型例子，区间类型的动态规划是在线性动态规划基础上的扩展。我的理解是，这个扩展就是将固定的线性问题变成一个变长的线性问题，也就是说，所谓的区间动态规划，就是在一个可选择的线性区间中寻找某种最优的结果，而线性区间长度本身也是可变化的，最优结果的组合也是可变化的，需要在两重变化中寻找最优解。除了矩阵链乘问题，此类问题的典型例子还有石子合并问题、能量项链问题、最优排序二叉树问题等。除此之外，前几年非常火的多边形三角剖分问题，也被归纳为区间动态规划类型的题目。

### 问题介绍

《算法导论》一书在介绍动态规划问题时，举了一个矩阵链乘（Matrix-chain
Multiplication）的例子。我知道很多读者害怕公式，看见《矩阵论》就头疼，但是不要怕，这个题目只涉及了一个简单的概念，就是矩阵的相容性（Compatible）。矩阵
A 和 B 能够相乘，前提是矩阵 A 和矩阵 B 必须相容，所谓的相容，就是矩阵 A 的列数等于矩阵 B 的行数。假设矩阵 A 是 $p\times q$
的矩阵，矩阵 B 是 $q\times r$ 的矩阵，则矩阵 A 和矩阵 B 的乘积是一个 $p \times r$ 的矩阵。计算这个乘积需要
$p\times q\times r$ 次标量乘法计算和若干次加法，其计算量的主要代价就是这 $p\times q\times r$ 次乘法计算。

对于一组满足相容性条件（顺序）排列的矩阵做链乘，无论选择中间哪两个矩阵先计算，其结果都能与剩下的矩阵继续保持相容性条件，这是一个很重要的前提，因为调整矩阵的位置会破坏相容性。但是，在矩阵位置不变的情况下，选择计算的顺序对标量乘法的计算量有巨大的影响。例如，有三个矩阵
A B C 相乘，其中 A 是 $10 \times 100$ 的矩阵，B 是 $100\times 5$ 的矩阵，C 是 $5 \times 50$
的矩阵。如果我们按照（（A B）C）的顺序计算，则需要计算的乘法次数是 10 × 100 × 5 + 10 × 5 × 50 = 7500
次。如果我们按照（A（B C））的顺序计算，则需要计算的乘法次数是 100 × 5 × 50 + 10 × 100 × 50 = 75000
次。可见，第二种计算方法需要的计算量是第一种方法的 10 倍。那么，最后的问题来了，对于 n 个矩阵序列 $A _{1}, A_ {2}, A
_{3},…,A_ {n}$，我们要计算它们的乘积，请用括号化的方式给出一种计算次序，使得最终需要的标量乘法次数最少。

### 算法原理分析

根据我们的经验（读者也应该掌握这个经验），典型的线性动态规划问题，一般会将状态定义为 $f[i, j]$，其中 $i$ 代表状态出现的位置，$j$
代表阶段的划分。对于矩阵链乘问题，阶段的划分其实就是参与相乘的矩阵的数量，每多一个矩阵参与乘法计算，阶段就增加一个。因此，对于本问题，位置 $i$
就是参与计算的矩阵链的第一个矩阵的编号，阶段 $j$ 其实就是参与链乘计算的最后一个矩阵的编号，状态 $f[i, j]$ 就是矩阵 $A _{i}A_
{i+1},…,A_{j}$ 乘积的最优解。

有了状态的定义，实际上子问题就很清晰了，就是矩阵序列 $A _{1}, A_ {2}, A _{3},…,A_ {n}$
中的一个子串，那么这样定义子问题是否满足无后向性要求呢？我们来分析一下，假设子问题 $A _{3}A_ {4}A _{5}$ 的最小标量乘法次数是状态
$f[3,5]$，那么它前面的矩阵 $A_ {2}$ 无论是直接和 $A _{3}A_ {4}A _{5}$ 的结果相乘，还是 $A_ {1}$ 和 $A
_{2}$ 先相乘，然后再和 $A_ {3}A _{4}A_ {5}$ 的结果相乘，都不影响 $A _{3}A_ {4}A _{5}$
之前计算出来的结果（即状态 $f[3,5]$ 的值）。$A_ {3}A _{4}A_ {5}$
的结果与后面的矩阵做乘法运算，无论以何种方式组合相乘，也同样都不会改变状态 $f[3,5]$ 的值，因此，我们这样划分的子问题满足无后向性要求。

那么，状态 $f[i, j]$ 怎么计算呢？很简单，就是将其分解为更小一点的子问题，通过求解子问题的状态递推计算状态 $f[i, j]$ 的值。设区间
$[i,j]$ 之间有分割点 $k$ 满足 $i\leq k < j$，则以 $k$ 为分割点时得到的状态结果就是：

$$ f[i,j]_{k} = f[i,k] + f[k+1,j] + cost(k) $$

其中，$cost(k)$ 是两个子问题得到矩阵相乘的开销，即标量乘法的次数。区间 $[i,j]$ 之间能有多少个分割点 $k$，就有多少个 $f[i,j]
_{k}$，最后状态 $f[i, j]$ 取所有 $f[i,j]_ {k}$ 中最小的那个即可：

![enter image description
here](https://images.gitbook.cn/f5133fe0-ed31-11e8-886c-4bc472f97234)

怎么理解这个公式呢，我们用一个实际例子来解释一下。假设有以下 6 个矩阵：

$$ \begin{matrix} Matrix & Dimension \ \------- & \-------- \ A _{1} & 30
\times 35 \ A_{2} & 35 \times 15 \ A _{3} & 15 \times 5 \ A_{4} & 5 \times 10
\ A _{5} & 10 \times 20 \ A_{6} & 20 \times 25 \end{matrix} $$

则状态 $f[2, 5]$ 的值可由以下递推关系得出（从三个分割结果中选择最小的那个）：

![enter image description
here](https://images.gitbook.cn/0a66ff30-ed32-11e8-af60-6f3fcafbf22b)

那么，读者可能会问，既然可以拆分成子问题，那为什么只拆成两个子问题，难道不能拆成更多的子问题？当然，为了遍历各种组合情况，我们也会拆分更多的子问题，但是无论怎么拆分，最终都是得到各种规模的子问题所组成的一张表。那么怎么做到拆分各种规模的子问题呢？回忆一下[第4-1课：如何理解动态规划](https://gitbook.cn/m/mazi/columns/5b6d05446b66e3442a2bfa7b/topics/5bdfb1b7665e8a7d7349edbc)中给出的区间类型动态规划算法实现模式，套用一下就好了：

    
    
    for(区间长度 size：从最小可分区间开始到最大区间长度)
    {
        for(小区间起始位置 i：从第一个位置开始到区间长度 size 所决定的结束位置)
        {
            j = i + szie - 1; //j 定义区间结束位置，具体计算方法因问题而异
            for(区间分割点位置 k：从 i 开始到 j 结束)//遍历所有区间 [i,j] 内的位置，将其分割为两个小区间
            {
                f[i][j] = min(f[i][j], f[i][k]+f[k][j] + cost(k));
            }
        }
    }
    

第一层 for 循环定义区间大小，就是最大子问题的规模，一般从 2 开始循环，表示子问题从最少 2 个矩阵开始。第二层 for
循环遍历子问题的起始位置，也就是子问题 $A _{i}A_ {i+1},…,A _{j}$ 中 $A_ {i}$ 的位置。第三层循环就是遍历分割点
k，尝试以各种顺序拆分子问题。

以前面给出的 6 个矩阵为例，当区间 size = 2 的时候，依次计算出了规模是 2 的各个子问题的状态，即
$f[1,2]$、$f[2,3]$、$f[3,4]$、$f[4,5]$ 和 $f[5,6]$ 的值。当 size = 3 的时候，再依次计算出了规模是 3
的各个子问题的状态，即 $f[1,3]$、$f[2,4]$、$f[3,5]$ 和 $f[4,6]$ 的值。规模为 3 的子问题状态由上一层计算出来的规模为
2 的子问题的状态递推计算处理，以 $f[1,3]$ 为例，就是取（$f[1,2]$+$f[3,3]$ + cost(2)）和（$f[1,1]$+
$f[2,3]$ + cost(1)）两个值中较小的那个。依次类推，当 size = 6 的时候，整个循环就只计算了 $f[1,6]$
的值，它是由之前计算的各种规模的子问题的状态递推计算出来的，最终的解也就是
$f[1,6]$，因为这就是最大子问题的规模，也就是原始问题的解。完整的状态关系图如图（1）所示，左边是状态递推关系，右边是状态对应的实际乘法计算次数。

![enter image description
here](https://images.gitbook.cn/ecc0a130-e641-11e8-9404-598148498eff)

图（1）状态递推关系示意图

好了，可以考虑将这个伪代码描述的模式翻译成代码了，等等，我们好像忘了什么东西。我们定义了子问题和子问题的状态，还有状态的递推计算公式，但是漏掉了边界条件（初始值），也就是
size = 1 时的情况，对于 size = 1 的情况，矩阵当然不需要自己乘自己，也就是不需要做任何乘法计算，显然 $f[1,1]$ =
$f[2,2]$ = … $f[6,6]$ = 0。

### 算法实现

尽管有了三层循环的算法模式框架，也有了递推关系式，但是要实现算法还有一些细节需要确定，比如递推关系中 $cost(k)$
的计算、各层循环中循环变量范围处理的细节等。

#### 计算 $cost(k)$

$cost(k)$ 就是分割点为 k 的时候，矩阵 $A _{i} … A_ {k}$ 乘积的结果矩阵与矩阵 $A _{k+1} … A_ {j}$
乘积的结果矩阵做乘法需要的标量乘法次数。$A _{i} … A_ {k}$ 乘积的结果矩阵的规模是 $A _{i}$ 的行数 × $A_ {k}$
的列数，$A _{k+1} … A_ {j}$ 乘积的结果矩阵的规模是 $A _{k+1}$ 的行数 × $A_ {j}$
的列数。由于矩阵乘法的相容性，矩阵 $A _{k}$ 的列数等于 $A_ {k+1}$
的行数，否则它们就无法再链乘下去了。因此，最终这两个结果矩阵做乘法需要的标量乘法次数 $cost(k)$ = $A _{i}$ 的行数 × $A_ {k}$
的列数 × $A_{j}$ 的列数。

根据矩阵的相容性，矩阵链中前一个矩阵的列数必然等于后一个矩阵的行数，所以实际编写算法代码的时候，没有必要为这些矩阵准备一个行数和列数的集合，只需要将它们压缩到一个一维数组中即可。以前面给出的
6 个矩阵的例子，我们将它们的行数和列数整理成数组 p：

    
    
    int p[] = { 30,35,15,5,10,20,25 };
    

对任意矩阵 $A _{i}$ 来说（我们不使用 $A_ {0}$，后面会有解释），它的行数就是 p[i−1]，它的列数就是 p[i]。例如，$A _{1}$
的行数是 p[0] = 30，列数是 p[1] = 35；同样，$A_ {2}$ 的行数是 p[1] = 35，列数是 p[2] =
15。使用这样的压缩数组的好处就是计算 $cost(k)$ 的算法代码很简单：

    
    
    cost(k) = p[i - 1] * p[k] * p[j];
    

#### 数据模型

实际上，上面已经介绍了用于计算矩阵乘法开销的压缩数组 p，除了这个数组，我们还需要一个记录状态 $f[i,j]$
的数据结构，其实也很简单，就是一个二维数组。前面提到过，矩阵的位置索引是从 1 开始，所以这个二维数组中 f[0,0]，以及 f[0,0]
所在的行和列都没有用到，我们直接从 f[1,1] 开始。

除了表示子问题结果的状态数组 f，我们还需要一个记录子问题最优分割点的位置 k
的数组，记录每个子问题的最优分割点的目的是为了最后输出结果。为了与子问题对应，我们同样用一个二维数组 s 存放每个子问题的最优分割点位置，s[i,j]
表示子问题 f[i,j] 对应的最优分割点。图（2）是与前面例子矩阵对应的 s 数组结果，最终输出结果的时候，从 s[1,6] 反向递推出括号化的计算顺序。

![enter image description
here](https://images.gitbook.cn/fd8bcb20-e641-11e8-8d3f-83d6dfd9a3ff)

图（2）最优分割点 s 数组记录示意图

#### 算法实现

代码的实现就是对上面的模式代码的简单翻译，没有特别值得说明的地方。最内层循环求最小值，给 f[i][j]
赋初始值为最大整数，这也是求一系列数值中最小值的常用技巧，先给一个明显超出问题域的最大值，然后再用其他值更新它。只要算出来的 q 比 f[i][j]
小，就更新 f[i][j]，同时记录分割点的位置 k 到 s[i][j] 中。

    
    
    void matrix_chain_order(int *p, int n, int f[][M], int s[][M])
    {
        for (int i = 1; i <= n; i++) /*初始化默认值*/
        {
            f[i][i] = 0;
        }
    
        for (int size = 2; size <= n; size++)     /* 矩阵链的长度 */
        {
            for (int i = 1; i <= n - size + 1; i++) /*子问题矩阵链起始位置*/
            {
                int j = i + size - 1;         /* 子问题矩阵链结束位置 */
                f[i][j] = INT_MAX;
                for (int k = i; k < j; k++)  /*分割点k的遍历*/
                {
                    int q = f[i][k] + f[k + 1][j] + p[i - 1] * p[k] * p[j];
                    if (q < f[i][j])
                    {
                        f[i][j] = q;
                        s[i][j] = k; //记录 f[i,j] 的最优分割点位置
                    }
                }
            }
        }
    }
    

我个人认为在各种动态规划题目中，结果输出部分是最有意思的地方。大家可能注意到了，基本上都是根据最优解的决策点反向递推出原始问题的决策过程，本题也不例外。最终结果
s[1,6] 记录了最大的子问题 f[1,6]（当然就是原始问题）的最优分割点的位置，以本题为例，s[1,6]=3。根据这个位置，f[1,6] 的结果是由
f[1,3] 和 f[4,6] 两个子问题递推出的最优解；同理，s[1,3]=1，说明子问题 f[1,3] 的结果是由 f[1,1] 和 f[2,3]
两个子问题递推出的最优解。以此类推，可以逐级找到各个子问题的分解方式，直到遇到 s[1,1]、s[2,2]、…、s[6,6] 时结束递推查找。

根据上面的分析，输出结果的过程是一个隐含的递归过程，用递归方法实现算法比较简单。老规矩，先找递归三要素中的递归退出条件和递归子结构的主体。递归退出条件就是子问题的规模是
1 的时候，此时直接输出子问题矩阵本身即可；递归主体部分的处理就是找出子问题的分割点 k，将输出委托给子问题 [i,k] 和 [k+1,j]
继续输出。别忘了，题目要求是要输出括号化的结果，就是用括号表示矩阵计算的次序，所以，要将子问题 [i,k] 和 [k+1,j]
的输出用括号括起来。整个递归函数的框架大概是这个样子：

    
    
    void print_optimal_parens(int s[][M], int i, int j)
    {
        if (i == j)
        {
            std::cout << "A" << i;
            return;
        }
    
        int k = s[i][j]; //该子问题的最佳分割点
        std::cout << "(";
        print_optimal_parens(s, i, k);
        print_optimal_parens(s, k + 1, j);
        std::cout << ")";
    }
    

不要被各种子问题的描述迷惑，这个不是分解子问题类型的递归，这个仍然是同一问题的结构变形模式。问题仍然是 matrix_chain_order()
函数求解得到的分割点表 s，所以，s 必须是递归函数的参数。另外，还需要标识问题范围的参数，很显然，这个范围就是对应子问题分割的范围 [i,j]，所以 i
和 j 也需要通过函数参数传递。这样一来，print_optimal_parens() 函数的参数基本上就定了：

    
    
    void print_optimal_parens(int s[][M], int i, int j)
    

定好函数参数，递归函数主体内的细节就可以确定了，判断子问题的规模是 1，就可以用 i 和 j 是否相等来表达，若 i 和 j 相等，则问题规模是
1，否则规模就不是 1，这很容易理解。分割点 k 就是 s[i][j] 中存放的值，两次递归调用的再触发，传递的范围用 k
分割一下即可，这就是整个输出函数的实现：

    
    
    void print_optimal_parens(int s[][M], int i, int j)
    {
        if (i == j)
        {
            std::cout << "A" << i; //输出 Ai
            return;
        }
    
        int k = s[i][j]; //该子问题的最佳分割点
        std::cout << "(";
        print_optimal_parens(s, i, k);
        print_optimal_parens(s, k + 1, j);
        std::cout << ")";
    }
    

### 总结

区间类型的动态规划不太容易理解，它在线性动态规划的基础上多了一层区间的变化，但是其问题的状态依然是二维的，仍然可以用二维状态定义反推出子问题的定义，为求解问题打开缺口。同时，记住区间类型动态规划解法的典型三重循环模式，也能事半功倍。

好了，问题来了，这一课的问题也是经典的“石子合并”问题。在操场上沿一直线排列着 n
堆石子（每一堆石子的个数不相等），现要将石子有次序地合并成一堆，规定每次只能选相邻的两堆石子合并成新的一堆，并将新的一堆石子数计为该次合并的得分，我们希望这
n−1 次合并后得到的得分总和最小，请给出合并的顺序。

举个“栗子”，假设有三堆石子，个数分别是 2、3 和 9，合并的顺序就是两种，分别是（（2 3）9）和（2 （3
9））。以第一种方式合并石子，第一次合并得到两堆石子分别是 5 和 9，同时得到积分为 5，然后第二次合并，积分累加 14（5 + 9 = 14），共得
19 分；以第二种方式合并石子，第一次合并得到两堆石子分别是 2 和 12，同时得到积分为 12，第二次合并，积分累加 14（2 + 12），共得 26
分，显然，第二种合并方式得分高。

这个题目和矩阵链乘非常像，矩阵链乘是相邻矩阵才能计算，这个题目是相邻的两堆石子才能合并，算法框架基本一致，差别就在状态的递推关系式，一个是求最小值，一个是求最大值，感兴趣的读者可以试试。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

