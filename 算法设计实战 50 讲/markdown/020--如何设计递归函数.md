这一篇内容是根据读者的反馈，补充了一些原来课程中没有规划的内容。考虑到有的读者不经常去读者圈提问题，在此建立一个读者群，可加“madacui”微信号拉您进群，请备注：算法读者，谢谢~

另外，本课程的代码[请戳这里](https://github.com/inte2000/play_with_algo)。

### 如何分析递归程序

递归不是“先有鸡还是先有蛋的问题”，也不是“从前有座山，山里有座庙……”，严格来说，递归应该不是算法设计，而是算法实现范畴的内容，因为它并不属于任何一种算法模式。作为算法实现的一种常用形式，递归程序常常让新手望而却步。难在两点，其一是相对于顺序执行的线性代码或重复执行的循环代码，递归程序不是很容易在脑子里形成代码流程，分析代码的时候，常常在几层递归调用之后，就记不得各层递归调用的上下文环境了；其二是递归程序设计比较困难，新手常常感觉无从下手。这一课，我就从递归程序的分析方面分享一些我的经验。

分析递归程序，不要像分析循环或线性程序代码那样，直接带入上下文环境进行死算，因为这样很容易迷失在代码细节中，只见树木、不见森林，最后都记不得哪一层参数是哪一层的上下文环境了。递归体现的是类似与“以此（方法）类推”或“以同样的操作模式（步骤）重复……”这样的思想（有点类似于数学归纳法）。因此，我的经验是先总体上分析一下代码，看看这个递归程序的整体结构是什么，各种类型的递归算法实现虽然在形式上有很大的差异，但是总体上其实都可以划分成三个主要组成部分：

  * 第一个组成部分就是递归子结构（或递归主体），所谓递归子结构就是递归程序中可重入的主体部分；
  * 第二个组成部分是递归的退出条件和退出处理，很显然，如果没有退出条件，就会无穷递归下去，直到栈溢出，但需要注意的是，递归退出条件可不仅仅是控制递归退出，很多情况下都会在满足退出条件时做一些处理，比如直接解决最小子问题 （这一句不理解没关系，后面看例子）；
  * 第三个组成部分是递归算法的自我再触发机制，如果没有再触发的机制，自然就没有递归过程了，一般情况下，递归的再触发机制常常包含在递归子结构的处理过程中，很多情况下区分不是很明显，读者只要记得，再触发机制就发生在递归函数自我调用的地方，分析这部分的代码就可以找到再触发机制，至于是否一定要和递归子结构区分开来，倒也未必一定需要这么做。

#### 二叉树遍历的简单例子

下面来看一个经典的二叉树前序遍历算法，这是个数据结构课的“Hello
World”算法。按照我们的思路，首先找到递归的退出条件，就是从上一级递归触发机制传递进来的节点指针是 NULL
的时候，表示已经遍历到二叉树叶子节点的子树了（叶子节点的子树指针是
NULL），不需要对其进行递归子结构主体部分的操作了。一个设计良好的递归函数，一般都会在函数入口位置进行退出条件的判断，我们在设计递归函数实现的时候，最好也在显眼位置放置退出的代码。接下来的
std::cout
是打印数据，算是对数据的操作，后面分别对左子树和右子树的递归调用就是我们说的再触发机制。这个遍历算法的再触发机制非常简单，就是先对左子树来一波操作，再对右子树来一波操作，然后结束。递归程序中的再触发机制只是按照问题的解决方案触发递归调用，至于递归调用做什么操作，再触发机制是不关心的，它只知道现阶段无法解决这个问题，需要把问题用递归的方式委托给“自身”，通过函数参数通知“自身”这次递归调用要处理什么数据，希望“自身”在条件具备的时候解决委托给它的问题。至于这次递归调用做什么操作，那是递归子结构关心的事情。

    
    
    struct TreeNode
    {
        int data;
        TreeNode *left;
        TreeNode *right;
    };
    
    void PreOrderPrint(TreeNode *node)
    {
        if (node == NULL)
            return;
    
        /*对节点的操作，本函数只是输出节点数值*/
        std::cout << node->data << std::endl;
    
        PreOrderPrint(node->left); //继续遍历左子树
        PreOrderPrint(node->right); //继续遍历右子树
    }
    

#### 经典汉诺塔递归程序

一般来说，递归程序中的退出条件是比较好识别的，难点主要是递归子结构和递归再触发机制的理解和分析。我的经验是从递归函数的参数入手，分析它的递归再触发机制。因为所谓的再触发，其实就是把各个参数包装或转换一下，再掉用一次函数“自身”，所以，函数参数是理解再触发的关键。

现在来看一个经典的汉诺塔游戏算法的递归实现。在这个递归实现中，递归退出部分好像不是很明显，这是很正常的，不同的人有不同的代码风格，这种情况只能从代码流程入手分析出退出处理。从这个函数的代码分支流程分析可以看出来，当只有
1 个环的时候，做了从 s1 号柱子移到 s3 号柱子的操作后直接结束了，没有走递归子结构主体部分的分支，显然，这个就是递归退出条件以及在退出时的处理。

    
    
    void hanoi(int n, int s1, int s2, int s3)
    {
        if (n == 1)
        {
            move(s1, s3);
        }
        else
        {
            hanoi(n - 1, s1, s3, s2);//步骤1 把 1 号柱子上面的 n-1 个环经过 3 号柱子移到 2 号柱子上
            move(s1, s3);            //步骤2 把 1 号柱子剩下的（最大的）一个盘子移到 3 号柱子上
            hanoi(n - 1, s2, s1, s3);//步骤3 最后把之前移到 2 号柱子上的 n-1 个环经过 1 号柱子移到 3 号柱子上
        }
    }
    

实际上对于我来说，我更喜欢下面这个风格的实现：

    
    
    void hanoi(int n, int s1, int s2, int s3)
    {
        if (n == 1)
        {
            move(s1, s3);
            return;
        }
    
        hanoi(n - 1, s1, s3, s2);//步骤1 把 1 号柱子上面的 n-1 个环经过 3 号柱子移到 2 号柱子上
        move(s1, s3);            //步骤2 把 1 号柱子剩下的（最大的）一个盘子移到 3 号柱子上
        hanoi(n - 1, s2, s1, s3);//步骤3 最后把之前移到 2 号柱子上的 n-1 个环经过 1 号柱子移到 3 号柱子上
    }
    

这样递归退出的处理和递归子结构的主体部分在代码结构上就很清晰了，接下来从函数参数入手分析递归再触发机制。递归函数 hanoi() 要做的事情是借助 s2
柱子做中转，将 n 个环从 s1 柱子移动到 s3 柱子上。因此，它的四个参数给足了一次递归操作所需要的全部信息。第 1
个参数是“委托”给本次递归操作移动的环的数量，第 2 个参数是 n 个环当前所在的柱子，第 3 个参数是用来做中转的柱子，第 4 个参数是移动环的目的柱子。

第一个参数 n 是问题的规模，当问题规模变成只有 1 个环的时候，不需要借助其他柱子做中转就可以直接将这个环从 s1 号柱子移到 s3
号柱子。但是当问题的规模大于 1 个环的时候，就需要递归主体来进行处理，并根据解决问题的方法产生相应的递归触发机制。

汉诺塔问题的递归子结构的主体就是三个操作步骤，第一步先借助 s3 号柱子做中转，将 s1 号柱子上面的 n-1 个环移到 s2
号柱子上，这里触发一次递归调用，注意传递给递归函数的参数，将 s3 号柱子作为第二个参数，也就是中转柱子，将 s2
号柱子作为第三个参数，也就是移动操作的目的柱子。当上面 n-1 个环移到中转的 s2 柱子后，第二步操作就可以将 1 号柱子剩下的那个最大的环直接移到 s3
号柱子。最后，第三步再借助 s1 号柱子做中转，将 s2 号柱子上暂存的 n-1 个环移到 s3
号柱子（最大的那个环已经在第二步移过去了）。这一步又触发了递归调用，同样注意参数传递的变化，此时上面 n-1 个环在 s2 号柱子上，s1
作为中转柱子被使用。

所以这个递归函数的递归子结构蕴含了递归触发机制，对 n-1 个环的处理方法是将其“委托”给自身递归处理，至于被“委托”的那个自身如何解决这个 n-1
规模的问题，先不要深入考虑，因为只要递归子结构是正确的，最终总会在某一级递归的退出处理时解决掉这个问题。递归函数通过递归触发机制传递进来的参数决定这次递归处理要做什么操作。递归子结构在处理上面
n-1 个环的时候，它对应的 s1、s2 和 s3 号柱子与原问题的 s1、s2 和 s3
号柱子是不一样的。我们分析递归程序的时候，开始阶段重点关注的是递归触发机制怎么给“自身”准备递归操作的参数，以及通过这些参数控制递归函数这次要解决什么问题，先总整体上把握递归子结构的逻辑流程，不要过度关注递归子结构是怎么解决具体问题的。

#### 一个稍微复杂一点的例子

前面两个例子中的递归子结构都比较简单，接下来看一个稍微复杂点的例子，这是我们介绍“用穷举法解决工作站与装配线问题”时给出的递归搜索算法实现。这个算法的原理请参考对应的课程内容，这里只介绍如何理解这个递归函数。看这个递归函数，仍然先关注函数参数。第
1 个参数用于暂存搜索过程中的临时最优解和最终的最优解；第 2 个参数是装配线和工作站的参数，这些参数由问题给出，计算过程中不会变化；第 3
个参数是装配线编号，第 4
个参数是工作站编号。很显然，后两个参数所标识装配线编号和工作站编号是理解这个递归函数的关键抓手，它们两个表示本次递归尝试选择的是编号为 line
的装配线上的编号为 station 的工作站。

根据问题的要求，无论是在哪条装配线，只要最后一个工作站完成装配，工件就算完成，所以很容易理解递归退出条件就是 station 的编号是 (STATIONS
- 1) 的时候。如果 station
不是最后一个工作站，则分别尝试本条装配线的下一个工作站和另一条装配线的下一个工作站，注意递归调用触发时的参数准备，两次触发递归调用的时候委托给“自身”的
line 参数有变化，同时第四个参数变成 station + 1
。分析完了，除了递归子结构和递归退出时的处理逻辑有点复杂之外，整个递归函数的基本结构还是很简单的。

    
    
    void search_stations_sequence(Result_T *rt, Program_T *para, int line, int station)
    {
        if (station == (STATIONS - 1)) //1. 递推退出条件和退出处理
        {
            rt->fs += para->assemble_time[line][station];
            rt->fs += para->exit_time[line];
            rt->line[station] = line;
            if (rt->fs < rt->ffs) /*当前穷举到的路径时间开销更小，更新 rt 结果*/
            {
                rt->ffs = rt->fs;
                memmove(rt->fline, rt->line, STATIONS * sizeof(int));
            }
            return;
        }
    
        //递归子结构的主体部分
        //2. 记录中间结果到 line 属性中
        int curCost = rt->fs + para->assemble_time[line][station];
        rt->line[station] = line;
    
        //3. 调整 line 和 station 参数，完成递归子结构的动作
        /*选择本装配线的下一个装配站，开销忽略不计*/
        rt->fs = curCost;
        search_stations_sequence(rt, para, line, station + 1);
    
        /*选择另一条装配线的下一个装配站，需要计算转移开销*/
        rt->fs = curCost;
        rt->fs += para->transport_time[line][station + 1];
        int nextline = (line + 1) % LINES;
        search_stations_sequence(rt, para, nextline, station + 1);
    }
    

总结一下，我们分析递归程序的时候，不要一开始就冲着具体计算的逻辑代码死看，一旦看不懂很容易就投降放弃了。根据我的经验，先从整体上把握递归程序的三个关键部分，了解递归子结构的逻辑流程，但是不要过度关注递归子结构是怎么解决具体问题的。把关注的重点放在递归触发机制怎么给“自身”准备递归操作的参数，以及通过这些参数控制递归函数下一次要解决什么问题，这一部分的分析可以从函数的参数入手，特别是理解递归函数各个参数的意义，十分有用。

### 递归程序的常用模式

同一个问题的算法实现有很多种方法，我们可以选择用递归方式，也可以选择用其他方式，当我们选择用递归方法的时候，通常会使用一些常用的递归实现模式，了解这些实现模式，有助于理解别人写的递归程序，也有助于自己设计递归程序。

#### 同一问题的结构变形模式

这一类递归程序，有一些共同的特点，就是每次递归调用的时候，递归触发机制传递的参数还是原问题的参数，范围没有变化，只是要处理的侧重点和位置发生了变化。换句话说，不是拆分成子问题处理的那种形式，并且触发机制产生的同一级递归调用之间没有组合关系。这句话又不好理解了，没问题，看例子，上一节介绍的“装配线与工作站问题”的递归实现就是这种模式。无论是哪一级递归调用，递归触发机制传递给自身递归调用的前两个参数不变，变化的只是表示装配线和工作站两个参数，通过这两个参数的变化，将两条装配线上的
N 个工作站都遍历了一遍，实现了对所有工作站的穷举处理。

是的，这种递归程序实现模式常常用于穷举法，典型的例子还有深度优先遍历（DFS）算法，基本都是这个套路，先来看看有向图的深度优先遍历的实现（伪代码）：

    
    
    void dfs(GRAPH g, Node i)
    {
        //处理节点 i
        Visit(i);
    
        for(i节点的每一个连接点node[k])
        {
            dfs(g, node[k]); //图还是那个 g，只是 i 不一样
        }
    
    }
    

怎么没有递归退出条件和相应的处理？有！当节点 i 没有连通点的时候，那个 for
循环没啥可做的，自然就直接结束了。我说过递归程序要在显眼位置做退出处理，但不是所有场合都合适，这里利用了 for
循环不满足条件时跳过循环体的技巧，相当于递归退出处理。当然，深度优先遍历也有非递归的实现，就是用一个栈维护搜索过程，用入栈和出栈操作模拟递归调用的自然回溯效果，代码比递归版本复杂，但是没有递归调用，不用考虑栈溢出问题。

“三个水桶倒水”问题，也应用了这种结构变形的递归模式，它的变形之道同样体现在递归函数的参数处理上。参考前面的深度优先遍历模式，大家应该能看出来，这是一个深度优先遍历。之所以采用递归的方式，是因为算法对每个状态的处理模式是一样的，就是用所有的倒水动作去尝试驱动状态改变，看看能否产生新状态。既然处理模式一样，当然就可以抽象出递归子结构，这个问题的递归子结构还是比较清晰的。

    
    
    void SearchState(std::deque<BucketsState>& states)
    {
        BucketsState current = states.back(); /*每次都从当前状态开始*/
        if(IsFinalState(current)) //判断是否到达 4,4,0 状态
        {
            PrintResult(states); //输出一组结果
            return;
        }
    
        for (const auto& act : action_table)
        {
            BucketsState next;
            /*从 from 到 to 倒水，如果成功，next 返回倒水后的状态*/
            if (current.TakeAction(act.first, act.second, next))
            {
                if (!IsProcessedState(states, next))
                {
                    states.push_back(next);
                    SearchState(states); //从新的位置继续搜索
                    states.pop_back();
                }
            }
        }
    }
    

这一节的例子和后面的例子，都是为了向大家展示递归程序的实现模式，不要关注代码的细节部分，要关注的是我一再强调的递归程序的三个组成部分，理解一下这些递归函数的实现方式，还有就是递归函数的参数，关注一下它们是怎么通过递归函数的参数控制递归子结构的，使得递归子结构能够对同一个问题的不同位置做同样的逻辑处理。

#### 多阶段组合模式

如果一个问题有多个部分组成，但是各个部分关系紧密，无法用通过拆分子问题的方式消减问题的规模。但是如果问题的每个组成部分具有相同的拓扑结构，可以用同一套代码逻辑来处理，也可以考虑使用递归方法设计算法实现。还有一种情况，就是一个问题的解决需要多个操作步骤，每个操作步骤完成问题的一部分，当所有的操作都完成后问题才能解决。对于这种情况，如果每个操作步骤逻辑流程一样，也可以考虑用递归方法设计算法实现。

当遇到这样的问题时，其递归程序的实现呈现一种多阶段组合的模式，这种模式的递归函数结构上类似“同一问题的结构变形模式”，但是逻辑结构上组合的特点明显。不理解这段文字没关系，还是看代码吧。在[第
3-4
课：爱因斯坦的思考题](https://gitbook.cn/m/mazi/columns/5b6d05446b66e3442a2bfa7b/topics/5bbd98969ccd7c1379f30902)中，我们介绍每种类型的属性枚举时用了典型的五重循环结构，实际上在《算法的乐趣》这本书中我给出的方法是用递归的方式实现的。先来看看对香烟品牌的枚举用五重循环的情况：

    
    
    void ArrangePeopleCigert(GROUP *groups)
    {
        /*这里没有可用规则*/
        for (int i = CIGARET_BLENDS; i <= CIGARET_BLUEMASTER; i++)
        {
            for (int j = CIGARET_BLENDS; j <= CIGARET_BLUEMASTER; j++)
            {
                if (j == i)
                    continue;
                for (int k = CIGARET_BLENDS; k <= CIGARET_BLUEMASTER; k++)
                {
                    if ((k == i) || (k == j))
                        continue;
                    for (int p = CIGARET_BLENDS; p <= CIGARET_BLUEMASTER; p++)
                    {
                        if ((p == i) || (p == j) || (p == k))
                            continue;
    
                        for (int q = CIGARET_BLENDS; q <= CIGARET_BLUEMASTER; q++)
                        {
                            if ((q == i) || (q == j) || (q == k) || (q == p))
                                continue;
    
                            groups[0].itemValue[type_cigaret] = i;
                            groups[1].itemValue[type_cigaret] = j;
                            groups[2].itemValue[type_cigaret] = k;
                            groups[3].itemValue[type_cigaret] = p;
                            groups[4].itemValue[type_cigaret] = q;
    
                            DoGroupsfinalCheck(groups);
                        }
                    }
                }
            }
        }
    }
    

五重循环实现枚举的特点就是简单粗暴，容易理解，但是代码很繁琐。来看看递归版本的实现：

    
    
    void EnumPeopleCigerts(GROUP *groups, int groupIdx)
    {
        if(groupIdx == GROUPS_COUNT) /*递归终止条件*/
        {
            DoGroupsfinalCheck(groups);
            return;
        }
    
        for(int i = CIGARET_BLENDS; i <= CIGARET_BLUEMASTER; i++)
        {
            if(!IsGroupItemValueUsed(groups, groupIdx, type_cigaret, i))
            {
                groups[groupIdx].itemValue[type_cigaret] = i;
    
                EnumPeopleCigerts(groups, groupIdx + 1);
            }
        }
    }
    

注意这个递归函数的参数，每次递归触发的时候，groups 还是那个 groups，但是 groupIdx 却不是那个 groupIdx。对于 5 个
groups（GROUPS_COUNT = 5），每次选择一个 group item 进行枚举，这个选择是通过 groupIdx
这个函数参数来控制的。因为对每个 group item 进行枚举操作的逻辑结构相同，就是对 5
个香烟品牌逐个测试，如果一个品牌还没有被分配，则分配这个品牌给当前 groupIdx 对应的 group item，然后通过递归调用继续下一个
groupIdx 做同样的操作。香烟品牌尝试分配的过程中，需要调用 IsGroupItemValueUsed()
判断这个牌子的香烟是否已经被分配了（被之前的层递归调用分配了），这也是此类递归程序常见的结构，因为前面讲过，这类问题无法拆分子问题的原因就是各个组成部分之间互相关系太紧密。

再来看一个数字枚举的例子。假如我们需要从 1 ~ 9 共 9 个数字中任选四个不同的数组成一个排列，想知道有多少种可能的结果吗？可以用经典的四重循环，像
ArrangePeopleCigert() 函数的实现那样。也可以用递归，像 EnumPeopleCigerts() 函数实现的那样：

    
    
    bool IsNumberUsed(int num[], int idx, int i)
    {
        for (int k = 0; k < idx; k++)
        {
            if (num[k] == i)
            {
                return true;
            }
        }
    
        return false;
    }
    
    void EnumNumber(int num[], int idx)
    {
        if (idx > 3) //枚举的有效 idx 是 0-3，超过 3 了就是退出条件
        {
            return;
        }
    
        //对当前 idx 位置用数字 1-9 尝试
        for (int i = 1; i <= 9; i++)
        {
            if (!IsNumberUsed(num, idx, i))
            {
                num[idx] = i;
                EnumNumber(num, idx + 1); //继续枚举下一个位置
            }
        }
    }
    

触发递归调用时的关键处理是 idx + 1 的操作，意味着要委托“自身”对当前位置 idx
的下一个位置上的数字进行同样的枚举尝试。IsNumberUsed()
函数的作用是判断当前枚举的数字与其他已经确定的位置上的数字是否有重复，当递归机制委托给“自身”的 idx 参数大于 3 的时候，就是递归终止的条件，此时
num[] 中已经准备好了四个不重复的数字。

#### 分解子问题模式

我之前讲过，分治法和递归是一对儿天然好朋友，因为分治意味着要分解子问题，而子问题就是一种天然的递归子结构，用递归方法处理分治法就是顺理成章的事情。说到分解子问题，其实动态规划法也干这种事情，我之前也讲过，如果找不出清晰的子问题的递推关系式，可以用递归
+ 日志记录的方式设计动态规划法的算法实现。

这种模式的递归程序，其递归函数的参数需要被设计成能够反映问题的规模的一组参数，比如快速排序算法，就需要给出当前要排序的序列起始位置和结束位置（ p 和 r
两个参数）：

    
    
    void quick_sort(int *arElem, int p, int r)
    {
      if(p < r)
      {
        int mid = partion(arElem, p, r);
        quick_sort(arElem, p, mid - 1);
        quick_sort(arElem, mid + 1, r);
      }
    }
    

有时候，子问题不是通过范围来描述的，而是数据自身的规模发生了变化，比如 Karatsuba
大整数乘法，当递归调用发生的时候，递归触发机制传递给子问题的参数还是个 CBigInt 对象，但是数据位数只有原始问题的一半。GetRightBigN()
的作用是将 n 位的大整数中的低 $\frac{n}{2}$ 位赋值给 low 代表的 CBigInt 对象，高 $\frac{n}{2}$ 位则经过
ShiftRightBigN() 函数右移 $\frac{n}{2}$ 位，也成为一个小一点的 CBigInt 对象。

> 举个具体一点的简化例子，假如要计算 1234 与 5678 的乘积，先将 1234 分解为 $12\times 10^{2}+34$，将 5678
> 分解为 $56\times
> 10^{2}+78$，根据乘法分配律，最后的算式是：$12\times56\times10^{4}+12\times78\times10^{2}+34\times56\times10^{2}+34\times78$。其中，10
> 的乘方可以用移位操作代替，只需要计算 $12\times56$ 这样的小整数计算就可以了。当然 Karatsuba
> 还用了一些技巧，将小整数的乘法次数从平均 4 次减少为 3 次和若干次加、减法，极大地提高了大整数乘法的计算效率。

这个递归函数的退出条件就是当两个大整数中任意一个分解为一位大整数的时候，就不需要再按照 Karatsuba
计算方法分解计算了，因为可以直接计算出结果。所以，递归退出处理就是直接返回计算结果。这个递归函数的递归子结构主体就是 Karatsuba
算法的分解和计算过程，其中天然地包含了递归触发机制，就是对分解后得到的小整数继续委托给“自身”计算。

    
    
    CBigInt Karatsuba(const CBigInt& mul1, const CBigInt& mul2)
    {
        //1 位大整数，直接计算，这也是递归的终止条件
        if((mul1.GetBigNCount() == 1) || (mul2.GetBigNCount() == 1))
        {
            return mul1 * mul2;
        }
        //问题分解
        CBigInt high1,high2,low1,low2;
        unsigned int k = max(mul1.GetBigNCount(), mul2.GetBigNCount()) / 2;
        high1 = mul1;
        high1.GetRightBigN(k, low1);
        high1.ShiftRightBigN(k);
        high2 = mul2;
        high2.GetRightBigN(k, low2);
        high2.ShiftRightBigN(k);
        CBigInt z0 = Karatsuba(low1, low2);
        CBigInt z1 = Karatsuba((low1 + high1), (low2 + high2));
        CBigInt z2 = Karatsuba(high1, high2);
        //结果合并
        CBigInt zk = z1 - z2 - z0;
        z2.ShiftLeftBigN(2 * k);
        zk.ShiftLeftBigN(k);
    
        return (z2 + zk + z0);
    }
    

除了分治法和动态规划法会涉及子问题的分解，有时候穷举法也会遇到逐步减少问题的规模，直到穷举处理到问题规模为 0
的情况，这种情况下如果用到递归程序，其递归函数的参数也会呈现规模变化的特点，比如用穷举法求解最长公共子序列长度的问题，其递归函数就是通过子串的位置变化来达到子问题规模减少的目的（这里我们给出了
C++ 的实现方法，C++ 通过字符串指针移位的方式实现子串的位置变化）。

    
    
    int RecursionLCS(const char *str1, const char *str2)
    {
        //递归退出条件，任何一个子串结束，意味着其后续的 LCS 值是 0
        if(*str1 == 0 || *str2 == 0)
            return 0;
    
        if(*str1 == *str2)
        {
            //若当前位置字符相同，则 LCS 的值是子问题的 LCS 值 +1
            return RecursionLCS(str1 + 1, str2 + 1) + 1; 
        }
        else
        {
            //若当前位置字符不相同，则分别尝试三种情况，然后取最好的一个结果
            int len1 = RecursionLCS(str1 + 1, str2);  //尝试跳过 str1 当前字符
            int len2 = RecursionLCS(str1, str2 + 1);  //尝试跳过 str2 当前字符
            int len3 = RecursionLCS(str1 + 1, str2 + 1); //尝试同时跳过 str1 和 str2 的当前字符
            return std::max(std::max(len1, len2), len3); //取三种尝试结果中最好的一个结果
        }
    }
    

介绍各种递归程序模式的目的，是为了给下一节介绍如何设计递归程序做铺垫，了解这些模式的目的就是为了能够灵活运用这些模式，实在不行，能起到比着葫芦画瓢的作用，那也是极好的。

### 如何设计递归程序

当我们面对一个问题，首先要考虑一下用什么方法去解决这个问题，因为解决问题的方法在很大程度上决定了算法实现的方式。一般来说，穷举法、分治法和动态规划法在很多情况下都会用到递归程序实现方式，很多问题都有固定的算法模式和套路。这里我们不讨论方法，只讨论当确定要使用递归方式实现算法的时候，如何设计递归函数。

#### 第一个例子

第一个例子是一个能明显看出来是子问题分解模式的例子，这个例子就是基础部分介绍分治法时使用的字符串全排列的例子。分解子问题类型的递归程序是比较简单的一种递归程序，算法实现的原理请大家复习这一课的内容，这里只介绍一下递归函数的实现方法。根据对问题的分析，确定原始问题按照从前向后的顺序每次固定一个位置，然后对剩下的
n-1
个字符进行排列，这就意味着递归子结构的退出条件就是剩下一个字符的时候，此时说明其他位置都排好了，就剩这一个字符了，这一个字符，还排列个啥，直接输出整个串的结果就行了。接下来考虑递归子结构的主体部分，主体部分要做的事情就是从字符串中选择一个字符固定，然后将剩下的
n-1 个字符委托给“自身”，触发递归调用，基本上，此时递归函数的轮廓应该比较清晰了，大致应该是这个样子的：

    
    
    void Permutation(......)
    {
        if (子串只有一个字符)//
        {
            输出已经排好的字符串
        }
    
        for (子串中的每一个字符si)
        {
            固定 si 位置的字符，将剩下的 n-1 个字符作为子串委托给“自身”
            Permutation(......); //触发递归调用
        }
    }
    

各种“串”类问题的子问题通常有三表达方式，一种是“串实体 + 子问题位置区间”的方式，一种是“串实体 + 子问题起始位置 +
子问题长度”的方式，还有一种就是“新建一个子串”的方式。其中，第三种方式“新建子串“存在额外的内存开销问题，有时候子串的分解也存在处理的开销，所以比较少使用，常用的就是前两种方式。我们选择第一种方式定义子问题，用
std::string 存储串实体，用区间 [begin, end] 表示子串的区间，那么递归函数的参数基本上可以确定了：

    
    
    void Permutation(std::string& chList, int begin, int end)
    

有了子问题的具体表达方式，递归退出部分就可以具体实现了：

    
    
        if (begin == end)
        {
            std::cout << chList << std::endl;
        }
    

递归子结构的主体部分实现难度主要在于怎么将剩下的 n-1 个字符构建成连续的子串。我们可以选择新建子串的方式，假如当前需要固定的是第 i 个字符，那么将 i
之前的 [0,i - 1] 区间和 i 之后的 [i+1,n] 区间组合成一个新字符串，然后递归调用 Permutation()
函数。但是如果这么处理的话，和我们开始选择的子串定义方式矛盾，并且 Permutation() 函数参数中的 begin 和 end
就完全没有意义了，因为传递进来的 chList
就只包含了子串的内容。这里我要介绍一个置换大法，这种方法不是我发明的，因为我在很多算法中都看到过这种应用。具体方法就是固定子串中 begin
的位置作为暂存位置，将被选作固定位置的字符交换到 begin 位置暂存起来，这样剩下的字符就组成了连贯的子串，并且还存储在 chList
中。但是需要记住，在递归触发之后，继续选择固定下一个位置的字符之前，要置换回来。补全递归子结构的主体部分后，完整的代码就是我们在基础部分的例子里看到的样子，注意递归触发机制触发递归调用的时候对
begin 位置的修正：

    
    
    //将字符串 [begin,end] 区间的子串全排列
    void Permutation(std::string& chList, int begin, int end)
    {
        if (begin == end)
        {
            std::cout << chList << std::endl;
        }
    
        for (int i = begin; i <= end; i++)
        {
            Swap(chList, begin, i); //把第 i 个字符换到 begin 位置，将 begin+1 位置看作新的子串
            Permutation(chList, begin + 1, end); //求解子问题
            Swap(chList, begin, i); //换回来
        }
    }
    

#### 再来一个例子

在一个 N x M（M 和 N 都小于
16）的地图上，有一些被水覆盖的水洼和陆地，当相互连接的水洼面积超过一定大小后，就可认为这块水洼是个湖泊。我们用位图数组 char bmp[N][M]
表示地图，其值为 1 表示是被水覆盖，其值为 0 表示是陆地。现在的问题是，给定一个水洼的位置，判断这块水洼是一块小水洼，还是某个湖泊的一部分？

这是一个平面连通性问题，我们解决问题的思路就是从给定的位置直接相连的 8
个位置开始，检查这些位置是否是被水覆盖，如果被水覆盖就增加连通计数，如果是陆地就跳过。持续搜索连通的位置，当连通水洼计数达到或超过湖泊的标准后，就停止搜索，返回结果。当然，隐含的停止搜索条件是搜索完全部连通的位置，连通计数仍然达不到湖泊的标准。从刚才的描述中，隐含了一个搜索连通位置的模式，就是从一个位置上下左右连通的
8 个位置开始遍历一遍，遍历完后再从这 8
个位置中被水覆盖的位置（可能有多个被水覆盖的位置）再重复上述过程。这不就是“以同样的操作模式（步骤）重复...”吗？问题规模不大，用递归的方法肯定是最简单的。先想好递归退出条件，根据题意，当某个位置周围连通水洼计数超过湖泊的标准后，就可以结束递归搜索，同时，如果其周围的某个水洼在递归搜索的过程已经达到湖泊的标准了，则这个位置周围剩下的连通位置也就不用搜索了，这是个递归定义的退出条件。接下来确定递归子结构，根据解决思路的描述，这个问题的递归子结构是对周围
8
个位置遍历一遍，我们先假设这用一个循环体表达（其实认真学了本课程之前的内容的读者，应该想到该用方向数组了）。到目前为止，可以写下这个递归程序的框架代码了：

    
    
    //判断是否是湖泊
    bool SearchConnection(...)
    {
        bool isLake = false;
        for (遍历周围每一个位置(nx,ny))
        {
            if ((nx,ny)是合法位置，并且此位置被水覆盖，并且这个位置没有被搜索过)
            {
                连通计数器增加
                设置该位置的访问标志
                if (计数器达到湖泊的标准) || SearchConnection(...))
                {
                    isLake = true;
                    break;
                }
            }
        }
    
        return isLake;
    }
    

接下来从递归函数参数入口开始细化函数体的内容。想想这是何种模式的递归？肯定不是子问题模式，当然也不是多阶段组合模式，这是典型的同一问题结构变形模式。从递归函数的形式看，这种模式的递归函数一般都要有一个表达整体问题的参数，这个参数就是我们的整体地图，不妨这样定义一下地图：

    
    
    typedef struct 
    {
        char bmp[N][M];  //地图，1 表示被水覆盖，0 表示陆地
        bool sign[N][M]; //此位置是否搜索过，初始值都是 false
    }MAP;
    

除此之外，还要有位置信息，表示当前递归搜索的位置，我们习惯性用 x 表示水平位置坐标，y
表示垂直位置坐标。最后，是一个不太容易想到的参数，就是当前位置已经知道的连通水洼计数。其实也不难想，每个位置的计数都是在之前已知的计数基础上增加，那怎么知道本次递归搜索之前的计数器呢？只能通过函数参数来传递了，可以通过一个单独的参数传递，也可以放在
MAP 中（给 MAP 数据结构增加一个 count 属性），总之，要有这个东西。参数订好了，递归函数的原型就有了：

    
    
    bool SearchLake(MAP *map, int x, int y, int count)
    

位置遍历的循环用方向数组，这里不多说了。计数器就是通过 count 参数传递的那个值，也有了，判断条件也可以具体给出了：

    
    
     if ((nx >= 0 && nx < N) && (ny >= 0 && nx < M) //位置有效性判断
                (!map->sign[nx][ny]) && (map->bmp[nx][ny] == 1))
     {
    
     }
    

最后，是递归触发时的参数准备，也就是递归触发机制。很显然，map 参数还是要继续传递，位置信息要替换成当前正在处理的位置，count
的值已经增加过了，递归函数调用时直接传递给“自身”就可以了。最后，递归函数就完成了：

    
    
    typedef struct
    {
        int x;
        int y;
    }DIRECTION;
    /*8 个方向*/
    DIRECTION all_dirs[] = { { -1, 0 },{ -1, -1 },{ 0, -1 },{ 1, -1 },{ 1, 0 },{ 1, 1 },{ 0, 1 },{ -1, 1 } };
    
    bool SearchLake(MAP *map, int x, int y, int count)
    {
        bool isLake = false;
        for (DIRECTION& dir : all_dirs)
        {
            int nx = x + dir.x;
            int ny = y + dir.y;
            if ((nx >= 0 && nx < N) && (ny >= 0 && nx < M) //位置有效性判断
                (!map->sign[nx][ny]) && (map->bmp[nx][ny] == 1))
            {
                count++;
                map->sign[nx][ny] = true;
                if ((count >= LAKE_LIMIT) || SearchLake(bmp, nx, ny, count))
                {
                    isLake = true;
                    break;
                }
            }
        }
    
        return isLake;
    }
    

#### 没有例子了

总结一下吧，递归程序归根到底要落地到递归函数上，设计递归程序的中心思想就是设计递归函数。设计递归函数首先确定递归程序的三个关键部分，然后根据题目求解的思路完成递归函数的框架，最后从函数参数入手，细化框架内的内容，直至完成递归函数。

### 递归程序的优点和缺点

递归程序设计的优点很明显，代码简洁、优雅，最终实现的算法代码有种类似用自然语言描述的问题解决方案的效果。当然，递归程序的缺点也很明显，就是递归函数调用的效率和对栈空间的依赖。函数调用的效率主要是参数入栈和出栈以及恢复栈平衡的开销，使用类似
fastcall
这样的函数调用约定，用寄存器传递函数参数能在一定程度上提高函数调用的性能。但是递归程序对栈空间的依赖主要是两个方面，一个是函数参数入栈需要占用栈空间，另一个是函数内部的局部变量，这些都会限制递归函数调用的深度，进而影响到这个递归程序能解决的问题的规模。

### 总结

现在总结一下，设计递归函数，要考虑的也是三个事情，那就是递归退出条件和退出处理、递归子结构和递归触发机制。我一直强调，递归程序代码简洁、优雅，解决问题的过程符合人类思维习惯，讲的其实就是递归子结构和递归触发机制的具体实现部分的特点。遇到问题，可以先用人的思维方式设计好递归子结构的框架以及在合适的位置触发递归调用，然后再从函数参数开始着手设计递归函数，思考递归函数需要哪些参数的过程中，递归函数退出条件和递归再触发机制就清晰了，所以，记住，函数参数就是递归函数实现的抓手。

另外，设计一个问题的算法实现，首先根据问题解决方法的分析，判断可以使用何种编程的实现方法。基本原则是能不使用递归就不使用递归，毕竟递归方法存在效率和栈的开销问题，在搞不清楚问题规模的情况下，很容易出现问题。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

