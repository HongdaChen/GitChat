>
> 之前我们介绍过一些求最优解的常用算法模式，比如贪心算法、动态规划算法、穷举算法，都是采用一种确定或几乎确定的方式来寻找最优解。所谓的确定性是指以上这些算法都是建立在确定性基础上的搜索算法，在搜索过程中遇到一个决策点时，对于选
> a 还是选 b，其结果是确定的。比如贪婪法，就是按照贪婪策略选择，同样的条件下，每个决策选 1000 次结果都是一样的。
>
>
> 这一课我们要介绍的是随机化算法，该算法并不是闭着眼睛掷骰子，它是一种带启发式的随机搜索，各种随机化算法都有与之对应的理论基础。随机化算法常见的有模拟退火算法、禁忌搜索、蚁群算法、神经网络，当然也包括本课要介绍的遗传算法（Genetic
> Algorithm）。这些模拟、演化（进化）式的启发式搜索算法的搜索过程不依赖目标函数的信息，非常适合一些传统最优化方法难以解决的复杂问题或非线性问题，在人工智能、自适应控制、机器学习等领域得到了广泛的应用。

### 遗传算法原理

达尔文（Darwin）的进化论讲述的是物竞天择、适者生存的自然原理，生物体通过自然选择、基因突变和遗传等规律进化出适应环境变化的优良品种。遗传算法就是这样一种借鉴生物体自然选择和自然遗传机制的随机搜索算法，其搜索过程就是“种群”一代一代“进化”的过程，通过评估函数进行优胜劣汰的选择，通过交叉和变异来模拟生物的进化。

#### 遗传算法基本原理

在讲解遗传算法之前，先介绍几个概念。

  * **基因（Gene）** ，生物学中基因是一个独立的遗传因子，在遗传算法中，基因是一组编码，代表的是参与计算的遗传特征。
  * **种群（Population）和个体（Individuals）** ，生物的进化以群体的形式进行，这样的一个群体就称为种群，种群中的每个生物体是一个个体，种群中的每个个体是相互联系、相互影响的，这种联系影响着种群的进化。
  * **遗传和变异** ，下一代个体会遗传上一代个体的部分基因，使得个体的生物学特征能够延续到下一代。但是遗传并不是平稳的，会有一定的概率发生基因突变，基因突变所产生的新的生物学特征可能会提高个体的环境适应度，也可能会降低个体的环境适应度。遗传算法通过适应度评估，以提高个体的环境适应度，这样突变基因能以更大概率地延续到下一代。

从算法角度看，繁殖就是基因交叉（Crossover）算法的处理过程，将种群中的个体进行两两部分基因编码片段的互换，即可得到下一代的个体。遗传算法中的基因突变（Mutation）算法是通过直接替换个体基因中的某个或某几个编码实现的，也有的算法采用直接生成一个新的个体（相当于替换全部基因编码）来实现基因突变。

基因交叉和基因突变都是遗传算法的重要步骤，但是不能进行得太频繁，否则会导致每一代的基因差异太大，最终使得算法无法收敛到近似最优解。基因交叉和基因突变如果发生得太少也不行，因为这样无法保证种群的多样性，最终使得算法可能收敛到某个局部最优解，从而无法得到全局最优解。一般遗传算法的实现都会定义一个基因交叉发生概率和基因突变发生概率，通过这两个概率控制其发生的频度。

选择（Selection）也是遗传算法中的重要算法之一，也是生物学所说的“优胜劣汰、适者生存”原则在遗传算法中的体现。选择就是根据个体的适应度，按照一定的规则从上一代种群中选择一些优良的个体遗传到下一代种群中。适应度（Fitness）是个体对环境的适应程度，适应度低的个体会被逐步淘汰，适应度高的个体会越来越多，遗传算法一般都会根据问题要求设置一个适应度函数评估每个个体的适应度。

严格来说，遗传算法并不是一个具体的算法，它代表的是一种思想，针对不同问题，基因的选择与编码、适应度评估函数的设计以及遗传算子的设计都是各不相同的。从算法控制流程来看，遗传算法是一种典型的迭代算法，种群从第
N 代到第 N + 1
代演化的过程中个体评价、选择运算、交叉运算和变异运算分别扮演着自然界生物进化过程中的“优胜劣汰”、“交配繁殖”和“基因突变”所对应的角色，其中选择运算、交叉运算和变异运算被称为遗传算法的遗传算子。

虽然遗传算法是一种很简单的算法，但是很多读者遇到问题，仍然无从下手。原因在于有几个问题还是没有明确，首先，基因是什么，怎么选择、怎么编码？其次，适应度评估函数如何设计？最后，三个遗传算子如何设计？下面就从这三个方面介绍一下如何设计针对具体问题的遗传算法。

#### 基因的选择与编码

简单地理解，遗传算法中的基因就是以某种编码的形式表示的实际问题的解。基因可能有点抽象，但是编码是具体的，所谓编码，就是用计算机能存储和处理的数据形式表达基因所代表的问题的解。遗传算法首先要解决的问题就是基因的选择与编码问题，如果这个问题不解决，遗传算法的三大遗传算子的设计就是空中楼阁。

本课将介绍两个遗传算法的例子，其中一个是求解抛物线 $f(x)=-2x^2+5x+6$ 在 [0,3.0] 区间上的最大值，另一个是著名的“0-1
背包问题”。以抛物线问题为例，要求解的值是自变量 $x$ 在 [0,3.0] 区间上某个位置时对应的 $f(x)$
值，很显然，对应遗传算法中的基因就是自变量 $x$ 的某种编码形式。而对于“0-1 背包问题”，所有物品的选择状态（1 表示选择，0
表示不选择）就是问题解空间的解，用向量表示 7 件物品的选择状态，比如 [0,1,0,1,1,0,0]，对应遗传算法的基因就是用某种编码形式存储的这个
[0,1,0,1,1,0,0] 状态。

遗传算法常用的基因编码方式有二进制编码、格雷编码、符号编码、属性序列编码等方式，对于多参数的最优化问题，可用上述方式对每个参数进行编码，然后用级联或交叉的方式组合成最终的基因编码（比如把一个
32 位的编码分成高 16 位和低 16 位，分别表示两个参数的编码）。

二进制编码方式是最简单的编码方式，简单地说，就是直接使用被选择为基因的解，不进行特殊编码，被选为基因的解在内存中是以二进制的形式存在。比如求抛物线最大值的问题，对
$x$ 不进行任何编码，直接选择若干个在 [0,3.0] 区间上的随机数作为初始种群的基因。

二进制编码虽然简单，但是从信息论角度分析，二进制编码存在汉明悬崖（Hamming
Cliff）问题，对基因做很小的交叉和变异，得到的结果却差异巨大，使得遗传算法的基因交叉和变异难以跨越。原因在于二进制编码直接表示数字，每个二进制位是有权位的，最高位部分变换一个
bit，其值可能差几百上千万，但是最低位部分变换一个 bit，其差值可能只有
0.000000000001，对结果几乎没有影响。这会使得基因交叉和变异过程中，基因变化过于“跳跃”，影响遗传算法的局部搜索性能。为解决这种问题，人们引入了每个数位上没有权位概念的格雷码（Gray
Encoding）作为基因编码格式，关于格雷码，我们会在后面介绍具体例子的时候介绍。

对于某些非数字体系的问题，其基因无法直接用数字表示，这就需要用一些符号编码来表示基因（还记得建模的时候说的信息数字化吗？）。举个学生选课问题的例子，假设有
26 门课程可供学生选择，每个学生可选 4 门课程，很显然，学生所选课程如果作为运算的输入参数，无法用数字表达。但是如果定义英文字母 A ~ Z 分别代表
26 门课程，则每个学生所选课程作为输入参数就可以组成符号编码，比如 ACEK，采用符号编码后就可以转换成遗传算法中的基因进行遗传算子计算了。

属性序列编码和符号编码的处理思想类似，也是解决非数字体系问题常用的基因编码方式。如果算法的输入参数无法用数字直接编码，但是输入参数由若干个固定个数的属性组成，这些属性变化就可以代表不同的输入参数，在这种情况下，可以为每种属性设置编码，然后按照属性序列排列，得到一个用属性序列编码表示的输入参数，这就是属性序列编码的主要思想。

以“0-1背包问题”为例，我们把一次选择完成后背包中的物品作为问题的解，则这个解无法直接用数字进行编码，但是观察这个解，发现其组成就是 7
件物品的选择状态，我们对每个物品的选择状态编码，0 表示不选，1 表示选，最终背包问题的基因编码就是类似 [0,1,0,1,1,0,0] 这样的形式。

#### 适应度评估函数

在遗传算法中，适应度用于衡量群体中每个个体与最优解的接近程度，也就是个体基因的优良程度。适应度高的个体遗传到下一代的概率比较大，而适应度小的个体遗传到下一代的概率比较小。计算个体适应度的函数就是适应度评估函数或适应度函数（Fitness
Function），遗传算子中的选择算子需要根据个体的适应度函数来评估每个个体遗传到下一代的概率，因此，适应度评估函数的设计总是和基因的选择紧密相关。

适应度函数对个体的评估过程一般是这样的：首先对种群中个体的基因进行解码处理，从遗传算法中的基因编码转换到问题空间中的数据表达形式；其次，根据问题空间中的数据表达形式，使用问题空间的目标函数或最优值评估方法计算问题空间对应的结果；最后，根据问题的类型和最优解的形式，按照一定的规则对计算的结果进行评估和转换，得到遗传算法中的个体适应度。

前文已经介绍过，遗传算法是一种随机搜索算法，遗传算法通过适应度函数控制搜索的重点区域，如果适应度函数设计不当，有可能找错重点区域，从而错过最优解。因此，遗传算法的适应度函数是算法是否能成功的关键因素。

#### 遗传算子的设计

选择算子、交叉算子和变异算子被称为遗传算法的三个遗传算子。选择算子，又称复制算子，是遗传算法中保证优良基因传播的基本方式，对应的是“适者生存”的群体进化现象。交叉算子对应的是物种“繁殖和交配”产生的基因交换现象，变异算子对应的是“基因突变”这种进化现象，交叉和变异算子用于产生新的个体，是基因多样性的保证。

##### **选择算子**

选择算子的作用就是从群体中选出比较适应环境的个体复制（繁殖）到下一代，选择算子运行的基础是个体的适应度评估值，因此选择算子和适应度函数直接影响着遗传算法的性能。根据“优胜劣汰”的原理，遗传算法的选择算子都是非均匀选择的，常见的选择策略有以下几种。

  * **比例选择（Proportional Selection）** ：又称“轮盘赌选择（Roulette Wheel Selection）”，是一种回放式随机采样方法，每个个体进入下一代的概率等于它的适应度值与整个种群中个体适应度值总和的比例。
  * **随机竞争选择（Stochastic Tournament）** ：又称“随机锦标赛选择”，每次用比例选择方式从群体中选择两个或多个个体进行适应度竞争，适应度高的个体被选中。重复这个过程，直到下一代个体选满为止。
  * **最佳保留选择** ：确切地说，这是和交叉算子与变异算子结合在一起的一种选择策略。首先用比例选择方式选择下一代个体，但是每次都找出上一代中适应度最高的个体，直接替换到适应度最差的个体，并且这个个体不参与交叉和变异运算，确保它能遗传到下一代。
  * **排序选择** ：对群体中的所有个体按其适应度大小进行排序，根据排序结果，按照某种规则计算出每个个体被选中的概率。
  * **确定式采样选择（Deterministic Sampling）** ：该策略可以确保适应度高的个体能 100% 被遗传到下一代，具体的方法是，根据个体的适应度计算群体中每个个体在下一代中期望的生存数目，计算方法如下。

$$ N_{i} = \frac{M \times F_{i}}{\sum_{i=1}^{M}F_{i}} $$

用 $N _{i}$ 的整数部分确定对应的个体在下一代种群中的生存数目，对 $N_ {i}$ 求和得到 $M' = \sum _{i=1}^{M}\left
\lfloor N_ {i} \right \rfloor$，按照 $N _{i}$ 的小数部分对个体进行排序，按照从大到小的顺序依次取前 $M - M'$
个个体加入到下一代种群（个体的数量是 $N_ {i}$），最终得到 $M$ 个下一代种群。

##### **交叉算子**

遗传算法中的交叉算子的功能是将两个个体基因的一部分片段（基因片段对应的位置相同）互相交换，从而产生两个新的个体。设计交叉算子的算法，一般要求即不要太多地破坏个体基因中的优良基因，又要能够有效地产生基因不同的新个体，保证种群的多样性。交叉算子的设计一般由基因的编码方式决定，基本过程就是随机从群体中选择两个个体配对，然后按照一定的交叉规则交换对应位置上的基因片段。基因交叉规则大致可分为以下几类。

  * **单点交叉（One-point Crossover）** ：在配对个体的基因中只随机选择一个点，以随机概率交换这个点对应的基因片段，从而形成两个新个体。
  * **两点交叉（Two-point Crossover）与多点交叉（Multi-point Crossover）** ：在配对个体的基因中只随机选择两个或多个点，以随机概率交换每个点对应的基因片段，从而形成两个新个体。
  * **均匀交叉（Uniform Crossover）** ：又称为一致交叉，对配对个体基因上的每个点都按照相同的交叉概率交换其对应的基因片段，从而形成两个新个体。
  * **算术交叉（Arithmetic Crossover）** ：由两个配对个体的线性组合而产生出两个新的个体，该操作对象一般是由浮点数编码表示的基因。

##### **变异算子**

遗传算法中的变异算子功能是将个体基因上的某个点对应的基因片段替换成适合该点的其他基因片段值，从而产生一个新的基因。和生物学进化的基因突变一样，变异在遗传算法中也只是产生新个体的辅助手段，通常用一个比较低的概率控制变异发生的频度。变异算子和交叉算子共同决定了遗传算法的搜索性能，通过维持种群的多样性避免早熟现象，变异算子主要解决两个问题，一个是如何确定变异的位置，另一个是如何进行基因变异。常用的变异算子类型如下。

  * **单点变异（One-point Mutation）** ：对个体的基因编码随机选择一个点，以随机概率进行变异运算。
  * **固定位置变异** ：对个体基因上的一个或几个固定位置上的基因片段，以随机概率进行变异运算。
  * **均匀变异（一致性变异）** ：对个体基因上的每个片段，都使用均匀分布的随机数，以较小的随机概率进行变异运算。
  * **边界变异（Boundary Mutation）** ：做变异操作时，使用基因编码规则定义的编码边界值（如果有多个边界值，比如同时有最大值和最小值的情况，则根据实现定好的规则选一个或随机选一个）替换原来的基因片段。
  * **高斯变异** ：基因变异的随机概率不是平均分布随机数或普通正态分布随机数，而是采用符合高斯分布的随机数生成器生成随机概率。

具体的变异算法与基因编码方式有关，比如二进制编码和浮点数编码，直接将某一位从 1 变成 0，或从 0 变成 1
就实现了变异。对于符号编码的基因，直接将某个位置上的符号替换成符合该位置要求的其他符号即可变成变异；对于属性序列编码方式，改变某个属性的值也算是实现了变异。总之，变异只是一个抽象的要求，具体的算法实现则千姿百态。

### 求解函数极值的例子

希望读者认真看完上面的原理，而不是直接跳到这里看例子。这一部分重点是基因编码的选择、三种遗传算子的实现和适应度评估函数的实现，不再细说这么做的原因，原因前面都有介绍。这一个例子是求解抛物线
$f(x)=-2x^2+5x+6$ 在 [0,3.0] 区间上的最大值，利用二次抛物线的极值公式，可以手工算出来这个函数在 [0,3.0] 上的最大值是
9.125，接下来尝试用遗传算法求出这个最大值。

#### 基因和种群建模

“基因的选择与编码”这一节讲过，对于这类问题，如果直接用自变量的二进制编码作为基因会存在汉明悬崖问题。为了避免浮点数直接编码，我们将区间 [0,3.0]
分成 65536 份，将连续区间分成 65536 个离散的点，用 0 ~ 65535
对其进行编码。这样划分会不会影响精度呢？当然会，我们来计算一下这样划分后的求解精度：

$$ v = (3.0 - 0) / 65536 = 0.0000457763671875 $$

精度是小数点后面四位，还行吧，如果有更高的要求，可以将区间分的更细一点。现在我们得到了一个 0 ~ 65535
的整数编码，避免了浮点数编码，但是这个整数编码依然存在汉明悬崖问题。举个例子，编码 1（0x0001）和 32768（0x1000）只有两个 bit
不同，但是其值却相差了 32767。因此，这个整数编码不适合直接作为基因编码。

现在来看看格雷码，其特点是任意两个相邻的格雷码之间只有一位不相同，即便是格雷码的最大数和最小数也仅有一位不同。格雷码最初是作为一种通信领域内的可靠性编码使用，但是其“两个相邻的格雷码之间只有一位不同”特性可用于遗传算法的基因编码。格雷编码连续性好，可避免汉明悬崖问题，增强遗传算法的局部搜索能力。格雷编码和二进制编码之间的转换算法不是这一课的重点，演示程序只是给出了实现，有兴趣的读者可以自行找相关的资料学习。

现在，我们知道基因是一个用格雷码编码的 16 位整数，接下来看看种群这个概念怎么定义。很显然，种群是由若干个个体组成，我们定义了一个 GATYPE
数据结构，用来描述一个个体，个体除了基因，还有这个基因对应的适应度。

    
    
    typedef struct GAType
    {
        unsigned short gene;
        double fitness;
    }GATYPE;
    
    GATYPE population[POPULATION_SIZE];
    

#### 基因的编码和解码

基因的编码就是将区间 [0,3.0] 上的自变量离散化，用对应的位置编号 0 ~ 65535
对其进行编码，然后再转成格雷码。编码过程可以从随机生成基因的函数实现中体现出来：

    
    
    unsigned short GetRandomGene()
    {
        //产生随机数 u，并映射到正整数 0 ~ 65535 范围上
        double u = (double)rand() / (RAND_MAX + 1) * 65536.0;
        //转换为格雷码
        unsigned short g = GrayEncoding((unsigned short)u);
    
        return g;
    }
    

解码的过程与之相反，先将格雷码编码的基因转化成 0 ~ 65535 之间的位置编号，然后再根据区间范围计算出对应的自变量 $x$
的值，然后就可以用自变量的值计算抛物线的值了。这个过程在适应度评估函数中体现，下面介绍适应度评估函数时会看到这个解码过程。

#### 适应度函数

求抛物线最大值问题的适应度函数非常简单，就是对基因进行解码，得到对应的自变量的值，然后带入抛物线函数求值，这个值就是基因的适应度，这个值越大，显然对这个基因越有利。对基因的解码函数也体现在这个函数中，先调用
GrayDecoding() 函数将基因解码，再映射到 [0,3.0] 区间上得到对应的自变量的值（此时是浮点数了）。EnvaluateFitness()
函数的 for 循环计算了种群中每个个体的适应度。

    
    
    double BinFunc(double x)
    {
        return (-2.0*x*x + 5*x + 6);
    }
    
    void EnvaluateFitness(GATYPE *pop)
    {
        for(int i = 0; i < POPULATION_SIZE; i++)
        {
            unsigned short k = GrayDecoding(pop[i].gene);
            //根据编码值，得到 [0.0,3.0] 区间上的 x 值
            double x = k * (pop[i].high - pop[i].low) / 65536.0 + pop[i].low;
    
            pop[i].fitness = BinFunc(x);
        }
    }
    

#### 选择算子与随机竞争选择算法

演示算法用的是随机竞争选择算法，也就是“随机锦标赛选择”，这种选择算法的实现是非常简单的，就是每次从种群中随机选 2
个个体，然后选择适应度大的那个胜出，进入下一代种群，重复这种选择，直到下一代种群选满为止。

    
    
    void Select(GATYPE *pop, GATYPE *next_pop)
    {
        for (int i = 0; i < POPULATION_SIZE; i++)
        {
            int fm = (int)((double)rand() / (RAND_MAX + 1) * POPULATION_SIZE);
            int fn = (int)((double)rand() / (RAND_MAX + 1) * POPULATION_SIZE);
            if (pop[fm].fitness >= pop[fn].fitness)
            {
                next_pop[i] = pop[fm];
            }
            else
            {
                next_pop[i] = pop[fn];
            }
        }
    }
    

#### 交叉算子

交叉算子对两个随机选中的个体的基因进行交换，基因交换的位置和个数都是随机选择，使得新个体的基因更具随机性。交叉选择受交叉概率的控制，对种群中的每个个体生成一个
0-1 之间的随机数，判断这个随机数是否小于交叉概率，若小于，则选择这个个体参与基因交叉运算。

![](https://images.gitbook.cn/94d3b9c0-17d4-11e9-8302-0d1daa9ceb5b)

图（1）基因交叉示意图

演示算法的交叉算子采用的是多点交叉的策略，每次会选择多个基因点进行交换，因为基因是一个 16 位的整数，定义一个基因点为一个 bit
位。交叉的方法如图（1）所示，每次随机选择一段连续的 bit 位作为本次交叉的基因点。ExchangeOver()
函数就是一些位操作，首先随机生成交叉点的起始位置（ps）和结束位置（pe），然后由 MakeMask() 函数生成掩码。

> 注意，为了方便交叉位置的清除操作，我们对掩码进行取反，得到了一个清除交叉位的掩码 revMask。
    
    
    void ExchangeOver(GATYPE *pop, int first, int second)
    {
        int ps = (int)((double)rand() / (RAND_MAX + 1) * 6 + 0.5);
        int pe = (int)((double)rand() / (RAND_MAX + 1) * 6 + 8.5);
    
        unsigned short mask = MakeMask(ps, pe); //生成掩码
        unsigned short revMask = ~mask;  //得到反向掩码，用于清除操作
        unsigned short temp1 = pop[first].gene & mask;
        unsigned short temp2 = pop[second].gene & mask;
    
        pop[first].gene &= revMask; //清除 first 的交叉位
        pop[first].gene |= temp2;  //换成 second 的交叉位
        pop[second].gene &= revMask;  //清除 second 的交叉位
        pop[second].gene |= temp1; //换成 first 的交叉位
    }
    

随机选择的过程比较简单，在演示程序的 Crossover()
函数中实现，这里不做过多说明，[演示程序源代码可以参考这里](https://github.com/inte2000/play_with_algo)。

#### 变异算子

变异算子采用的是均匀变异的策略，对基因编码的每一位以平均分布的概率进行选择，变异算子受变异概率的控制，以较低的概率选择进行变异的个体。P_MUTATION
是变异概率，只有随机数小于变异概率时，才调用 ReverseBit() 函数进行基因的变异处理，该函数的作用是将基因中指定位置的 bit 位做个反转（0 变
1，1 变 0），在调用 ReverseBit() 函数首之前，要指定反转的 bit 位，这个位置是随机指定的。

    
    
    void ReverseBit(GATYPE *pop, int index, int bit)
    {
        unsigned short mask = 0x0001 << (15 - bit);
    
        if(pop[index].gene & mask)
        {
            pop[index].gene &= ~mask;
        }
        else
        {
            pop[index].gene |= mask;
        }
    }
    
    void Mutation(GATYPE *pop)
    {
        for(int i = 0; i < POPULATION_SIZE; i++)
        {
            double p = (double)rand() / (RAND_MAX + 1);
            if(p < P_MUTATION)
            {
                int bit = (int)((double)rand() / (RAND_MAX + 1) * 15);
                ReverseBit(pop, i, bit);
            }
        }
    }
    

#### 完成

    
    
    Initialize(population);
    
    GATYPE next_population[POPULATION_SIZE] = { 0 };
    for(int i = 0; i < MAX_GENERATIONS; i++)
    {
        EnvaluateFitness(population);
        Select(population, next_population);
        Crossover(next_population);
        Mutation(next_population);
        for (int j = 0; j < POPULATION_SIZE; j++)
        {
            population[j] = next_population[j];
        }
    }
    

遗传算法的主体就是用迭代法对上述选择、交叉和变异进行迭代计算，直到满足迭代终止条件。迭代终止条件就是种群遗传达到指定的
generation，迭代结束后从种群中选择适应度最大的那个值作为结果。演示算法选择种群大小是 64，交叉概率是 0.8，变异概率是 0.15，种群遗传
200 代，连续计算 500 次，每次选择种群中最好的结果记录下来，最后得到的结果如图（2）所示，可以看到基本上都很接近理论的最大值 9.125。

![](https://images.gitbook.cn/d18af040-17d4-11e9-8302-0d1daa9ceb5b)

图（2）200 代遗传算法的结果

### 求解背包问题的例子

这一节我们介绍如何用遗传算法解决“0-1
背包问题”，该问题的基因建模与抛物线求极值完全不同，是另一种设计基因的方式。另外，这一节演示算法的选择算子用了比例选择算法，也就是轮盘赌算法，读者可以看看这些算法的实现其实是非常简单的。

#### 基因和种群建模

这个问题的基因设计其实前面已经简单介绍了，基因由 7 件物品的状态组成，状态有两个：1 表示装入背包、0 表示不装入背包。这样基因就可以用一个 7
元组表示，并且不需要像前一个例子那样需要对基因进行编码和解码。GATYPE
是种群个体的数据结构定义，每个个体除了基因以外，还有适应度，选择概率（rf）和积累概率（cf），关于选择概率和积累概率将在选择算子一节中介绍。

    
    
    const int OBJ_COUNT = 7;
    
    typedef struct GAType
    {
        int gene[OBJ_COUNT];
        int fitness;
        double rf;
        double cf;
    }GATYPE;
    
    GATYPE population[POPULATION_SIZE] = { 0 };
    

#### 适应度函数

对这个问题来说，适应度就是当前选择的物品总价值。计算的方法就是判断基因中每个物品对应的是否是
1，如果是，则计算这个物品的价值，依次累加后的总价值就是这个基因的适应度。但是有个异常需要考虑，那就是物品的总重量可能会超过包的容量。基因在交叉和变异的过程中，难免会出现这种异常基因，对于这种情况，解决的方法就是给这个基因对应的个体一个很低的适应度值，作为惩罚性措施，使得这个基因在选择过程中很难被选入下一代种群，从而淘汰掉这种异常基因。

EnvaluateFitness() 函数还计算了所有个体的适应度之和，其目的是为了给选择算子计算选择概率时使用。

    
    
    int Weight[OBJ_COUNT] = {35,30,60,50,40,10,25};
    int Value[OBJ_COUNT] = {10,40,30,50,35,40,30};
    
    int EnvaluateFitness(GATYPE *pop)
    {
        int totalFitness = 0;
        for(int i = 0; i < POPULATION_SIZE; i++)
        {
            int tw = 0;
            pop[i].fitness = 0;
            for(int j = 0; j < OBJ_COUNT; j++)
            {
                if(pop[i].gene[j] == 1)
                {
                    tw += Weight[j];
                    pop[i].fitness += Value[j];
                }
            }
            if(tw > CAPACITY) /*惩罚性措施*/
            {
                pop[i].fitness = 1;
            }
            totalFitness += pop[i].fitness;
        }
    
        return totalFitness;
    }
    

#### 选择算子和轮盘赌算法

我们的例子算法用的是比例选择算法，也就是轮盘赌算法，该算法是随机算法中最常用的一种概率选择算法，因原理和赌场中的轮盘赌原理相似而得名。每个个体被选择的概率就像轮盘上的一个扇区，面积大的扇区被选中的概率就比较大。每次对种群计算适应度，得到的适应度总和可以理解为整个轮盘，每个个体的适应度就是轮盘上对应的扇区，适应度大，占的扇区就宽。

**选择概率** 和 **积累概率**
是轮盘赌算法中的两个重要概念，选择概率可以理解为轮盘上每个扇区所占的比例，积累概率则是一个递归定义，某个扇区的积累概率可以理解为这个扇区前一个扇区的积累概率加上这个扇区的选择概率。如果不好理解的话，那就举个“栗子”吧，如图（3）所示，假设某种群中有
6 个个体，每个个体的选择概率分别是 0.1、0.2、0.15、0.25、0.05 和 0.25，则它们的积累概率分别是
0.1、0.3、0.45、0.70、0.75 和 1。

![](https://images.gitbook.cn/ab6bdff0-17d4-11e9-9a16-dfdfa8850682)

图（3）选择概率与积累概率示意图

轮盘赌算法随机选择的过程就是随机生成一个概率值，比如图（3），随机选择一个概率是 p=0.53，根据积累概率关系：0.45 < p <
0.70，于是第四个个体被选中。从这个关系可以看出来，选择概率大的个体在积累概率中占的范围就大，被选中的概率也大。

选择算子的算法实现要做两件事情，第一件事情就是根据适应度函数计算的适应度，计算出每个个体的选择概率，并根据选择概率计算出累加概率。pop[i].rf
是计算出的选择概率，pop[i].cf 是累加概率，lastCf 是临时变量，用于辗转存放当前个体之前的所有个体的选择概率之和，也就是前一个个体的积累概率。

    
    
        double lastCf = 0.0;
        for(i = 0; i < POPULATION_SIZE; i++)
        {
            pop[i].rf = pop[i].fitness / totalFitness;  //计算选择概率
            pop[i].cf = lastCf + pop[i].rf;  //计算积累概率
            lastCf = pop[i].cf;
        }
    

得到累加概率后，剩下的工作就是生成随机概率，然后从当前种群中选择个体进入下一代种群。根据前面的分析，适应度高的个体计算得到的选择概率就高，被选中的概率也高，当然，就可能被多次选中。适应度低的个体选择概率也低，被选中的概率就小，如果一次都没有被选中，就意味着这个个体被淘汰了。

    
    
        for(i = 0; i < POPULATION_SIZE; i++)
        {
            double p = (double)rand() / (RAND_MAX + 1); //产生随机概率
            for(int j = 0; j < POPULATION_SIZE; j++)
            {
                if((p >= pop[j].cf) && (p < pop[j + 1].cf))
                {
                    newPop[i] = pop[j + 1];
                }
            }
        }
    

#### 交叉算子

这个问题的基因简单，没有编码，因此交叉算子的实现也简单。演示程序使用的是还是多点交叉算法，首先生成一个随机数，决定这次要交换的基因点个数 n（n <=
7），然后循环 n 次，每次随机选择一个基因点，两个基因借助一个中间变量实现基因点的交换。

    
    
    void ExchangeOver(GATYPE *pop, int first, int second)
    {
        /*对随机个数的基因位进行交换*/
        int ecc = rand() % OBJ_COUNT + 1;
        for(int i = 0; i < ecc; i++)
        {
            /*每个位置被交换的概率是相等的*/
            int idx = rand() % OBJ_COUNT;
            int tg = pop[first].gene[idx];
            pop[first].gene[idx] = pop[second].gene[idx];
            pop[second].gene[idx] = tg;
        }
    }
    

随机选择的过程比较简单，在演示程序的 Crossover()
函数中实现，这里不做过多说明，[演示程序源代码可以参考这里](https://github.com/inte2000/play_with_algo)。

#### 变异算子

这个问题的变异算子采用的是均匀变异策略，对基因的每一个基因点以平均分布的概率进行选择。ReverseGene()
函数的作用是将基因中随机个数的基因点做反转（0 变 1，1 变 0）处理，但是在调用 ReverseGene()
函数首之前，要体现变异概率的控制。变异算子受变异概率的控制，以较低的概率选择进行变异的个体，P_MUTATION
是变异概率，只有随机数小于变异概率时，才调用 ReverseGene() 函数进行基因的变异处理。

    
    
    void ReverseGene(GATYPE *pop, int index)
    {
        /*对随机个数的基因位进行变异*/
        int mcc = rand() % OBJ_COUNT + 1;
        for(int i = 0; i < mcc; i++)
        {
            /*每个位置被交换的概率是相等的*/
            int gi = rand() % OBJ_COUNT;
            pop[index].gene[gi] = 1 - pop[index].gene[gi];
        }
    }
    
    void Mutation(GATYPE *pop)
    {
        for(int i = 0; i < POPULATION_SIZE; i++)
        {
            double p = (double)rand() / (RAND_MAX + 1);
            if(p < P_MUTATION)
            {
                ReverseGene(pop, i);
            }
        }
    }
    

#### 完成

演示算法选择种群大小是 64，交叉概率是 0.8，变异概率是 0.15，种群遗传 500 代，连续计算 500
次，每次选择种群中最好的结果几乎都是理论最大值 170。

### 总结

这一课，我们用两个例子介绍了遗传算法的应用，可以看出来，这种算法并不神秘，实现起来也很简单，应用的关键是基因的建模、适应度函数设计和三种算子的设计。基因的建模是遗传算法的核心，基因选择不当会导致适应度函数设计困难，也会导致交叉和变异算法实现困难。抛物线极值问题我们使用随机竞争选择算法，背包问题使用了轮盘赌选择算法，这两种算法都是很适用于遗传算法的随机化算法，都能保证适应度高的个体在选择过程中体现优势。

遇到问题，如果对基因无从下手，不妨从问题的解着手开始分析，基因一定是以解的某种形式存在，它能够以某种变换得到要求解的答案。抛物线问题的 $x$
可以带入抛物线函数得到极值，这个极值就是我们要搜索的最优解；“背包问题”可以根据 7 个物品的选择状态计算出物品的重量，这个重量也是我们要搜索的最优解。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

