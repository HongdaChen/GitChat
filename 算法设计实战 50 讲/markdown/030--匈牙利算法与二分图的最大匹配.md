>
> 在图论中，二分图（又称二部图）是一个特殊的模型，关于二分图有很多概念，比如匹配、完全匹配、最大匹配等。这一课我们来介绍一种求二分图的最大匹配的匈牙利算法，匈牙利算法原理是公开的，人们使用匈牙利算法都是根据自己问题域的数据模型，利用算法原理实现具体的算法。这一课我们的关注点仍然是怎么根据算法原理设计数据模型，并实现算法。

### 二分图的各种匹配

首先介绍一下二分图，二分图 G=(V,E) 是这样的一个图，它的顶点集合 V 可以划分为 X 和 Y 两个集合，它的边集合 E 中的每条边都有一个端点在 X
集合，另一个端点在 Y
集合。判断二分图的关键是看点集是否能分成两个独立的点集，如图（1-a）就是一个二分图，如果一个图的边形成了三角形，那它一定不是二分图，图（1-b）就不是二分图。

![](https://images.gitbook.cn/5fb57960-f126-11e8-af10-4396b0560f7c)

图（1）二分图识别示意图

#### 匹配

对于一个二分图 G=(V,E) 中部分边组成的子集 M，如果 M 的边集中任意两条边都不依附于同一个顶点，则称 M
是一个匹配，怎么理解这句话呢？首先匹配是一个边的集合，并且不唯一；其次，匹配 M
中没有任何两条边有公共的顶点。以图（1-a）所示的二分图为例，图（2-a）和图（2-b）中红色的边集就是二分图的两个匹配，而图（2-c）中的红色边集就不是匹配。

![](https://images.gitbook.cn/6e16a830-f126-11e8-a304-4d4afd81180c)

图（2）二分图匹配示意图

#### 最大匹配

对于一个二分图 G=(V,E) 的所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配，最大匹配所包含的边数就是二分图的最大匹配数。

#### 完全匹配

如果一个二分图 G=(V,E)
的最大匹配，恰好连接了图中所有的顶点，也就是说所有的顶点都有属于最大匹配的边与之相连，则称这个最大匹配是完全匹配，或完美匹配。最大匹配不一定是完全匹配，但是完全匹配一定是最大匹配，图（3）就是图（1-a）所示的二分图的一个完全匹配。

![](https://images.gitbook.cn/7a0c7c50-f126-11e8-a304-4d4afd81180c)

图（3）二分图完全匹配

### 最大匹配和匈牙利算法

匈牙利算法是埃德蒙德斯（Edmonds）在 1965
年提出的一个简化的最大流算法，该算法根据二分图匹配这个问题的特点将最大流算法进行了简化。匈牙利算法不区分图中的源点和汇点，也不关心边的方向，因此不需要复杂的网络图模型，正因为如此，使得匈牙利算法成为一种很简单的二分匹配算法。匈牙利算法的关键是寻找增广路径（Augment
Path），首先介绍一下什么是增广路径。

#### 增广路径

设 M 是二分图 G=(V,E) 的一个匹配边集，若 P 是图 G 中一条连通两个未匹配顶点的路径（P 的两个顶点一个在 X 集合，另一个在 Y
集合），并且在这条路径上，属于 M 的边和不属于 M 的边交替出现，则称 P 为相对于匹配 M 的一条增广路径。也就是说，增广路径从 X
集合中的一个未匹配点开始，依次交替经过不在匹配 M 中的边和在匹配 M 中的边，最后到达另一个在集合 Y 中的顶点。

根据上述定义，增广路径具有以下三个重要性质：

  * 路径中边的条数是奇数，对路径上的边按照顺序编号，所有奇数编号的边都不在已知的匹配 M 中，所有偶数编号的边都在 M 中（也就是第一条边和最后一条边不在匹配 M 中）；
  * 路径的起点在 X 集合，终点在 Y 集合（反过来也成立），路径上的点一个在 X 集合，一个在 Y 集合，交替出现，整条路径上没有重复的点，并且只有路径的起点和终点是未覆盖的点，路径上其他的点都已经配对；
  * 如果对增广路径进行“取反”操作，新的匹配数就比已知匹配数增加一个，也就是说，可以得到一个更大的匹配。

所谓的取反操作，就是把增广路径上奇数编号的边加入到已知匹配中，并把增广路径上偶数编号的边从已知匹配中删除。每做一次“取反”操作，得到的匹配就比原匹配多一个，为啥多一个呢？因为增广路径有奇数条边，在匹配
M 中的边比不在 M 中的边少 1 个（理解第一条特性），取反以后，自然就变成多 1 个了。

寻找增广路径并扩大当前匹配是匈牙利算法的关键，增广路径的起点要么是在二分图的 $X$ 集合中，要么是在 $Y$
集合中，因此寻找增广路径的算法可以从任何一侧的顶点开始，逐个顶点搜索。从 $X_{i}$ 顶点开始搜索增广路径的流程如下：

    
    
    while(从 Xi 的邻接表中找到下一个关联顶点 Yj)
    {
        if(顶点 Yj 不在增广路径上)
        {
            将 Yj 加入增广路径;
            if(Yj 是未覆盖点 或者 从与 Yj 相关连的顶点（Xk）能找到增广路径)
            {
                将 Yj 的关联顶点修改为 Xi；
                从顶点 Xi 开始有增广路径，返回 true；
            }
        }
    
        从顶点 Xi 开始没有增广路径，返回 false；
    }
    

#### 数据模型

既然是图的算法，肯定要用到图的数据模型，图有邻接矩阵和邻接表两种表达方式，对应的算法实现稍有差异，但是算法的原理是一样的。我们准备用邻接矩阵存储图，用从 0
开始的数字为每个顶点编号。当然，邻接矩阵的数组下标自然就借用顶点的编号了。二分图的邻接矩阵有个特点，就是矩阵的二维坐标分别来自 X 集合和 Y 集合，比如
$edge[2][4]=1$，表示 X 集合的 2 号顶点和 Y 集合的 4 号顶点之间有条边。

根据算法原理的描述，在处理的过程中，还需要记录当前匹配的边集用于结果输出，虽然是边，但还是要通过点的信息来表示，有了点就有了边，当然，要两个点才行，虽然有两个点的信息需要存储，但是不一定需要两个数。因为数组下标本身就可以是一个点的信息，那么边的另一个点的信息就用对应数组元素的值来表达，不容易理解吧？举个“栗子”：假设这个数组的第二个元素值是
5，即 path[1] = 5，表示当前匹配边集上有一条边，它的一个顶点编号是 1，另一个顶点的编号是 5，因此 path[1]
是一条边，同样，path[0] 也是一条边，Get 到感觉了吗？感觉数组下标被“玩”坏了吧，谁说边一定要用两个数字存储？

除了增广路径，算法原理的描述里隐含了一个重要的信息，那就是根据 $X _{i}$ 搜索对应的 $Y_ {j}$ 点时，要区分 $Y _{j}$
是否是已经被增广路径覆盖的点。怎么区分？就是给每个顶点 $Y_ {j}$ 设置一个是否在增广路径上的标识。这个仍然用一维数组就可以了，on_path[2]
= true，表示编号为 2 的顶点已经在增广路径上了。

最后把它们放在一起，就是这个样子（实际上，如果对代码设计有追求的读者，会选择把 edge 独立放在 GRAPH 中）。

    
    
    typedef struct 
    {
        int edge[UNIT_COUNT][UNIT_COUNT];
        bool on_path[UNIT_COUNT];
        int path[UNIT_COUNT];
        int max_match;
    }GRAPH_MATCH;
    

#### 算法实现

匈牙利算法的思路就是不停地寻找增广路径，增加匹配的个数，当不能再找到增广路径时，算法就结束了，得到的一个匹配就是最大匹配。因此，我们先实现寻找增广路径的函数，寻找增广路径可以从
X 集合的点开始，也可以从 Y 集合的点开始。如果从 X 集合的点开始，GRAPH_MATCH 数据结构中的 path 和 on_path 数组的下标就是
Y 集合的顶点编号。

寻找增广路径的算法原理就是根据给出的 X 集合某个顶点 $X _{i}$，遍历 Y 集合的所有顶点 $Y_
{j}$，看看能否将其加到增广路径上。结合我们的数据模型和上一课的算法原理，寻找增广路径的算法实现就水到渠成了：

    
    
    bool FindAugmentPath(GRAPH_MATCH *match, int xi)
    {
        for (int yj = 0; yj < UNIT_COUNT; yj++)
        {
            if ((match->edge[xi][yj] == 1) && !match->on_path[yj])
            {
                match->on_path[yj] = true;
                if ((match->path[yj] == -1)
                    || FindAugmentPath(match, match->path[yj]))
                {
                    match->path[yj] = xi;
                    return true;
                }
            }
        }
    
        return false;
    }
    

当 `match->path[yj] == -1` 的时候，说明 $X _{i}$ 和 $Y_ {j}$
连线的边还不在匹配的边集中，此时直接将其添加到匹配中就可以了。因为根据增广路径的性质，它是从 X 集合开始，到 Y 集合结束，并且 $X _{i}$ 和
$Y_ {j}$ 原来都不在匹配中。虽然此时增广路径只有一条边，但那也是奇数啊，因此，它满足增广路径的条件，怎么算是添加到匹配的边集中了呢？就是这句
`match->path[yj] = xi`，还记得前面对 path 数组的解释吗，这说明从 $X _{i}$ 到 $Y_ {j}$ 的边记录在匹配中了。

当 `match->path[yj] != -1` 的时候，说明 X 集合中的某个点（假设是 $X _{k}$ 点）与 $Y_ {j}$
的边已经在当前匹配中了，假设 `match->path[yj] = xk`，那么我们就从 $X_{k}$ 继续在 Y 集合中查找增广路径，记住，因为算法是从
X 集合开始查找的，所以增广路径必须结束在 Y 集合，要一直找到一个不在路径上的 Y 集合的点为止，如果找不到就返回
false。这个继续查找实际上是个深度优先的搜索过程，采用递归方式实现，`match->path[yj]` 的值就是 xk，直接递归调用
`FindAugmentPath(match, match->path[yj])` 就是了。

最后匈牙利算法的实现就是 Hungary_Match() 函数所展示的内容，`match->max_match`
是找到的最大匹配数，`match->path[]` 记录了最大匹配的边集。特别地，当 Hungary_Match() 函数返回 true
的时候，说明当前找到的最大匹配是个完美匹配。注意每次搜索增广路径之前，要调用 ClearOnPathSign() 函数清除上次搜索增广路径时记录的标志信息。

    
    
    void ClearOnPathSign(GRAPH_MATCH *match)
    {
        for (int i = 0; i < UNIT_COUNT; i++)
        {
            match->on_path[i] = false;
        }
    }
    
    bool Hungary_Match(GRAPH_MATCH *match)
    {
        for (int xi = 0; xi < UNIT_COUNT; xi++)
        {
            if (FindAugmentPath(match, xi))
            {
                match->max_match++;
            }
    
            ClearOnPathSign(match);
        }
        return (match->max_match == UNIT_COUNT);
    }
    

### 总结

图论中的很多算法都有公认的最优算法实现，比如本课介绍的求最大匹配的匈牙利算法，再比如带权二分图最大权匹配（最小权匹配）的 Kuhn-Munkres
算法（KM 算法），还有求稳定匹配的 Gale-Shapley
算法等。这些都是已知问题的高效算法，也没啥好发挥的，玩算法的人基本上都要准备好这些算法的实现模板，只要识别出题目适合用这些算法，直接套模板，算法框架就出来了。当然，也要根据题目的情况，适当修改算法的数据模型。

尽管网上有很多此类算法的实现，但我还是建议大家自己抽空把这些算法写一遍，研究透原理和实现。原因很简单，套模板的时候，少不了要修改数据模型，以便适应题目要求，如果不熟悉算法实现，难免会改错，耽误时间。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)。

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

