>
> 很多人都玩过“一笔画”游戏，能一笔画成的图要么是所有点的连接边数都是偶数的情况，要么是连接边数是奇数的点有且只有两个的情况。第一种情况从任何点开始都可以完成一笔画，第二种情况只能从其中一个奇数点开始到另一个奇数点结束才能一笔画成。它的原理就是我们这一课要介绍的欧拉图（Euler）和欧拉回路（Euler
> Circuits），从图论的角度看，有向图和无向图都有欧拉回路的概念，但是判定的方法不一样，这一课来介绍欧拉图、欧拉图的判定和用弗罗莱（Fleury）算法求欧拉回路的相关算法。

### 欧拉图和欧拉回路

对欧拉图的研究起源于著名的哥尼斯堡七桥问题，如图（1-a）所示，哥尼斯堡有七座桥连接一条河两岸的陆地和河中间的两个小岛，传说哥尼斯堡的居民最喜爱的消遣活动就是一次性走过这七座桥但不重复，不过好像谁也没有成功过。1736
年，欧拉将图（1-a）中的陆地抽象为一个顶点，将桥抽象为连接顶点的边，就得到了一个类似图（1-b）的无向图。欧拉最终在他的论文中证明了“存在从任意点出发，经过所有边恰好一次，并最终回到出发顶点的走法的充分必要条件是：每个顶点的度均为偶数”。显然，哥尼斯堡七桥问题不满足这个条件。

![](https://images.gitbook.cn/120d0c60-f6a2-11e8-894f-2d4c947f092d)

图（1）哥尼斯堡七桥问题示意图

后来，人们把一个图中经过每条边有且仅有一次的回路称为欧拉回路，把含有欧拉回路的图称为欧拉图。无向图中存在欧拉回路的条件是每个顶点的度数都是偶数，有向图中存在欧拉回路的条件是每个顶点的入度
=
出度，与欧拉回路对应的概念还有一个欧拉路径，欧拉路径有确定的起点和终点，它不是一个封闭的环，欧拉路径对应了引言部分提到的“一笔画”的第二种情况，但是我们这一课只讨论欧拉回路。

### 欧拉图的判断

欧拉图相关的算法有很多，这一课我们关注两个算法，一个是如何快速判断一个图是不是欧拉图，另一个是在图中寻找欧拉回路的弗罗莱（Fleury）算法。算法用到的图的例子是图（2）所示的无向图，首先要判断这个图是不是欧拉图，然后使用弗罗莱算法按照顶点名称输出一个欧拉回路。

![](https://images.gitbook.cn/33aa3e10-f6a2-11e8-84d7-dda2538adc04)

图（2）算法示例使用的图

#### 数据模型

判断图的连通性，主要关注的是顶点的连接关系，因此用邻接表的方式表示图是比较合适的选择，邻接表的数据模型前面已经介绍很多了，这里不罗嗦了，就是这样：

    
    
    typedef struct
    {
        bool visited;
        std::vector<int> relVertex;  //相邻边顶点
    }VERTEX_NODE;
    
    typedef struct
    {
        int count;   //图的顶点的个数
        VERTEX_NODE vertexs[MAX_VERTEXNODE];  //图的顶点列表
    }EU_GRAPH;
    

#### 连通图

无向图中任意两点都有边相连，则这个无向图是个连通图。特别地，对于有向图，如果任意两点都是双向连通的话，这个图就是强连通图，这里我们只考虑无向图的连通性判断，无向图的连通性判断很简单，就是从任意一个顶点开始遍历整个图，每遍历到一个顶点就将该点标记为“已访问”状态，遍历结束后，如果所有的点都被标记为“已访问”状态，那这个图是连通图，否则不是连通图。

因此，这个连通性判断算法起始就是图的遍历算法，本课程基础部分多次提到图的遍历有深度优先遍历（DSF）和广度优先遍历（BSF）两种方法，这里我们就分别用两种方法给出图的遍历算法示例，这里给出的算法是结合前面的数据模型实现的，调整数据模型并不影响算法的整体结构，可做遍历算法模板使用。

深度优先遍历图，用递归就对了，简单明了，结合数据模型定义和代码注释，很容易理解：

    
    
    void DsfEnumeration(EU_GRAPH& g, int node)
    {
        g.vertexs[node].visited = true; //设置当前点的访问标志
        for (int i : g.vertexs[node].relVertex)
        {
            if (!g.vertexs[i].visited) //i 是 node 的相邻点，并且 i 没有被访问过
            {
                DsfEnumeration(g, i);
            }
        }
    }
    

广度优先遍历需要用一个队列暂存那些相连，但是这一步来不及处理的顶点，我们用队列来维护这些暂存的顶点：

    
    
    void BsfEnumeration(EU_GRAPH& g, int node)
    {
        std::queue<int> q;
        q.push(node);    //起始位置入队列
    
        while (!q.empty())
        {
            int cur = q.front(); //取队首元素（顶点编号）
            q.pop();   //删除队首元素
            g.vertexs[cur].visited = true;   //设置访问标志
            for (int i : g.vertexs[cur].relVertex)
            {
                if (!g.vertexs[i].visited)   //i 是 cur 的相邻点，并且 i 没有被访问过
                {
                    q.push(i); //没有被访问过的顶点入队列
                }
            }
    
        }
    }
    

遍历完图之后，判断是否是连通图：

    
    
    bool IsConnected(EU_GRAPH& g)
    {
        for (int i = 0; i < g.count; i++)
        {
            if (!g.vertexs[i].visited)
            {
                return false;
            }
        }
    
        return true;
    }
    

#### 欧拉图

根据欧拉图的判断条件，一个无向图首先是连通图，然后每个顶点的度都是偶数才能被判定为欧拉图，上一节给出了连通图的判断算法，这一节继续判断每个顶点的度是否是偶数。根据我们的数据模型，每个顶点与几个顶点相连就有几条边，边数就是度，因此只需判断每个顶点的相连顶点个数是否是偶数即可（注意我们判断偶数的方法）。

    
    
    bool IsEuler(EU_GRAPH& g)
    {
        if (!IsConnected(g))
        {
            return false;
        }
    
        for (int i = 0; i < g.count; i++)
        {
            int n = g.vertexs[i].relVertex.size();
            if ((n & 1) != 0)
            {
                return false;
            }
        }
    
        return true;
    }
    

### 弗罗莱（Fleury）算法

#### 算法原理

设 G(V,E) 为无向欧拉图，在 G 中找一条欧拉回路的算法如下。

  * 任取 G 中的一个顶点 $V _{0}$，令路径 $P_ {0}=V_0{}$。
  * 假设沿着 $P _{i} = V_ {0}E _{1}V_ {1}E _{2}V_ {2}…E _{i}V_ {i}$ 到达顶点 $V _{i}$，按照以下两个方法从剩下的边（$E(G)-{E_ {1},E _{2},…,E_ {i}}$）中选 $E_{i+1}$：
    * a. $E _{i+1}$ 与 $V_ {i}$ 相连；
    * b. 除非没有别的边可供选择，否则 $E _{i+1}$ 不应该是图 $G_ {i}=G - {E _{1},E_ {2},…,E_{i}}$ 中的桥。
  * 重复第 2 步，直到不能再找到符合条件 a 和 b 的边为止。

当算法停止时，所得到的回路 $P _{n} = V_ {0}E _{1}V_ {1}E _{2}V_ {2}…E _{n}V_ {n} (V _{n} =
V_ {0})$ 就是 G 的一条欧拉回路。

设无向图 G(V,E) 为连通图，若某个边集 $E _{i}\subseteq E$，在图 G 中删除边集 $E_ {i}$
中所有的边后得到的子图是不连通的，但是删除 $E _{i}$ 的任何一个子集后得到的子图是连通图，则称边集 $E_ {i}$ 是图 G
的一个割边集。若割边集只有一条边构成，则称这条边为割边，或桥。简单理解，图（3）中连接顶点 A 和 B 的边就是桥：

![](https://images.gitbook.cn/528605d0-f6a2-11e8-8715-21906afe16ff)

图（3）桥（边）的示意图

很多算法原理都是通俗易懂的，基本上可以理解为算法的伪代码实现，但是这个 Fleury
算法的原理描述显然不能算通俗易懂。稍微翻译一下，意思大概可以这样理解：先准备好一个队列存放回路 P，然后在图中任选一个顶点 $V _{0}$
作为欧拉回路的起点，将 $V_ {0}$ 入队。按照顺序从图中选择与 $V _{0}$ 相关联的点 $V_ {i}$，将边 $E[V _{0},V_
{i}]$ 从图中删除，再继续选择与 $V _{i}$ 相关联的点，重复上述处理，直到 $V_ {n}$，如果没有与 $V _{n}$
相关联的边了，就判断一下回路（栈）中的边数是否等于图的边数，如果相等就说明回路中已经找到了一个经过所有边的欧拉回路；如果回路中的边数不等于图的边数，就将
$V_ {n}$ 出队，从队中（队首）选择顶点 $V _{k}$（假设），继续寻找与 $V_ {k}$ 相关联的边。

找到与 $V _{0}$ 相关联的点 $V_ {i}$ 后，为什么要将边 $E[V _{0},V_ {i}]$
从图中删除呢？这是因为要判断这条边是否是桥，判断的方法就是删除这条边，然后再从 $V _{0}$ 找 $V_ {i}$，如果还是能找到 $V
_{i}$，则说明边 $E[V_ {0},V _{i}]$ 不是桥，如果删除这条边后再次遍历完整个图无法找到 $V_ {i}$ 了，就说明边 $E[V
_{0},V_ {i}]$
是桥。因此，在算法实现过程中，要不停地删除边，当然，每次从队列中回退一个顶点重新搜索的时候，要恢复之前被删除的边，这个后面结合算法实现的代码再理解吧。

#### 数据模型

这个算法进行过程中要不停地删除边、增加边，因此用邻接矩阵来描述图是很好的选择：

    
    
    typedef struct
    {
        int vertexs;   //图的顶点数
        int edges;    //图的边数
        int edge[MAX_VERTEXNODE][MAX_VERTEXNODE];   //邻接矩阵
    }FE_GRAPH;
    

  * vertexs 表示图中顶点的个数，这个在寻找与 $V _{0}$ 相关联的点 $V_ {i}$ 的时候会用到。
  * edges 表示图中边的总数，在判断回路 P 中的边数是否和图的边数相等的时候会用到。

这两个值和 edge 表一样，都要在算法开始前初始化好。

使用邻接矩阵的好处是处理删除边和添加边的代码非常简单：

    
    
    void DeleteEdge(FE_GRAPH& g, int u, int v) //删除顶点 u,v 之间的边
    {
        g.edge[u][v] = 0;
        g.edge[v][u] = 0;
    }
    
    void AddEdge(FE_GRAPH& g, int u, int v) //在顶点 u,v 之间添加一条边
    {
        g.edge[u][v] = 1;
        g.edge[v][u] = 1;
    }
    

#### 算法实现

原理描述中的“重复第 2
步”这句话非常隐晦，其实，如果大家对算法很敏感的话，应该知道在图的算法中出现“重复XXX操作”的描述的时候，十有八九是要用递归了。fleury()
函数中有两个触发递归调用的地方，都是对应了“重复第 2 步”这句话。第一次是在删除边的时候，对应算法描述中“从剩下的边中选择 $E _{i+1}$ 加入路径
P”，这意味着这条边应该从图 G 中删除，加入到路径 P 中；删除边后，要从 $V_ {i}$ 开始继续搜索，即“步骤 2-a 所说的重复第 2 步”。

第二次是在 if (!flag) 的时候，此时找不到与当前顶点相邻的顶点了，说明之前最后一次删边操作删除的 $E _{i+1}$ 是桥。然而根据步骤 2-b
的描述，$E_ {i+1}$ 不能是桥，这里显然还有别的选择，那就是从路径 P 中丢弃 $V _{i}$ 顶点，从 P 中选择 $V_ {i}$
的前一个顶点（就是队列头部的那个顶点），然后从当前位置的下一个顶点开始继续搜索，即“步骤 2-b 所说的重复第 2 步”。

    
    
    void fleury(FE_GRAPH& g, std::queue<int>& s, int cur, int start)
    {
        bool flag = false;      //是否还有与 cur 关联的边
        s.push(cur);            //当前顶点入栈
        for (int i = start; i < g.vertexs; i++)
        {
            if (g.edge[cur][i] == 1)    //当前顶点与 Vi 相连
            {
                flag = true;
                DeleteEdge(g, cur, i);      //删除当前顶点与 vi 的边，然后从 vi 开始继续搜索
                fleury(g, s, i, 0);
                break;
            }
        }
    
        //没有顶点与当前节点 cur 相连
        if (!flag)
        {
            s.pop();        //抛弃最后入栈的那个顶点
            int m = s.front();
            AddEdge(g, cur, m);     //没有顶点与当前顶点相连，说明之前删除的是桥，先恢复这条边
            int new_start = cur + 1; //从当前顶点的下一个顶点继续搜索
            if (s.size() == g.edges)  //路径 P 中的边数与图的边数相等
            { 
                s.push(cur);
            }
            else
            {
                s.pop();
                fleury(g, s, m, new_start);
            }
        }
    }
    

如果理解了我对算法原理的解释，对照代码看这个算法的实现还是很简单的，算法结束后队列 s 中依次存放的就是欧拉回路路径
P（不包含回到起始点的那条边，输出时可以自己补上这条边）。

### 总结

判断无向图是不是连通图，还有一种效率比较高的方法，就是所谓的并查集方法，并查集的原理就是：初始化时将每个节点看作一个集合，每扫描一条边就把连接的两个节点的集合合并，最后遍历完所有的边，剩下几个集合就是图中有几个连通分量，若只有一个集合，则说明是一个连通图，并查集方法通常情况下时间效率较高，还能判断一个图是否有回路，这个留给读者自己实现吧。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

