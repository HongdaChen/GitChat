### 什么是状态压缩

动态规划问题中重要的一环就是确定状态的定义，在大多数情况下，状态中所包含的信息并不多，比如线性规划问题的状态一般表示为 d[i,j]（i 表示状态的位置，j
表示状态的阶段），算法实现时可用二维数组保存计算过程中的状态。但是也有一些问题，它的状态中包含的信息很多，比如它的状态可能是一个集合中各个元素的情况，或者是像铺瓷砖问题这样，是某一行的覆盖状态。如果沿用简单的状态表示方法，则可能会用到
N 维数组，这样不仅空间占用大，而且状态的转移（状态递推公式）算法也会非常复杂。不信？读者猜猜这个状态 d[i,j,k,l,m,n,o,p,q,r,s,t]
的下一个状态是什么，是 t + 1 还是 q + 1 ?

在这种情况下，如果我们能用一种编码策略，将前面例子中的 j, k, l, m, n, o, p, q, r, s, t
编码成一个整数数字，就可以将状态简化成 d[i, encode(j, k, l, m, n, o, p, q, r, s,
t)]，这种情况下就可以用二维数组来保存状态，并且状态的递推公式也会简单很多。这种策略看起来好像状态被“压缩”了，所以被称为状态压缩动态规划。

### 状态压缩和动态规划

严格来说，状态压缩是状态压缩，动态规划是动态规划，是算法模式，它们只是碰巧一起发生了而已。这种通过某种编码和解码方式将某些离散的信息（比如集合中各个元素的状态）转化成某种简单数值类型进行计算和处理的方法，在很多算法中都有体现，并非状态规划独有的方法。最常见的就是各种
hash 算法，通过比较 hash 值的方法比较原始数据的差异要比直接比较原始数据简单高效。

根据解题的经验（很多资料都是这么认为的），当一个题目具有以下两个特征的时候，就要考虑是否可以使用状态压缩动态规划方法了。

  * 数据规模的某一维或某几维非常小。比如 N x M 平面上铺瓷砖问题，大多数情况下给出的题目规模都是类似这样的：N ≤ 5，M ≤ 1000，或 N ≤ 150，M ≤ 10。
  * 题目满足动态规划特有的最优化原理和无后向性子问题描述，换句话说就是，我一看这就是个动态规划题目。

第二个特征说的识别就比较虚了，能不能一眼看出来，主要还是靠经验。没别的方法，就是刷题，题目做的多了，遇到问题就会发现脸熟的概率变大了，到那时候差不多一看就能看出来了。

### 状态压缩的常用方法

状态压缩的方法取决于问题自身的特点，通常根据需要选择合适的编码和解码方法，这一节我们介绍几种常见的状态压缩方法。

#### 整数比特位方式

如果问题在某些维度上的状态是开关量（0 是一个状态，1
是一个状态，没有其他状态），就可以考虑将这些维度上的状态压缩到一个整数中，整数的每个比特位对应一个状态。一般这时候状态的数量都不多，16 位整数或 32
位整数就可以存储这些状态。旅行商（TSP）问题中每个城市有两个状态，假设已经走过的城市标记为 1，没有走过的城市标记为 0，就可以用一个整数 S
表示所有城市的遍历状态，则遍历到第 $i$ 个城市时的状态可以描述为：

$$ d[i,S] = min { \: d[j, S-{i}] + dist[j][i]\: } $$

$S-{i}$ 的意思是将 $S$ 中第 $i$ 个城市标记为 0（未访问过），因为 $S-{i}$ 是 $S$ 的前一个状态。这里的 $S-{i}$
操作就可以用简单的移位操作来完成状态的变化：

    
    
    S = S ^ (1 << i)；
    

这种压缩方法常用的其他比特位操作方法有：

    
    
    if ( ((1 << (i - 1)) & S) > 0)  //判断第 i 位是否是 1
    
    S = S | (1<< (i - 1))   //将第 i 位设置为 1
    

#### 整数分段方法

将一个整数按照位数分段，每一段存储一个状态值的方法，就是整数分段方法。假如一个问题有三个状态，每个状态的值都不会超过
99，就可以按照整数分段的方法压缩这三个状态。比如用个位和十位存放一个状态，用百位和千位存放一个状态，用万位和十万位存放一个状态，这种状态压缩的编码方法可以简单表示为：

    
    
    S = i * 10000 + j * 100 + k; //状态编码
    
    i = S / 10000;  //解码
    j = (S % 10000) / 100;
    k = S % 1000000;
    

用 100 来分段是我举的例子，我还没见过单个状态的变化有这么多的（超过 10）的情况，我遇到过单个状态变化是个位数的情况，用 10
来分段，也就是每个十进制数字的位表示一个状态。

#### 二进制位分段方法

二进制分段方法和整数分段方法的机制类似，只不过分段的方式更细化一点，按整数比特位分段其实就是二进制分段的一种极端形式。如果一个问题的某些单个状态变化不超过
4 个状态，就可以用 2 个比特位表示一个状态；如果问题的单个状态变化不超过 8 个状态，就可以用 3
个比特位表示一个状态，以此类推。最后通过比特位移位将这些状态组装到一个位宽足够的整数中，如果 32 位整数不够就用 64 位整数。64
位都不够用的情况我没遇到过，一般出题的人都会考虑这些情况的，不会让你陷入困境，如果真的遇到了，请优先考虑你的方法是不是错了。

这种方式需要熟练使用各种位操作，基本上 C++ 和 Java 都支持常见的位操作，比如 &、|、^、<< 和
>>。下面以两个比特位分段为例，演示几个常用的操作：

    
    
    S = (i & 0x00000003) << 4;  //编码
    S |= (j & 0x00000003) << 2;
    S |= (k & 0x00000003);
    
    S = S | ((i & 0x00000003) << 4);   //设置状态 i 
    i = ((S >> 4) & 0x00000003); //取状态 i
    

### 总结

因为下一课要介绍铺瓷砖问题，这是状态压缩问题的经典例子，这个例子还是比较简单的，但是要解释状态压缩需要的篇幅超过了介绍问题本身，感觉有点头重脚轻，所以将状态压缩部分拿到这里单独介绍，希望大家看了之后，对状态压缩动态规划能有更深的理解。

[请单击这里下载源码](https://github.com/inte2000/play_with_algo)

### 答疑与交流

> **为了方便与作者交流与学习，GitChat 编辑团队组织了一个《算法应该怎么玩》读者交流群，添加小助手-
> 伽利略微信：「GitChatty6」，回复关键字「259」给小助手-伽利略获取入群资格。**

