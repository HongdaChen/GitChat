### 匿名嵌入

将其他类型匿名嵌入到复合类型，以组合方式获取方法调用权限。

  * 匿名类型字段实际以“类型”为名。
  * 不能同时嵌入 T 和 *T。
  * 方法名存在遮蔽，以“最近”为准。
  * 组合和调用语法糖，不是继承。

OOP 三大基本规则封装继承多态，继承很多语言都放弃了，涉及到很多概念比如抽象类型、覆盖、重写，Go 语言组合优先于继承。

所谓的匿名嵌入就是没有给字段名字只给类型，然后用语法糖的概念来实现类似继承的概念，用组合的方式来实现继承的能力。

比如下方代码：匿名嵌入后，Y 可以用简短模式调用 X 的方法。

### 不能同时嵌入 T 和 *T

    
    
    type X int
    type A struct {
        X
        *X // duplicate field X
    }
    

因为它们名字相同，结构体不允许有多个相同名字的字段。

嵌入 X 和 *X 名字都是 X，如果同时嵌入就会重名，同时嵌入一个类型和它的指针类型是不行的。在设计层面嵌入这两个类型实际上都是嵌入 X
的类型，目的是为了访问方法权限。

在实现层面，X 和 *X 字段存储格式不一样，它们占用内存结构也就不一样，*X 实际是一个指针，内存大小占用 8 字节，这里 X
是结构体。因为这和初始化方式有很大关系。

### 匿名字段方法

    
    
    type A int
    
    //go:noinline
    func (A) a() { println("A.a") }
    
    type B struct {
        A
        x int
    }
    
    type C struct {
        *A
        x int
    }
    
    //go:noinline
    func (B) b() { println("B.b") }
    func main() {
        o := B{A: 100, x: 200}
        o.a()
        o.b()
        o.A.a()
    
        var a A
        c := C{&a, 200}
        c.a()
    }
    
    
    
    $ go build && go tool objdump -s "main\.main" test
    

类型 A 有一个方法 a 类型， B 匿名嵌入 A，B 有一个方法 b，可以用 a 和 b 的方式调用，匿名嵌入方式让 B 拥有 A 的方法访问权限。

> 注意：简短模式 o.a() 和 o.A.a() 写法一样。

编译器会把它 o.a() 翻译成原始调用 o.A.a()。所谓的匿名字段或者匿名嵌入在编译器里实际上用类型名字作为字段名字。

嵌入指针 *T 的时候，没有初始化则访问非法的地址，有个字段内存没有初始化，调用的时候认为很危险，这涉及到语言安全规则支离破碎。

如果按照刚对函数的理解、函数表达式的理解，不初始化没有问题，因为在调用的时候并没有在里面使用。不过这里是个坑，o.a() 实际上翻译成
o.A.a()，调用这个函数需要传参数，函数定义参数是值，没有办法把 nil 转换成 value。如果函数定义是 *T 没有问题，内存是合法。

第一设计上的一种理念用组合的方式目的是想引用 A 的方法，第二考虑内存中怎么实现，用指针还是整个拷贝进来，这涉及到两种不同的层面。

前面说到结构体，结构体中有内联的问题，提到了内联不等于继承，继承的意思是有个 A，B 继承自 A，A 有个方法叫 Inc，我们可以通过 B.Inc 来调用。

匿名嵌入是 B 里面包含了 A 的结构体，A 有个方法叫 Inc，我们通过 B.A.Inc 和 B.Inc 两种方式调用，B.Inc 就是语法糖，先在 B
中找有没有 Inc 方法，如果 B 没有从 A 中找，B.Inc 就被编译器还原成 B.A.Inc，好处是嵌入了 A，用语法糖方式引入到 B
的集合中，看上去像 B 继承了 A，其实是纯粹的语法糖并不是继承。

    
    
    type N int
    
    type Z struct {
        x int
        N
    }
    
    func (n *N) Inc() {
        *n++
    }
    
    func main() {
        var z Z
        z.Inc()
    
        fmt.Printf("%+v\n", z)
    }
    

有 N 类型，有个 Inc 方法，有个 Z 类型，嵌入了 N 类型，用语法糖 Z 调用 Inc 方法：

    
    
    $ go build -gcflags "-N -l" -o test embed.go #编译
    $ go tool objdump -s "main\.main" test
    

我们看到了实际的调用 `CALL main.(*N).Inc(SB)` 还是调用 N.Inc 方法
`main.(*N).Inc()`，这实际上就是编译器会把 z.Inc 还原成 z.N.Inc。我们通过反汇编可以搞清楚最终调用的是什么。

这会涉及到方法集这样的概念，方法集概念和后面的接口有关系，是属于编译器层面上的一些技巧，我们虽然看上去调用的是语法糖转换，但是在内部其实是有很复杂的体系支撑这种逻辑。

Go
语言没有继承的概念，只有组合的概念，他对于面向对象基本特征只实现了封装，没有实现继承，多态实际上是通过接口方式实现的，没有实现继承的多态。多态有两种逻辑，子类可以出现在父类的地方，实现可以出现在抽象接口的地方。Go
语言只实现了接口的多态。

### 匿名字段方法遮蔽

    
    
    type A int
    
    //go:noinline
    func (A) test() { println("A.test") }
    
    type B struct {
        A
    }
    
    //go:noinline
    func (B) test() { println("B.test") }
    func main() {
        var o B
        o.test()
        o.A.test() //明确调用父类方法
    }
    
    
    
    $ go build && go tool objdump -s "main\.main" test
    

可以此实现类似 override 功能。

override 实现是面向对象编程很常见的案例，我们写面向对象编程有这样的案例，比如类型 A，类型 A 有个方法，类型 B 嵌入类型 A，如果在 B
中改写 A 方法。Go 怎么实现呢，Go 没有继承的概念，但是 Go
有名称查找规则。查找规则是在当前类型里找，如果有相同方法就使用，如果找不到就在匿名嵌入字段里找。这和大部分语言一样，先查找自己，自己找不着再去父类里面找。

有类型 A，有个方法叫 test，接下来 B 匿名嵌入 A，所以在 B 里可以直接调用 test。B 也定义了 test，B 现在拥有两个 test
方法一个是自己实现一个是 A 实现的，编译器选择谁？会涉及在 OOP 就近原则，从结构上来看，B 间接引用 A。A 有方法叫 test，调用的时候沿着 B
查，因为 o 是基于 B 创建的。这种方式是 OPP 继承的覆盖，假设用组合的方式实现继承功能，可以把 B 看成 A 的子类，B 可以调用 A
的方法。OOP 编程有一个概念，子类可以重写父类的方法。

这给我们一些手段来修正我们不满意的地方，但是这种手段属于侵入式设计，实际上承担了一部分 A 的责任，因为使用嵌入字段实际上表达的意思是暴露 A
所有对外公开的能力。

现在用一种方式修正 A 的某个默认行为，用自定义行为代替 A 的行为。B 只是把 A 放入了合适的位置，用户是否使用 A 是用户的责任，A
有责任维护它的接口，B 只是给 A 提供存放位置，但是一旦介入到 A 的默认行为的时候实际上承担了一部分 A
的职责，这种设计存在着一定的耦合性。我们应该考虑清楚，用什么样的方式表达这些东西，一旦介入了以后，从设计的角度来说就类似于代理模式，代理模式就是拦截真实调用之前进行检查，可能是权限检查，代理具备了拦截原本调用的能力。

我们可以把 A 隐藏起来不依赖 A，`a A` 这种设计模式就是 Facade。找了一堆零件，用一个盒子把这堆零件全装起来，怎么换零件跟用户也没有关系。

### 同级匿名字段方法遮蔽

    
    
    type A int
    type B int
    
    //go:noinline
    func (A) test() { println("A.test") }
    
    //go:noinline
    func (B) test() { println("B.test") }
    
    type C struct {
        A
        B
    }
    func main() {
        var o C
        o.test() // ambiguous selector o.test
    }
    

有些编程语言存在一种规则叫左侧优先，有点像多继承的概念。一些语言按照继承列表优先使用。

为了实现补位调整内存布局减少内存占用，造成行为发生改变。要知道这种隐式错误存在歧义，我们设计上的概念和实现上的概念要分清楚。

