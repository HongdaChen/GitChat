### Not-Addressable 设计

    
    
    type User struct {
        name string
        age  int
    }
    
    func main() {
        m := map[int]User{
            1: {"user1", 20},
            2: {"user2", 22},
        }
        m[3] = User{"user3", 22} //赋值操作会翻译成具体的函数调用
        //可读
        println(m[1].name)
    
        m[1].age++ // 通过当前指针操作 cannot assign to struct field m[1].age in map
        //不可写 cannot assign to struct field m[1].name in map
        //m[1]返回的是复制品
        //m[1].name = "aaa"
        //m[1].age++
    
        u := m[1] //赋值给变量
        u.age++  //修改
        m[1] = u //赋值操作写回去
    
        m1 := make(map[int]*User)
        m1[1] = &User{"tom", 32}
        m1[1].name = "aaa"
        m1[1].age++
    }
    

哈希表结构，鉴于扩容和数据迁移需要，设计为不可寻址模式。

设计成不可寻址是因为，内部的存储位置未必是固定的。插入数据空间不够的话，就需要进行扩容，扩容要重新哈希，key
可能被重新哈希另外的桶里。另外迁移的过程不是一次性，是分批完成，取 key 或者 Value
的地址操作过程中，可能发生扩容被迁移，对这个指针操作访问内存不安全。所以设计不可寻址，通过函数赋值是哈希算法内部算法，而通过指针直接操作内存。Go
这种设计在很多语言里也有这样的限制。

它不允许这样操作的理由是什么？字典把 keyvalue 保存在内部，当返回value
的时候有两种返回方式：第一种返回它的地址，可以直接用地址修改；第二种是整个 value 的复制品。

  * 返回地址比较危险，返回去赋值时候，不能保证是原子操作，有可能这个地址由于某种原因重新 Hash 为新地址了，在返回原来的地址上修改就破坏了内存安全模型，也就是跟它的内存安全模型可能有冲突。
  * 第二种返回的是复制品，修改的是复制品，修改的复制品没有任何意义，因为不持有这个复制品，我们管这东西叫临时变量，临时变量的意思就是没有任何东西引用它。

解决方法：

  * 第一种方式，把复制品拷贝过去，然后对复制品进行修改，修改完把整个复制品拷贝到字典里面去。
  * 第二种方式，字典的 value 使用指针，返回的复制品实际上是堆上的指针，指针指向堆上某个对象，通过指针修改对象有引用关系自然合法的。

同样的 `m[key]++`和`m[key]+=` 也遵循这样的设计。官方 issues：3117。

把 Value 读出来赋值给变量，修改变量以后把变量写回去，写回去不是通过指针操作而是调用哈希内部函数，它通过 key
重新找到处于哪个桶进行赋值。赋值语句被翻译成哈希内部函数，这个函数有哈希算法，找到对应的桶。还有一种方式 value
存储指针，获得指针不再是哈希内部的值而是目标对象，通过指针修改目标对象和字典没关系。通过指针操作对象属于语法糖。

很多语言都会有这样的情况，有些数据结构内部的存储不是固定的，甚至 C#、Java
不允许使用指针，因为对象在内存中的存储位置也不是固定的，垃圾回收会压缩空间。所以对于内存安全访问模型，我们把对象分成两种，一种是可寻址的，一种不可寻址的。不可寻址的情况下，我们应该避免直接操作内部内存，因为它的存储位置是非固定的。

### nil map

    
    
    func main() {
        var m map[int]int
        println(m[1]) // 0
        m[1] = 100    // panic: assignment to entry in nil map
    
        v, ok := m[100]
        fmt.Println(v, ok)
    }
    

nil map 可读不可写。

空字典其实和字典相关的函数实现有关系。字典 m 理论不能用，本质上是一个指针，创建字典返回的是头部指针。比较奇怪的是，可以读任何一个 key
返回默认值零值，因为没有底层初始化结构不能写。

读操作只是和函数实现有关系，如果 key 没有或者空返回零值。

Go 语言有两大模型：一个是返回值 error 模型，一个是 OK 模型。零值可能存储的就是零，可能是默认值，我们需要使用 OK 模型来判断。

### nil vs empty

    
    
    func main() {
        var n map[int]int           // nil
        m := map[int]int{}          // empty
        println(n == nil, m == nil) // true, false
        println(len(n), len(m))     // 0, 0
    }
    
    
    
    (gdb) info locals
    m = map[int]int
    n = map[int]int<error reading variable: Cannot access memory at address 0x9>
    (gdb) x/xg &m
    0xc00002e748: 0x000000c00002e758
    (gdb) x/xg &n
    0xc00002e740: 0x0000000000000000
    

n 是一个指针，8 字节，实际上没有指向任何地方。m 是 make 或者初始化语句，构建底层结构只不过在没有存数据数据而已。

### ok_idiom 设计

Go 语言字典有个设计上的缺陷。

    
    
    var m map[int]int
    // m := *new(map[int]int)
    
    // m[1] =100 //写操作失败
    v, ok := m[1] //居然能读
    println(v, ok)
    

这属于 Go
设计上的不严谨，能读但是写不行，空指针不能工作居然可以从里面读。既然不能写，又没有只读属性，那应该从设计角度保证行为是一致的，作为可读写的字典在没有合法分配内存的情况下，写操作肯定失败，读操作成功就莫名其妙。所以不能通过上面判断
m 是否合法。这属于设计上的缺陷，行为没有保证一致性。

关于 ok 模式设计还是有讲究的。

    
    
    func main() {
        var s string = "abc"
    
        m := map[string]int{
            s: 0x100,
        }
    
        b := []byte(s)
        v, ok := m[string(b)]
    
        println(v, ok)
    }
    

很多语言都有这样的一个做法用于判断 m 里面是否有个 key。Go 没有，Go 的做法实际上通过 ok 模型完成的。因为 m["a"] 返回 0，但是不知道
a 是否在字典里面。Go 语言 ok_idiom 模型会返回两个值，v 和 ok，如果不存在 v 就是默认值，ok 表示是否找到就是这个操作是否成功。

当设计一个接口的时候，返回一个默认值，默认值到底表达什么概念，能不能真的区分清楚？如果我们不关心存不存在就返回默认值没有问题，但是在默认值之外还需要知道，这个默认值到底是怎么得来的？是因为操作成功得来的，还是因为操作失败得来的？默认值还有一种可能就是真实的值，所以在设计时可以返回两个值，默认值和原因。

