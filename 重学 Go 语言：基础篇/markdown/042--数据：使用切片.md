### 用 new 或 make 创建引用类型的差别

在不同语言里，对分配内存有不同做法。Go 语言分为两种方式，一种是 new，一种是 make，这两种方式有很大的差别。

我们 new 一个类型，比如 new(int) 的时候怎么分配内存呢？它计算出类型的长度，int 是
8bit，然后在堆上或者在栈上分配空间，然后返回这个指针，不管是什么类型都是一样的。

  * new 一个数组 new([8]byte) 计算类型的长度 8bit，分配 8 字节内存空间，指针返回；
  * new 一个切片 new([]byte) 计算类型长度 (ptr(8bit)+len(8bit)+cap(8bit))，三个字段组成的 24 字节内存空间，指针返回。

new 并不会把复合结构完整地去创建，它只计算出当前这个类型究竟需要占用多大的内存空间。很显然用 new 创建切片，这个切片本身是没有办法工作的，其中指针
ptr 没有指向任何底层的数组，因为切片是用来管理数组的，如果被管理的对象不存在，那这个管理对象本身没有任何意义。

Go 语言对于一些复合结构使用了一个语法糖，表面上看上去 make 函数，但实际上这个 make 函数是一个语法糖结构，当我们去
make([]byte,0,8) 时候，首先会创建切片本身头对象（ptr、len、cap），然后创建底层数组，数组容量是 8
个，然后把指针指向开始位置，len 设为 0，cap 设为 8。

很显然 make 操作就包含了几个步骤：

  * 第一步，创建切片本身
  * 第二步，分配底层数组
  * 第三步，初始化切片属性

整个 make 操作是由这三部分组成的，它会翻译成标准的 makeslice 函数。

![enter image description
here](https://images.gitbook.cn/05a11a70-1c35-11ea-92d2-695368b0b395)

为什么说 Go 语言用 make
创建引用类型比较坑爹，因为把它称之为引用类型，仅仅是由于有一个指针引用其他的数据结构，这样的结构称之为引用类型。就是当前类型内部有一个指针引用另外一个数据结构，这和
C#、Java 的引用类型很大的差别。

### 切片传递

    
    
    //go:noinline
    //go:nosplit
    func test(x []int) {
        fmt.Println(x)
    }
    func main() {
        a := [...]int{0x11, 0x22, 0x33, 0x44}
        b := a[:]
        test(b)
    }
    
    
    
    $ go build -gcflags "-m -S" 2>a.txt
    

切片可能导致堆内存分配。

切片本身是一个很简单的结构体，那么传递切片的时候，Go 语言是值传递，即拷贝三个字段，底层数组和切片不是一个整体。这就是切片传递的时候代价很小。

底层数组如果非常大的情况下，复制切片复制三个字段就可以了。反汇编看到内存逃逸，通过 newobject 分配内存，statictmp_0
是把字面量统一打包到 rodata 起个名字，把字面量复制进去，接下来把三个参数入栈调用 test。

### 如何比较两个切片内容相等？

切片操作不支持负索引，不支持倒序，不支持步进。它就是非常简单的半开区间。

切片不支持比较。

比较意义：

    
    
    func main() {
        a := [...]byte{1, 2, 3}
        //b := a //b必然是复制了一份a
        b := [...]byte{1, 2, 3}
    
        fmt.Println(a == b)
    }
    

这个意思不是说判断 a 和 b 指向同一个对象，因为它不是判断指针，而是我们想判断它们的内容是否相同。{1, 2, 3}
是有存储顺序的，它每个元素长度是固定的，所以按照这东西比较，当其中任何一个不符的话它就会返回一个假值。

我想判断两个切片内容相等怎么办？转换为 []byte，然后 bytes.Equal。

    
    
    func main() {
        a := []int{1, 2, 3}
        b := []int{1, 2, 3}
    
        //fmt.Println(a == b)
    
        //错误方法
        xa := *(*[]byte)(unsafe.Pointer(&a))
        xb := *(*[]byte)(unsafe.Pointer(&b))
        fmt.Println(bytes.Equal(xa, xb))
    
        type header struct {
            ptr *int //可以持有这个指针，也可以不持有
            len int
            cap int
        }
    
        ah := header{&a[0], len(a) * 8, len(a) * 8}
        bh := header{&b[0], len(b) * 8, len(b) * 8}
    
        ax := *(*[]byte)(unsafe.Pointer(&ah))
        bx := *(*[]byte)(unsafe.Pointer(&bh))
    
        fmt.Println(bytes.Equal(ax, bx))
    }
    
    
    
    invalid operation: a == b (slice can only be compared to nil)
    

错误提示 slice 只能比较是否为 nil，也就只能说是否初始化过，但是我们不能用来比较两个切片内容是否相同。

标准库 bytes.Equal
提供了，按照字节来比较两个字节切片内容是否相同，但是如果不是字节怎么办？这种场景很多，有时候我们拿到两份数据，我们想判断这两份数据是否相同。一种情况它们指向相同地址相同长度的内存，如果它们不在同一块内存怎么办？既然标准库提供了
bytes.Equal，我们无非把它们转换为字节切片 []byte 就好了。

当你手上持有指针的时候，可以转换任何内存结构。

`*(*[]byte)(unsafe.Pointer(&a))` 转换出来的到底是头部还是指向的底层数组？我们的目标实际上是比较底层的数据是否相同。

切片的结构体 {指针、长度、容量} 是一块内存，指针指向的底层数组是一块内存，很显然 `&a`
取出来的是结构体的内存地址，`*(*[]byte)(unsafe.Pointer(&a))` 转换完依然是
{指针、长度、容量}，是比较第一个整数的三字节，后面相等不相等理论都一样。

切片的结构体 {指针 Ptr、长度 3、容量 3}，指针指向的底层数组 `[...]int{1, 2, 3}`，底层数组小端布局实际上是
`[...]byte{10000000, 01000000, 11000000}`。如果把切片头部从 []int 转换为 []byte
的时候，新的切片结构体是 {指针 Ptr、长度 3、容量 3}，实际上是比较 3 个字节，后面根本不比较。

所以当转换的时候，你有没有考虑过不同单位可能会存在长度不一致的问题？int 类型的长度和 byte
类型的长度在内存中是不一样的。所以需要明白，这种转换到底是合法的还是不合法的。转换完我们需要长度调整，接下来需要修改 []byte
里面的数据。那么原来的信息可能被我们改掉，因为 []int 和 []byte 内存是同一块内存，只是转换一个指针类型。

最简单的做法，我们抛弃对方的切片结构，取出来第一个元素的地址，重新去构建新的头，不直接使用原来的头部信息。

虽然我们了解 header 结构，但是内存转换的时候一定需要搞清楚内存布局是什么样的，当我们把 []int 转换为 []byte
的时候，其实用同样的一块内存，只是换种方式来访问，因为数据类型不同，导致访问的内存单位发生变化。原来访问 3 个整数，现在变成访问 3 个字节，因为 len
和 cap 还是 3，你没有修改这个数字。所以转换为 []byte 的时候，你需要把 len 和 cap
相应的长度转换为新的步进长度。同时需要注意，你不应该修改原来的值。

当你做一些东西的时候，一定需要搞清楚内存布局是什么样的，这样才能保证你所有的操作是安全的。当你拿到指针，这意味着“危险”，因为指针可以越界，而且不同类型的指针访问路径不一样。

