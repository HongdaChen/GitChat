切片比较诡异的地方是，不支持 Pointer[index]
访问，这也是它设计上的理念差异。就想表达当你拿到切片指针的时候，很明确地就想操作头部结构体内存。数组指针拿到的是数据的内存。通过这个限制很明确地想表明你操作的目标到底是谁。这东西在某些语言里就是说我替你自动转换了，但是有些严谨的语言就不替你转换。你想操作可以，你用
`(*pb)` 恢复成一个切片，然后用切片的行为去访问。

系统语言对内存操作非常严谨，你想操作的内存到底是什么东西，编译器替你优化那是语法糖，不替你优化的时候，你必须知道你操作的是哪一块内存。

    
    
    func main() {
        a := [...]int{1, 2, 3} //array
        b := a[:] //slice
    
        pa := &a //array pointer
        pb := &b //slice pointer
    
        pa[1] = 10 //pointer[index]
        pb[1] = 100 //pointer[index]
        (*pb)[1] = 100 //sliceptr[index]
    }
    

`invalid operation: pb[1] (type *[]int does not support indexing)`
错误提示切片指针不支持索引操作。

当你拿到数组指针的时候，你很显然需要操作的就是数组这块内存，这个行为非常确定。当你拿到切片指针的时候，默认持有的是头部内存，它不允许在这种数据结构上按照索引访问，因为就这块内存来说你用索引访问这三个字段是非法的，结构体默认情况下不支持索引访问的，这种行为是不合理的。

有一个函数，接收接口类型的切片，为什么不能传递 `test([]int{1, 2, 3})` 进去呢？不应该把 `[...]int` 自动转换为
`[]interface{}` 类型么？

编译器的确可以帮你转换，但是这绝对不是内存的隐式转换，`[...]int` 内存结构是每个格子是 8byte 的数组，`[]interface{}`
内部结构是由两个指针组成 {itab，data}，至少 16byte，这两个玩意如果不插入代码直接转换，从内存的角度肯定不能直接转换。

很显然这两块内存不能直接转换的，必然需要写代码，比如 for
循环重新赋值的代码。这段代码可以由编译器自己生成，我们管自动生成的代码称之为语法糖，编译器帮你完成这种事。

很显然大多数系统语言所谓的转换，都是在同一块内存上转换不同的类型，这两个内存结构根本不同，这时候这种转换逻辑肯定会出错，因为它们的数据结构根本不一样。所以需要搞清楚，转换的两种行为方式：第一种直接在原来内存上转换类型，第二种编译器隐藏替你插入这样的代码。系统语言很多转换是基于内存的一种行为。

    
    
    func test(x []interface{}) {
    
    }
    
    func convert([]int) []interface{} {
        // for {
        //  ...
        // }
    }
    
    func main() {
        test(convert([]int{1, 2, 3}))
    }
    

这些很小的细节会体现出一些系统语言和应用语言在设计上的差异，比如像 Python、Java
这种应用型语言，有很多的语法糖替你完成很多的事情，但是在背后这种东西也隐藏着另外一个问题：让学习者养成惰性，不再关心底层实现，也不关心底层怎么来的，造成只是会用。当需要自己去设计逻辑的时候，并不知道边界在哪，因为我们知道这么多设计都是中庸方案。你不可能偏向于某一方。

比如我们要设计架构，你偏向于性能时必然会使用非常苛刻的限制，当你完全偏向于应用，你的代码中就存在着大量所谓的魔法。因为很多东西为了用户方便，你实现了大量的魔法，也就意味着想做优化就可能很苦逼了，所以取中庸，哪些地方该设限制、哪些地方应该放弃，同时你要培养用户什么样的习惯，架构当中都需要考虑的事情，你设计个算法也好，暴露什么、隐藏什么，这些东西都需要我们去思考。你需要搞明白，你是个设计者，你不能永远把自己当做用户。

所有的应用开发人员永远把自己定义在用户层面，它们用任何一门语言，第一个想到这门语言方便不方便，能不能自动帮我完成什么工作，自动转换啊、自动操作符重载。结果就养成不动脑子，“这些在
Java、.NET 语言中能自动帮我完成，为什么到你这就不行”。

学习一门严谨的语言，Go
是相对严谨而不是绝对严谨。它为什么要做这个限制？比学习语法更重要，因为这个时候实际上是在培养你的思维能力。如果是我，会考虑数组和切片到底有什么不同，因为很多时候我们只用切片不用数组，甚至在标准库里都看不到有数组的痕迹。

那你别忘了一点，当你使用标准库的时候，你是个用户，当你自己去开发一个库的时候，如果这个库有性能要求，那你是设计者。当你处于设计者或者用户时候，思维方式是不一样的，用户只关心暴露给它的，而设计者除了考虑暴露什么以外，还得考虑不暴露的地方该怎么做。这是两种思维。

如果你是架构师或者核心开发人员，你必须得明白，对外怎么思考，对内怎么思考，这是不同的。这个边界在哪？这个中庸的点到底在哪？天平的砝码到底怎么放？怎么样是合理的？这些都是需要培养的。你就得从一些语言，从它的一些细微设计，可能很多人不介意不关心的地方，来看作者设计的到底出于什么考虑。

例如 `var s []int`，很多人会说这地方根本没有分配内存，所以你不能访问，或者 `var x
*int`，指针根本没有初始化，这指针根本不能用。这些说法即对也不对，因为当做普通用户，这说法勉强算作对，但是如果作为系统级程序员，你一定要搞明白这玩意到底在你脑子里是什么样子的。

