### 数组

我们站在汇编的角度基本上没有数据结构一说，只有纯数字。要么传地址，地址也是一些整数，要么就是把内存中一些字节从寄存器搬到内存或者从内存搬到寄存器或者做一些简单的数学运算。所以站在汇编的角度事情很简单很直接。这样的好处就是我们可以抛开很复杂的抽象理论去研究计算机本质是怎样工作的。

那么带来的问题是，在我们编程时不可能全部用数字来表达所有的东西，需要用抽象概念来表达这些数字。从本质上来说，不管是字符串还是对象还是类型，都是由一些数字构成的一些数学模型。当我们学习这些抽象概念的时候，我们一定要有一种途径把它还原成原始的状态。

我们就来研究一些基本类型以外的复合类型。从字面上来说复合类型就是由多个基本类型构成的。由多个独立内存块构成的数据结构通常称之为复合类型。当然在不同的语言里对于复合类型的定义不太一样。比如说
C 语言里默认没有字符串的概念，它是以某个结束符标记的字节数组称之为字符串。

我们想象一下整个内存看做成超大号的字节数组，其中地址就是数组的序号，所以说不管类型多么复杂，归根到底它是在数组之上进行抽象的。所谓的虚拟地址空间就是看做成字节数组，在这字节数组之上通过一些关联逻辑把它构想成一个复杂的数据结构。

我们最终还是需要把数据结构最终还原成具体的内存布局。学习 C
语言时都知道研究一个对象的时候首先需要知道它的内存布局结构，理解内存布局结构关系到我们进行代码优化，选择什么样的算法。因为这样我们才知道，当传递一个对象的时候究竟复制的是什么东西：如果是简单就把整数复制过去，复合结构是复制一块呢？还是把两块全部复制？这是有很大差别的，如果是由指针指向的，是复制本身还是连指针指向的内存块一起复制？如果只复制本身，那么是不是有另外的指针也指向那块内存块，那么这时候就会存在数据竞争问题。

所以对于一个复合类型来说，我们必须要知道它究竟在内存中是什么样的，它是怎么构成的。这个对于我们选择什么样的数据结构，或者进行什么样的优化有直接的关系。

基础类型有两种类型是最原始的，一种是字节，内存是由字节构成。另外一种是数组。复杂数据类型都是在基础类型之上做一些包装和叠加。

数组是所有类型的基础类型。一个整数也是一个字节数组，比如说 64 位整数在内存中是由 8
个字节组成的字节数组。整个栈内存空间可以看成一个字节数组，地址就是数组的序号，SP+
偏移量就是访问内存，所有的数据结构都是由数组的方式构成，因为我们的内存空间可以看成数组。数组是所有类型里面最基础的类型，而且它还有个特点是数组的访问效率是高的，因为我们只需要给出它的下标就可以访问某一个元素，给出一个下标的情况下，编译器会优化成很简单的偏移寻址操作，对于寻址操作的效率非常高。

数组存储一个序列，它有几个特点。第一，它的地址是连续的，天生具备空间上的亲和性，基于局部性原则。对于 CPU 的缓存来说，CPU
的缓存是按照线性的空间缓存的，数组在一定条件下具备最好的性能。很多复杂一些的数据结构都尝试在局部使用数组优化它的访问，比如哈希表、链表，都会尝试去使用它。但是数组的缺点也很明显，相对来说功能比较呆板，删除数据或者插入数据都很麻烦。

我们很少使用一种单纯的数据结构，而用很多复杂的方式来组合。我们不建议直接使用数组，而是把它作为底层数据结构去包装，插入或者删除操作的时候，把链表和数组组合起来的方式去处理，利用简单的局部性操作，来改善数组本身的一些问题。

举个例子来说，数组插入数据很麻烦，实际上有种做法是实现类似开放式链表的结构，比如 123，第一种做法把 3 向后移，把值写到 2
后面。另外一种做法，如果后边数据量比较大，用链表来改变结构，12
依然保留，链表指向数组头部，链表后面节点指向一个新的结构，把新值赋值进去，后边再用一个节点指向 2
后面的位置，即把连续的空间利用链表的方式打断，最后检查破碎率，尝试压缩处理重新把数组还原把链表删掉。

类似这样的做法在垃圾回收算法中也常见，比如基于压缩、拷贝的方式，因为整个内存空间本质就是一个大数组。插入数据、删除数据、压缩数据实际上利用一些手段改善这种操作。

数组在不同的语言里不同的实现，有些语言支持动态数组，有些语言不支持。大多数情况下 Python
很少去使用数组，虽然类库支持。但我们通常使用链表的构造方式，链表的底层有可能是数组实现，也有可能是链表实现，所以当我们选择一个结构需要搞清楚到底是什么。数组在不同的语言表现方式也不一样，可能是引用传递，就是传递的是指针；也可能是值传递，把整个数组拷贝过去。

Go 语言 map，如果在 8 个 key、value 以内，实际上会把 map 退化成数组来使用。因为数组被缓存到 L3
的缓存，简单的快速遍历远超过函数调用计算哈希。使用切片或者指针返回数据，可能导致对象发生逃逸，付出很大的代价；在栈上拷贝很小的内存片段速度实际上非常快，所以在局部很小的空间内，使用数组优化性能。

#### 数组初始化

    
    
    func main() {
        var a [4]int
        b := [...]int{1, 2, 3}
        c := [...]int{1, 2, 100: 100}
    }
    

基础数据结构：

  * 长度是非负整数常量表达式
  * 长度是类型组成部分

数组的初始化方式有很多，指定一个长度或者根据表达式初始化值的数量或者使用索引号来指定某一位置，这都是语法层面上的语法糖，在底层编译器都是一回事。

Go 语言不支持动态数组，必须设置数组的长度，它是类型组成部分。

#### 长度常量表达式

    
    
    func main() {
        a := 0x11223344
        b := *(*[unsafe.Sizeof(a)]byte)(unsafe.Pointer(&a))
        fmt.Printf("% x\n", b)
    }
    

编译期可以计算结果的常量表达式。

定义数组长度不仅仅是数字也可能是常量表达式，表达式在编译的时候计算出来用数字替代，这也算是语法糖。

#### 数组值传递

    
    
    //go:noinline
    //go:nosplit
    func test(x [3]int) {
        fmt.Println(x)
        println("test:", &x)
        x[1] += 100
    }
    func main() {
        a := [3]int{0x11, 0x22, 0x33}
        test(a)
        fmt.Println(a)
        println("main:", &a, a[1])
    }
    
    
    
    $ go build && go tool objdump -s "main\.main" test
    

  * 使用数组指针或切片传递，避免值拷贝。
  * 某些时候，传递数组有更好的性能。

在 C 语言里对于数组的处理是这样的，比如数组 A，A 代表的是起始地址，所以可以对 A
做加法运算，每加上一个序号偏移，实际上就是根据元素的长度来做偏移寻址。

Go 语言里数组也是一个连续内存，但是数组本身并不代表指针了，可以获得 A[0]、A[1] 的地址，但是 A 本身不再代表 A 的起始地址。

![](images/array_definition_c_go.png)

所以在不同语言里，数组符号名字代表什么有很大的差别，在 Go 语言里 A 代表数组一整块内存，而在 C 语言里 A 代表起始位置。

这个差别会带来什么问题呢？C 语言里传递 A 的时候传递是指针，Go 语言传递 A
的时候传递的是数据。对于汇编层面来说，传递数据会复制数据，如果传递的是指针就复制指针，传递值就复制值。在 C
语言里传递指针只是复制指针，传递过去以后都共享同一份数组，因为两个指针指向同一个数组，我们管这种方式叫做引用传递。在 Go 语言里 A
代表的是整个数组，传递的时候会把整个数组复制一次，它们各自持有不同的复制体。

![](images/array_copy_c_go.png)

C 语言的数组名字是指向第一个元素的地址。Go 语言数组是值传递的，当一个数组赋值给另外一个变量的时候或者参数的时候，它会把整个内容进行拷贝。

通过指针来判断是不是同一个对象，还有个做法是对数组的修改是否会影响外面的数据。

通过反汇编的方式来验证，数组 A 当成参数传给 test。根据调用约定不是 SP0 开头存的是局部变量，从 SP0
开始提供参数，明显看到存在两份数据很显然是被复制过的。

看到首先把 `1, 2, 3` 保存了一份 `MOVQ $0x1, 0x20(SP)`，接下来把这些数据拷贝到传参的区域 `MOVQ 0x20(SP),
AX`，最后调用 test。所以从这一块我们可以看出数组被复制的过程。

我们改成指针，看看复制的是什么。

    
    
    func test(x *[3]int) {
        println("test:", x)
        x[1] += 100
    }
    
    func main() {
        x := [3]int{1, 2, 3}
        test(&x)
        println("main:", &x, x[1])
    }
    
    
    
    $ go build -gcflags "-l" -o test test1.go
    $ go tool objdump -s "main\.main" test
    

看到首先把 `1, 2, 3` 保存了一份 `MOVQ $0x1, 0x18(SP)`，接下来把数组起始地址保存起来 `LEAQ 0x18(SP),
AX`，最后把地址放到 SP 调用 test。这时候我们注意到，复制的仅仅是指针，没有复制元素。

