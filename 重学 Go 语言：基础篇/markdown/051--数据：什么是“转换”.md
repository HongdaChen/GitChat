### 转换

字符串数据结构先是有底层的字节数组，保存
helloworld，然后标准头对象有个指针指向字节数组开始位置，有个长度。这样的结构看上去有点像切片，区别在于没有容量，因为字符串一旦创建之后，它是只读的，在只读的情况下容量含义没有意义了，因为没有扩容的可能。所以字符串与切片具备一定的结构重叠。

![enter image description here](https://images.gitbook.cn/c20124c0-2195-11ea-
bb46-07e0f92c6feb)

那么我们需要字符串类型转换的时候，普通的转换是 string 转换为 []byte 或者 []ruce，[]byte 或者 []ruce
进行修改，修改完再转换为
string。这样做需要做两次内存分配操作，第一次不可变到可变做一次内存分配，然后可变到不可变再做一次内存分配，很显然这种类型转换效果很差。

既然数据结构上存在相似性，如果我能保证数据安全的情况下，我们能不能通过别的方式提供性能优化呢？那么说下简单的转换方式。

假如一个原始字符串，它是动态创建的，并不是保存在 rodata 里，比如访问客户端返回的，不会保存在 rodata
里而会保存在堆上面，也就意味着字节数组本身默认情况下是可读写的，只不过因为它是字符串，编译器阻止我们对其操作，那么如果把它转换为切片，只构建切片的头部信息，p、l、c，其中
c=l，p 和 l 从字符串头部信息复制过来，这样的话 p
就是指向底层数组了，我们所消耗的成本仅仅是创建头部信息的成本，我们用创建后结构读写操作的时候，很显然编译器并不阻止对字节数组的读写操作。

那么把字符串转换为切片，简单转换方式只创建一个头，然后底层数组并不创建，很显然这样一来性能就会很高，因为我自己保证底层的数组是有效的是可读写的，我们只是用这种方式避开编译器检查，这样就是很常见的性能优化策略。同样地，把切片转换为字符串就更简单了，连头都不用创建，直接返回
p 和 l 就是一个字符串，把 c 抛弃掉。

所以这是一种很常见的利用指针类型转换实现对内存不同访问，比如一个整数在内存中由 4~8 个字节组成，如果用 int
类型访问的时候就是一个整数，如果转换为字节数组访问实际上是 8
个字节构成。内存里面数据都是一堆数字，关键是你是用什么类型访问这些数据，类型不同也就意味着对数据处理方式不同，同样的我们只要实现对指针类型的转换，我们就可以对同样的内存有不同的读写方式。只要拿到一段内存的指针，接下来可以把这段内存看做什么是由你自己决定的，完全不用考虑编译器的一些限制。

我们进行性能优化的时候，往往通过会我们自己对内存进行干预来避开编译器一些复杂操作，因为这样更直接。以字符串转换为例，它就避开了复制操作，因为字节数组我们没有任何的处理，我们只处理了头信息，头信息最大
24 字节，底层可能有 1MB。这就是很典型的性能优化策略。

    
    
    func main() {
        s := "hello, world!"
        fmt.Printf("s: %#v\n", *(*reflect.StringHeader)(unsafe.Pointer(&s)))
        bs := []byte(s)
        s2 := string(bs)
        fmt.Printf("bs: %#v\n", *(*reflect.SliceHeader)(unsafe.Pointer(&bs)))
        fmt.Printf("s2: %#v\n", *(*reflect.StringHeader)(unsafe.Pointer(&s2)))
        rs := []rune(s)
        s3 := string(rs)
        fmt.Printf("rs: %#v\n", *(*reflect.SliceHeader)(unsafe.Pointer(&rs)))
        fmt.Printf("s3: %#v\n", *(*reflect.StringHeader)(unsafe.Pointer(&s3)))
    }
    

与 []byte、[]rune 转换，均需要重新分配内存，并复制数据。

因为字符串本身是不可以写是只读的。如果对它修改必须转换成 []byte 或者
[]rune，修改后再转换回来。这会导致在转换的时候都会涉及重新内存分配。我们通过头信息输出，看指针指向是不是原来的位置，判断内存是不是重新分配。这会导致处理字符出现性能问题，而处理字符串是编程中最常见的操作。所以需要一些特殊的优化方式。

字符串 s，利用反射方式把头信息两个字段输出。通过指针指向是不是同一个数组，接下来把字符串转换成 []byte，输出字节数组的头部信息。然后再把
[]byte 还原为字符串。对比指针知道有没有重新分配。三个内存地址都不一样，意味着都需要重新进行内存分配和复制。

### 非安全转换

    
    
    func main() {
        bs := []byte("hello, world!")
        fmt.Printf("bs: %#v\n", *(*reflect.SliceHeader)(unsafe.Pointer(&bs)))
        s := *(*string)(unsafe.Pointer(&bs))
        fmt.Printf("s: %#v\n", *(*reflect.StringHeader)(unsafe.Pointer(&s)))
    }
    

基于 []byte 和 string 头部相同改造，直接做指针类型转换。

字节数组转换成字符串，字节数组和字符串的数据结构是指针长度容量，指向底层数组。字符串数据结构是指针长度，指向底层数组。字符串的结构和字节数组其实是一致的，如果把容量字段去掉就从切片变成字符串。实际上完全可以把切片转换成字符串。这种转换方式就涉及到指针类型的转换，不安全是底层数组内存。切片转换成字符串安全问题不大，因为字符串本身不能写。只要内存存在就没问题，所以这种转换比较安全。这样不会涉及任何的内存复制不需要重新分配内存。

    
    
    func main() {
        s := "hello, world!"
        h := *(*reflect.StringHeader)(unsafe.Pointer(&s))
        fmt.Printf("s: %#v\n", h)
        bh := reflect.SliceHeader{
            Data: h.Data,
            Len:  h.Len,
            Cap:  h.Len,
        }
        bs := *(*[]byte)(unsafe.Pointer(&bh))
        fmt.Printf("bs: %#v\n", *(*reflect.SliceHeader)(unsafe.Pointer(&bs)))
    }
    

字符串转换成字节序列的话，稍微复杂一点。第一个不安全的地方是访问不安全的空间。第二个不安全的地方是原来指向的底层数组，某种情况下不能修改的，可能分配在
rodata 上。

字符串转换成字节切片的时候，新建头部结构体，把前两个字段拷贝过来，容量用长度填充。关键在于得保证底层数组内存可以写。这种转换方式啊不是很常见。大多数情况下基于文本、文件都是字节序列，转换成字符串方式非常常见的。

我们可以看到底层数组没动过，需要付出的代价仅仅是创建了一个头对象。

### 不同转换方式性能对比

转换方式用 unsafe
方式来转换，在字节数组和字符串结构之间进行转换。任何一门语言一旦有操作指针的能力，很少有东西限制住你，你可以在真实项目中尽可能不使用它，但是对于学习来说，所有的规则都是用来打破的。

    
    
    func main() {
        b := []byte("hello")
        ps := (*string)(unsafe.Pointer(&b))
    
        bh := (*struct {
            ptr uintptr
            len int
        })(unsafe.Pointer(&b))
    
        byh := (*reflect.StringHeader)(unsafe.Pointer(&b))
    
        ph := (*struct {
            ptr uintptr
            len int
        })(unsafe.Pointer(ps))
    
        fmt.Printf("%+v\n%+v\n%+v\n", *bh, *byh, *ph)
    }
    

普通转换把一个字节数组转换为字符串，非安全转换就是我们直接用指针类型来处理头信息来避开复制底层的字节数组，首先确保普通转换和非安全转换方式结果是一样的，很显然两次转换结果是一样的。

    
    
    func BenchmarkTest(b *testing.B) {
        bs := []byte("hello, world!")
        b.Run("safe", func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                _ = string(bs)
            }
        })
        b.Run("unsafe", func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                _ = *(*string)(unsafe.Pointer(&bs))
            }
        })
    }
    

写一个性能测试，性能测试里面有两种方式，一种是常规的转换方式，一种非安全转换方式。对比两种不同的转换方式性能差别到底有多大？

    
    
    $ go test -bench . -benchmem
    BenchmarkTest/safe-4 200000000 6.61 ns/op 0 B/op 0 allocs/op
    BenchmarkTest/unsafe-4 2000000000 0.33 ns/op 0 B/op 0 allocs/op
    

这个差别还是挺大的，在 Web
框架中时时刻刻处理大量这种转换操作，这个性能开销是非常可怕。这个例子没有体现出来是可能涉及到额外的内存分配，复杂的场景底层数组可能逃逸到堆上，性能差距进一步会增大。

很显然我们自己写的转换方式比语言默认快很多倍，另外我们阻止了一次内存分配，没有复制底层数组。所以有些时候这种非安全方式带来的性能差异非常大。前提是我们对于它的内存布局有足够的了解，默认的方式自己做了哪些操作，正是因为知道这样我们才有针对性对它做性能优化。

**有必要退化成指针操作么？这样就不安全了。**

首先不安全并不是不可用，不安全仅仅是认为如果你没有足够的知识、没有足够的能力，这个不安全代码可能会带来一些麻烦，比如说数据不小心弄丢了，弄丢了话，这个指针就变成悬垂指针或者是野指针，你访问的目标可能是错的。

第二种可能意外的造成内存泄露，因为让垃圾回收器不能正常工作。非安全的前提是你自己得保证它的安全，但是非安全并不等于不可用。你能不能使用非安全代码，仅仅是因为你的能力问题，而不是语言的问题。

**对于复杂的指针转换获取性能是不是有必要？**

说这话的根本没有碰到过针对性能带来的巨大压力。有些时候我们为了性能可以抛弃其它的一切，因为在早期我们为了获得性能，最极端的做法直接用内联写代码。

**那不如加机器？**

增加机器的前提你设计的数据结构或者架构本身支持你加机器，加机器未必提升性能，只是做了分流，但是不能减少单次访问压力。这是两码事，针对面不一样。当 QPS
大的情况下，垃圾回收器往往成为我们的性能瓶颈，所以我们要减少在堆上内存分配。

