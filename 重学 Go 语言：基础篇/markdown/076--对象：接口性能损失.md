### 接口性能损失

    
    
    type Xer interface {
        A(a int)
    }
    type X int
    
    func (X) A(b int) { println("a") }
    func main() {
        var o X
        var e Xer = &o
        o.A(1)
        e.A(1)
    }
    
    
    
    $ go build && go tool objdump -s "main\.main" test
    

动态调用消耗不大，主要影响是对象逃逸和无法内联。

使用接口的时候，从静态绑定变成动态绑定不会有很大的性损失，动态查找的过程实际上很精简无非十几条指令。接口造成的性能损失不是动态调用。主要的损失可能会导致内存逃逸，对象复制，如果指针传递可能导致对象本来在栈上，结果在另外地方有一个指针去引用它，可能导致对象从栈上跑到堆上。内存逃逸会导致性能损失，因为在堆上分配对象代价比较大。还有就是方法需要动态调用，可能造成没有办法内联。原来方法调用是可以内联的，通过接口调用不能内联可能会带来一定的性能损失。

先通过方法来调用，A 可以内联的也没有发生逃逸行为。如果通过接口来调用的时候发现有逃逸。内联可能就取消了。

关于接口什么时候该用什么时候不该用的问题。假设一开始是在一个设计层面上，在设计的时候很少会涉及到细节，更多是基于比较大的模块去设计，设计的时候，往往是由单个人和单个团队完成的。在编码上由单个人完成的时候，最大的要求是性能，很多优化的细节是尽可能的减少额外中间环节，因为整个代码权在个人的控制范围之内，而且内部的细节没有必要公开。当设计这样一个模块时候，涉及到内部的构造不应该用接口，中间环节越少越好，因为整个代码都在控制范围之内。

设计上很多时候不要过度设计，不要把一些莫名其妙的东西加进来。不要因为接口有解耦的能力就什么时候都用。在设计模式上有很多情况下，听到另外一个词叫反模式，甚至拒绝使用设计模式。比如在系统设计领域很讨厌设计模式，因为它会增加很多额外的负担。接口很大程度上是用来做组合的，在对性能要求非常高的领域不愿意用接口。

### 接口调用与直接调用的性能差异

直接调用是静态绑定，接口调用是动态绑定，因为接口调用的地址是在运行期从栈帧里面取的。很显然动态绑定的性能低于静态绑定。我们对比一下接口调用到底有多大的性能损失。

    
    
    type N int
    
    func (n N) A() int {
        c := 0
        for i := 0; i < 1<<20; i++ {
            c += i
        }
    
        return c
    }
    
    type Ner interface {
        A() int
    }
    
    func BenchmarkCall(b *testing.B) {
        var n N = 0x100
    
        for i := 0; i < b.N; i++ {
            _ = n.A()
        }
    }
    
    func BenchmarkIface(b *testing.B) {
        var n N = 0x100
        var e Ner = &n
    
        for i := 0; i < b.N; i++ {
            _ = e.A()
        }
    }
    
    
    
    $ go test -v -bench . -benchmem
    
    
    
    BenchmarkCall          5000        290851 ns/op           0 B/op          0 allocs/op
    BenchmarkIface         3000        339684 ns/op           0 B/op          0 allocs/op
    PASS
    

从汇编角度，动态绑定肯定没有静态绑定块，因为还涉及到二次寻址操作，把一个地址从某个地方读出来。为什么测试结果不一样？究竟怎么测试才是最准确的。

其实 OOP 这块概念非常的多，正因为这样，OOP 现在被很多人批判，因为觉得把事情搞得太复杂。跟 OOP
诞生的大量设计模式，这些设计模式都会大量的运用接口来实现，形成一种抽象。因为接口实际上是从类型耦合拆解出来。当你依赖于接口的时候，你就不用依赖于某个具体的类型。

但如果你依赖某个类型，哪怕是抽象类型，那你也必须依赖于某条继承树。这样就造成 OOP
复杂度非常高，而且随着程序的维护这种复杂度越来越复杂，中间的耦合度越来越高。

现在语言里会大幅度简化 OOP 的概念，因为用其它方式来模拟 OOP
概念的话没必要搞成那么复杂。一来可以在编译器实现上可以做的更优化更简单；第二对于指令的优化可以做的很简单。OOP
对于我们日常编程来说，既方便又复杂，方便把一些数据抽象成个体。新的语言多半是为了解决一些老的语言的弊端。

在耦合中有两种关系，第一种是是什么（is），第二种是有什么（has）。第一种是知道你是谁，为什么调用代码是知道那个函数干什么的。第二种是你有什么符合我的条件，这种耦合关系不是强制性，任何一个你符合什么你有什么的。

对于第一种，主动调用就构成耦合关系。第二种是调用者必须知道被调用方有什么，被调用方就知道调用方需要什么，被调用方任何修改都会造成关联反映。

is 关系，是 a 依赖于 b 的个体或者家族。

