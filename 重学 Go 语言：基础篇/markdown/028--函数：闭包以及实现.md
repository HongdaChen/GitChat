### 何为闭包

一个匿名函数引用了它的上下文对象，我们把这种状态称之为闭包。

    
    
    func test(x int) func() {
        println("test.x :", &x)
    
        return func() {
            println("closure.x :", &x, x)
        }
    }
    
    func main() {
        f := test(100)
        f()
    }
    

和匿名函数关系最深的就是闭包，因为匿名函数可以当做返回值来传。

    
    
    func test() func() {
        x := 1 //局部变量
        fmt.Printf("%p: %v\n", &x, x) //输出地址
        //返回函数
        return func() {
            fmt.Printf("%p: %v\n", &x, x)
        }
    }
    
    func main() {
        f := test()
        f()
    }
    

调用 f()，test 栈帧已经失效，但可以打印 x 的值，这涉及到闭包是由两部分组成，匿名函数的指针加上环境变量的指针。很显然 x 必须逃逸到堆上才能在
f() 访问。因为堆上的对象和栈帧没有关系由 GC 来控制，这就会涉及到逃逸的问题。

    
    
    $ go build -gcflags "-m -l" main.go
    

### 闭包通过指针引用环境变量

闭包严格意义上来说，由两个东西组成的：函数加上环境变量，称之为闭包。闭包有这样一个问题，比如说有一个函数，函数内部有个环境变量
x，当它返回一个匿名函数的时候，这个函数是通过指针访问环境变量 x 的，并不是把环境变量 x 复制过去，用指针引用环境变量 x 实际上会造成这个局部变量 x
在堆上分配，生命周期延长。

以上面代码为例，test 函数访问之后 test 代码调用堆栈就结束了，结束了以后它的栈帧就失效了，这样再去引用变量 x
的时候肯定会有问题，不能引用地址空间已经无效的内容，所以会造成这个 x 从栈上逃逸到堆上。

### 闭包导致环境变量生命周期延长和堆分配

我们看下是否逃逸到堆上了：

    
    
    $ go build -gcflags "-N -l -m" -o test test.go
    
    
    
    ./test.go:6:12: func literal escapes to heap
    ./test.go:6:12: func literal escapes to heap
    ./test.go:7:33: &x escapes to heap
    ./test.go:3:22: moved to heap: x #我们可以看到 moved to heap:x
    ./test.go:4:25: test &x does not escape
    ./test.go:7:32: test.func1 &x does not escape
    

因为只有把 x 放到堆上时候，当我们去执行 f() 时候，对象才能在堆上找到。所以闭包会导致它所引用的环境变量生命周期延长。原来 test()
函数执行结束以后 x 的值就失效了，现在 test() 函数虽然执行结束了，但是 x 值依然存在，因为执行 f() 调用代码时候 x 不存在就出错了，所以
x 的生命周期必然延长，延长就必须从当前栈帧上逃逸到堆上，才有可能在调用时候依然有效的。

### 闭包与数据竞争

闭包可能引起数据竞争。闭包是通过指针引用环境变量，比如说一个函数有个 x，同时返回两个匿名函数，这两个匿名函数都引用 x 的情况下，它们都持有 x
的指针，当两个匿名函数都对 x 并发操作时，就会形成数据竞争效应，因为两个匿名函数用不同线程执行时，同时去访问 x
就会引起数据竞争。理论上我们需要对它加锁处理。

    
    
    func test(x int) (func(), func()) {
    
        // 尽管 x 不是指针，但闭包内部通过指针引用，所以
        // 也会导致数据竞争（data race）发生。
    
        w := func() {
                for {
                    x++
                }
            }
    
        r := func() {
               for {
                   _ = x
                }
            }
    
        return w, r
    }
    
    func main() {
        w, r := test(100)
    
        go w()
        go r()
    
        time.Sleep(time.Second * 10)
    }
    
    
    
    $ go run -race race.go #-race 参数用于数据竞争检查
    

闭包实际上是由两个东西组成的：第一个匿名函数，第二个环境变量，合起来才叫闭包。不同的语言对闭包的处理不太一样。

### 闭包实现

    
    
    //go:noinline
    //go:nosplit
    func test() func() {
        x := 100
        return func() { println(x) }
    }
    func main() {
        f := test()
        f()
    }
    
    
    
    $ go build -gcflags "-S" 2>a.txt
    

就是所谓的闭包效应，当一个匿名函数离开了它的出生地，它依然可以持有它所引用的环境变量，也就是说返回函数加上自由变量组合体称之为闭包。

定义变量 x 返回一个匿名函数，在匿名函数里打印 x。按照函数栈帧，完成函数调用 x 变量逃逸。

实际返回的是数据结构，有两个字段构成，第一个是匿名函数，第二个是 x。所谓的闭包实际上是，返回的匿名函数加上它所持有的环境变量组成的。

test 函数返回一个函数指针，它是个类型，类型是`type.noalg.struct {uintptr, int}`
结构体，在结构体里面有两个字段构成的。第一个存储一个指针，第二个是用来存储名字为 x 的整数，这个结构体通过 AX 赋值 SP，目的是为
runtime.newobject 函数准备参数，也就是说，先通过 runtime.newobject 在堆上分配了一块内存，这个内存是
type.noalg.struct 数据结构。

所以第一件事，在堆上创建数据结构，这个数据结构有两个字段组成的，接下来把匿名函数的地址填到第一个字段里面，把环境变量的值拷贝到第二个字段里面。这个结构体包含闭包执行需要的数据，所以匿名函数加上所需要的环境变量叫做闭包。

main 函数怎么执行这个匿名函数呢，首先通过 SP 拿到返回值，赋值给 DX，DX 赋值给局部变量 f，所以 f
严格意义上来说不是一个简单的函数，是闭包的第一个字段。DX 读出一个值放到 AX 内，接下来直接 `call AX` 相当于调用匿名函数，这个匿名函数通过
DX+8 取到第二个字段，就构成了一套的完整的闭包调用。

总结起来就是 test 函数实际上返回的两个数据，第一个是匿名函数的地址填到第一个字段里面去，x 的值赋值到第二个字段里面去，返回给 main
函数的实际上是结构体。然后通过了临时中转寄存器 DX 实现后面的调用，DX 存储返回值的引用，AX
引用第一个字段实现对匿名函数的调用，最后在匿名函数内部通过 DX+8 就可以取 x 的值，这就是闭包调用过程。

