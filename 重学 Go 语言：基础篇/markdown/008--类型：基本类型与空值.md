### 基本类型与空值

相比 C 语言，Go 语言有明确的基本类型。

C语言大多数类型不确定长度，int 类型固定是 32 位的，long 可能是 4 字节也可能是 8 字节，所以定义 long long 是 64
位整数。Go 语言里面类型定义非常明确，官方文档中有张表格。基本类型除了很明确的类型以外，其中比较特殊的有几个，其中 uintptr
用来存储地址的整数，rune 用来存储编码的码点，int32 有点类似 UCS-2 方式，但是不完全一样，毕竟不是对等关系。

### int 类型的宽度

int 类型在很多语言和当前的架构有关系。

例如下面例子，在 64 位平台和 32 位平台执行结果是不一样的。

    
    
    func main() {
        var x int
        println(unsafe.Sizeof(x))
    }
    

二次运行：

    
    
    $ go run main.go
    $ GOARCH=386 go run main.go #使用 GOARCH=386 指定 32 位运行
    

定义变量的时候推荐使用 int 类型，它比 int64 类型性能更好一点。因为 int 类型的宽度和寄存器的宽度相同，32 位平台寄存器宽度是 4
字节，64 位平台寄存器宽度是 8 字节。同时跟 L1、L2 缓存宽度也是一致的。某些场合编译器可以把 int 类型的变量直接放在寄存器中，在 32
位平台下使用 int64 类型则不能放到寄存器中。因为它的宽度比寄存器宽，编译器就没有办法对这个变量做优化。

### 不同进制的表示方法

在汇编层面上会大量习惯使用 16 进制，16 进制整数就是这个数字在内存中的布局，小端在前面。

    
    
    func main() {
        x := 0x123456 // 56 34 12 00 00 00 00 00
        p := (*[8]byte)(unsafe.Pointer(&x))
        fmt.Printf("%x\n", p[1]) //打印第 1 位输出 34
    }
    

例如 x 在内存中的布局是 `56 34 12 00 00 00 00 00`。p 指针类型转换字节数组，p[1] 取第一位输出 34。

打开文件的时候指定权限用 8 进制，因为 Linux 下权限管理就是用 8 进制表示的，通过不同的二进制位确定权限标记。

    
    
    os.OpenFile("./test.dat", os.O_RDWR, 0755) // 0=setuid bit 7=R4+W2+X1 5=R+X
    

代码可阅读性非常重要，基础类型有不同的表达方法，选择不同进制可以提高代码的可阅读性，对编译器没有影响。源码除了给编译器看，更多时候是给我们看的，哪怕很小的细节都要注意。

### 空值

除指针外，函数、接口、字典、切片、通道默认值为 nil。

  * 不是关键字，代表零值（zero），不仅仅是空引用。
  * 没有类型，不能作为简短赋值语句右值。
  * 即便同为 nil，不同类型也不能直接比较。（不同类型零值含义不同）
  * 值为 nil，不代表没有分配内存。

经常有 `var p *int = nil` 这种写法，nil 很容易误解成表示是空的、没有的、这个变量不存在的。

nil 严格意义上来说有两层含义。在抽象层面代表的是空值，如果是指针的话可能表示没有指向任何地址。在实现层面它代表的是零值。上面写法正确的理解是定义变量
p，它的类型是指针类型，默认情况下它会分配 8
字节，然后写为零值。至于怎么解读零值和具体的类型有关系，指针指向地址为零的区域是不允许访问的，指向它没有任何意义。所以 p
是分配内存的，不存在定义一个变量不分配内存这种说法。

    
    
    func main() {
        var a []int = nil
        println(unsafe.Sizeof(a)) // 24
    }
    

使用 GDB 查看内存内容。

    
    
    (gdb) x/3xg &a
    0xc00002e770: 0x0000000000000000 0x0000000000000000
    0xc00002e780: 0x0000000000000000
    

函数、接口、字典、切片、通道都可以用 nil 值表达。但是 nil 的长度未必等于
8，比如切片是一个结构体，它是由三个字段组成的，第一个字段是指针用来指向数组，第二个字段是长度、第三个字段是容量，长度是 24 字节。定义切片的时候分配
24 字节内存，如果等于 nil，只不过全部用零来填充 24 个字节而已。

`var a []int = nil` 实际上是分两个步骤完成的，首先定义变量，然后对这个变量进行赋值。即使不赋值为 nil，它本身也等于 nil，因为
Go 语言有责任让变量的内存被初始化为零。

那么输出的时候，所有的值都被填充为零。

另外 nil 不是一个关键字，可以当变量名用，简短定义不能出现在右边。它代表的是一种语法层面上的空值或者零值，本身是没有类型的。

    
    
    func main() {
        nil := 100
    }
    

## 空标识符

### 空标识符的本质

    
    
    //go:noinline
    //go:nosplit
    func test() (int, int) {
        return 1, 2
    }
    func main() {
        x := 100
        _ = x
        a, _ := test()
        println(a)
    }
    

空标识符是对编译器检查的一种“建议”。

空标识符可能是从 Python 语言里学的。Python 里面可以读，Go 语言只能丢。但是垃圾桶 `_`
什么类型都可以往里丢，如果它是一个固定的垃圾桶比如全局变量，各种各样类型都可以往里丢，怎么实现的？到底定义多长才算合理？Python
就是一个指针，Python 所有都是通过指针引用的，指针大小固定都是 8 字节。Go
语言值拷贝怎么丢进去呢？如果说只是丢弃，那么还能把它读出来丢弃就解释不通。Go 语言的确读不出来，难道仅仅是写给编译器的一种欺骗？

查看汇编：

    
    
    $ go build -gcflags "-N -l"
    $ go tool objdump -S -s "main\.main" test
    TEXT main.main(SB)
    func main() {
     x := 100
     0x44ea1d MOVQ $0x64, 0x10(SP)
     a, _ := test()
     0x44ea26 CALL main.test(SB)
     0x44ea2b MOVQ 0(SP), AX
     0x44ea2f MOVQ AX, 0x20(SP)
     0x44ea34 MOVQ AX, 0x18(SP)
     println(a)
    }
    

编译器会忽略空标识符赋值。

空标识符在官方文档定义是用来忽略某一个变量或者返回值，怎么解释忽略？

把一个变量 x 丢到里面去，然后又把 test() 函数一个返回值丢进去。反汇编观察 `_ = x` 失踪了，test()
函数有两个返回值但只处理一个返回值。从这一点上来说编译器会忽略空标识符赋值。编译器用空标识符检查特定的语法规则，而不是用来生成汇编指令的。它是用来检查在语义和语法上符合一定的规则，只是在生成机器代码的时候忽略。编译器可能在语法分析的时候用来做检查规则的匹配。

### 空标识符的其他用途

    
    
    type Xer interface {
        A()
    }
    type X int
    
    // func (x X) A() {}
    var _ Xer = X(0)
    
    
    
    $ go build -gcflags "-N -l"
    ./main.go:11:5: cannot use X(0) (type X) as type Xer in assignment:
     X does not implement Xer (missing A method)
    

编译器虽然不生成相关指令，但依然会检查。

空标识符除了用来忽略变量还可以完成一些检查的工作。比如 Go
语言没有显式的语法，定义接口并不知道一个类型是否实现了接口。编译器没有办法检查类型和接口有什么关系。

我们可以写成这样：`var _ Xer = X(0)` 用来检查，明确地把类型赋值给接口，让编译器替我们检查类型有没有实现这个接口。

