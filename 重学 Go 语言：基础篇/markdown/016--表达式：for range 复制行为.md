### for range 复制行为

复制要么复制指针，要么复制完整的对象，Go 语言影响最大的是数组。

    
    
    func rangeCopy() {
        x := [4]int{0x11, 0x22, 0x33, 0x44}
    
        for _, n := range x {
            // 遍历输出
            println(n)
        }
    
        for i, n := range x {
            // 遍历每次修改值
            x[0], x[1], x[2], x[3] = 0x100, 0x200, 0x300, 0x400
            fmt.Printf("%d: n=%#x, x[%d] = %#x\n", i, n, i, x[i])
        }
    
        for i, n := range x[:] {
            x[0], x[1], x[2], x[3] = 0x100, 0x200, 0x300, 0x400
            fmt.Printf("%d: n=%#x, x[%d] = %#x\n", i, n, i, x[i])
        }
    }
    

同样遍历数组，但是每次重新修改值，一般人会认为，既然修改了，每次遍历出来 x 的值应该是修改后的值。实际上不是。

我们遍历依然是原始的值，修改并没有影响遍历。所以 `range x` 实际上执行了一次 `range x.copy()`，所以 n 的值相当于是从每次
x.copy() 里面拿出来的，x[0] 修改的是原来 x 数组的值，这对复制过后的对象根本没有影响。

避免这样很简单的做法是传递引用对象进来，x[:] 切片每次复制的只是头部信息的拷贝，但是它里面的指针还是指向同一个数组，x[0]
修改是底层数组，这样一来就避免了这样的麻烦。

第一个值为什么没有修改？因为在修改之前，n 的值已经取出来了，它是发生在修改之前。所以影响后面的值，没有影响前面的值。

所以不管是函数调用还是执行，很多地方都会涉及到拷贝操作，需要注意拷贝的到底是什么，是头信息还是指针，到底影响哪些东西，整个拷贝到底复制了多少，任何时候都需要注意这一点。

### 观察 for range 复制行为

    
    
    func main() {
        data := [...]int{0x11, 0x22, 0x33}
        for i, d := range data {
            _, _ = i, d
        }
    }
    
    
    
    TEXT main.main(SB)
     main.go:4 MOVQ $0x11, 0x28(SP)
     main.go:4 MOVQ $0x22, 0x30(SP)
     main.go:4 MOVQ $0x33, 0x38(SP)
     main.go:5 MOVQ $0x11, 0x40(SP)
     main.go:5 MOVQ $0x22, 0x48(SP)
     main.go:5 MOVQ $0x33, 0x50(SP)
     main.go:5 MOVQ $0x0, 0x20(SP) #长度
     main.go:5 MOVQ $0x3, 0x18(SP) #循环迭代计数
     main.go:5 JMP 0x104df79
     main.go:5 MOVQ 0x18(SP), AX
     main.go:5 CMPQ AX, 0x20(SP)
    

第四行 `main.go:4` 是赋值语句，第五行 `main.go:5`
出现第二次的数据复制并提供了长度和循环迭代计数。很显然第五行处理数据是已经复制的数据，也就意味着对 data 其实修改的是复制之前的数据，在循环之前
range 把数据全部复制过了，接下来是从复制的数据中取数据，所以我们修改复制前的数据没有意义。

for range 默认会复制目标对象。如果目标是函数调用，仅执行一次。我们可能认为 for range 是连接到数据内部取数据，range
相当于接口进行迭代。

所以 range 首先会把数据复制一份，复制品和原始数据是没关系的。

### 利用 for(break) 实现代码块跳出

    
    
    func main() {
        x := 1
        println("a")
        println("b")
        if x <= 0 {
            println("c")
            println("d")
        }
        println("exit")
    }
    
    
    
    func main() {
        x := 1
        for {
            println("a")
            println("b")
            if x > 0 {
                break
            }
            println("c")
            println("d")
            break
        }
        println("exit")
    }
    

比如一种技巧性写法，和语言没关系，我们拿这个东西来做例子。

比如 ABCD 是一个完整的逻辑，但是 CD 需要有前置条件，我们通常会这样去写，这种写法逻辑没问题，但是不是很优雅。通常从缩进层次上来说，我们希望 AB
和 CD 保持同一个层次。因为 AB 和 CD 是放在一起的又不能把它重构成一个函数，它们相互是一种完整的逻辑关联，我们怎么改良这种代码的写法呢？

有个简单的做法，就是用一个条件来形成跳出效应。所谓的跳出效应就是阻止后面语句执行。表面上 if
语句是为了让它执行，其实恰恰相反，是要阻止它们执行。我重构成一个块，块影响作用域，没有办法形成跳出效应。

for 语句支持跳出，break 阻止后面执行。这样 AB 和 CD 就形成一套完整平行逻辑。实际上借助 for(break)
可以跳出块的功能，来改善逻辑层次上的一种关联。

我们可以用很多的技巧来改善我们代码的可阅读性，对于正常的一个初学者，上面的写法才是正常的，但是对于有追求的人来说，可能会出现下面写法。代码可阅读性实际上是对代码编写质量的一个很重要的评价手段，尤其是在团队合作当中代码写得是否干净实际上非常重要。

代码重构时候，任何一次缩进都会带来新的作用域，对于前后相关联的逻辑，如果在不同作用域，重构的时候就可能改变某些变量的生命周期，反而会带来一些负面影响。

相同层次保持在相同的缩进里面对重构来说非常重要。我们为什么会把一些逻辑重构拆成函数，函数有性能的影响但是还会拆开，因为我们不允许细节出现在框架里面，它会影响到代码的管理重构等问题。

### label 和 goto 的使用实例

性能要求好的代码会有大量的 goto
语句。某些时候我们需要写些高性能的算法，这个算法会很复杂，但是如果把它全部重构成函数调用的话，可能内部很多次循环会很多，内部开销会很大，不能把希望寄托给编译器，编译器能不能优化、能不能内联是编译器的事情，有些时候我们必须在源码层面上做出很多优化，goto
语句是很正常的操作。

goto 语句翻译很简单的汇编指令就是跳转。就相当于在 C 语言里面用内联汇编写代码一样。对于 Go 也一样，有些高性能的代码本身就很复杂。

### 用 goto 实现 inline block

    
    
    func gotoBlock(x int) {
    top:
        if x < 0 {
            goto err
        }
        //logic
        {
            x--
            if x > 0 {
                goto top
            }
        }
    
        {
            goto exit
        }
    err:
        {
            goto exit
        }
    exit:
        {
    
        }
    }
    

  1. 避免递归开销。因为 Go 不支持尾递归优化。
  2. label block 独立代码块，类似函数。用 goto 实现 call，避免函数调用开销。
  3. label block 相对独立，便于重构，同时避免闭包开销（逃逸）。
  4. 相对同一层次，可提升阅读性。

### label 使用实例

    
    
    func gotoLable() {
    outer:
        for x := 0; x < 5; x++ {
            for y := 0; y < 5; y++ {
                if x > 2 {
                    continue outer
                }
    
                if y > 2 {
                    break
                }
    
                fmt.Printf("%d:%d ", x, y)
            }
    
            fmt.Println()
        }
    }
    

两个循环情况下，如果跳出循环比较麻烦，我们知道 continue 和 break 是当前循环，在多层嵌套时候使用 label。

