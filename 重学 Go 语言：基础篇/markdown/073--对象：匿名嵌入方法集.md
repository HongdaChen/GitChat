### 匿名嵌入方法集

  * 嵌入 S，T += receiver S。
  * 嵌入 *S，T += receiver (S + *S)。
  * 嵌入 S 或 *S，*T += receiver (S + *S)。

匿名嵌入字段时基本规则大概这样。如果在一个类型里嵌入 S，那么 T 的方法集包含 S。如果嵌入 *S 那么包含全部。不管 S 还是 *S，以 *T
的方式获取方法集的时候包含全部。所以用指针方式获取方法集时等于全部，当用 T 方式获取时，分嵌入 S 还是 *S。不管一级还是两级都严格区分 T 和 *T。

### 匿名嵌入字段方法集

    
    
    type S int
    type X struct {
        S
    }
    
    func (S) A()  {}
    func (*S) B() {}
    func main() {
        var o X
        t := reflect.TypeOf(o)
        // t := reflect.TypeOf(&o)
        for i := 0; i < t.NumMethod(); i++ {
            fmt.Println(t.Method(i).Name)
        }
    }
    

S 有 A 和 B 两个方法，X 里嵌入 S 或者 *S。测试不同嵌入情况下的方法集有什么不同。

在很多语言接口不是实际意义上的概念，可能在运行期并不存在，Python 甚至没有接口这种概念，它称之为协议。在 Go
里接口是独立数据结构，所以导致通过接口调用方法的时候和它的内存布局有关系。了解方法集概念以后，第一个概念是一个类型能调用的方法和它对应的方法集不一样。第二个概念就是上面公式。

### 匿名嵌入对方法集的影响

当匿名嵌入一个对象的时候，编译器会帮我们自动生成间接代码调用，所以看上去拥有了对象的方法，实际上不是拥有而是编译器做了代码补全。这个语法糖实际上是代码补全，不是动态行为，而是静态行为。

    
    
    type N int
    
    type X struct {
        N
    }
    
    type Y struct {
        *N
    }
    
    func (n *N) Inc() {
        *n++
    }
    
    func (n N) String() string {
        return strconv.Itoa(int(n))
    }
    
    func listMethods(a interface{}) {
        t := reflect.TypeOf(a)
        fmt.Printf("\n--- %v ---------\n", t)
    
        for i := 0; i < t.NumMethod(); i++ {
            m := t.Method(i)
            fmt.Printf("%s: %v\n", m.Name, m.Type)
        }
    }
    
    func main() {
        var x X
        listMethods(x)
        listMethods(&x)
    
        var y Y
        listMethods(y)
        listMethods(&y)
    }
    

X 嵌入了 N，Y 嵌入了 *N。

    
    
    --- main.X ---------
    String: func(main.X) string
    
    --- *main.X ---------
    Inc: func(*main.X)
    String: func(*main.X) string
    
    --- main.Y ---------
    Inc: func(main.Y)
    String: func(main.Y) string
    
    --- *main.Y ---------
    Inc: func(*main.Y)
    String: func(*main.Y) string
    

我们注意到 X 只拥有 X 自身的方法，X 指针拥有 X 和 X 指针的方法。Y 因为嵌入了 X，只能获得对应值类型的方法，Y 指针拥有对应的指针类型。

接下来看看匿名嵌入的时候哪些东西是自动生成的，我们注意到这里面有很多自动生成的方法来实现方法集。

    
    
    $ go build -gcflags "-N -l" -o test embed.go
    $ nm test | grep "[^\.]main\."
    $ go tool objdump -s "main\." test | grep "TEXT.*autogenerated"
    $ nm test | grep "[^\.]main\."
    
    
    
    T main.init
    B main.initdone.
    T main.listMethods
    T main.main
    T main.(*N).Inc
    T main.(*N).String
    T main.N.String
    T main.(*X).Inc
    T main.(*X).String
    T main.X.String
    T main.(*Y).Inc
    T main.Y.Inc
    T main.(*Y).String
    T main.Y.String
    
    
    
    go tool objdump -s "main\." test | grep "TEXT.*autogenerated"
    
    
    
    TEXT main.init(SB) <autogenerated>
    TEXT main.(*N).String(SB) <autogenerated>
    TEXT main.(*X).Inc(SB) <autogenerated>
    TEXT main.(*X).String(SB) <autogenerated>
    TEXT main.X.String(SB) <autogenerated>
    TEXT main.(*Y).Inc(SB) <autogenerated>
    TEXT main.(*Y).String(SB) <autogenerated>
    TEXT main.Y.Inc(SB) <autogenerated>
    TEXT main.Y.String(SB) <autogenerated>
    

