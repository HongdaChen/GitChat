### 多变量赋值

    
    
    //go:noinline
    //go:nosplit
    func test() (int, int) {
        a, b := 1, 2
        a, b = b+1, a+2
        return a, b
    }
    func main() {
        a, b := test()
        println(a, b)
    }
    

多变量赋值涉及计算规则问题，很多语言对于多变量赋值其实是个坑。Go 语言的做法先计算右边的值，然后批量对左边进行赋值。

`a, b := 1, 2` 没有歧义，`a, b = b+1, a+2` 怎么计算呢？第一种解释先计算 b+1，把这个结果赋值给 a，那么 a =
3；然后计算 a+2，那么 a = 5 那 b = 5。第二种解释是什么？先把 b+1 和 a+2 计算出来再进行 a 和 b 的赋值 a 和 b 都等于
3。处理顺序到底是什么？我们需要用反汇编的方式来确认。

### 反汇编多变量赋值

    
    
    $ go build -gcflags "-N -l"
    $ go tool objdump -s "main\.test" test
     main.go:5 MOVQ $0x0, 0x30(SP) # ret1 = 0 30(SP)
     main.go:5 MOVQ $0x0, 0x38(SP) # ret2 = 0 38(SP)
     main.go:6 MOVQ $0x1, 0x8(SP)  # a = 1 8(SP)
     main.go:6 MOVQ $0x2, 0(SP)    # b = 2 0(SP)
     main.go:7 MOVQ $0x3, 0x18(SP) # tmp1 = 3 18(SP)
     main.go:7 MOVQ 0x8(SP), AX    # tmp2 = a + 2 10(SP)
     main.go:7 ADDQ $0x2, AX
     main.go:7 MOVQ AX, 0x10(SP)
     main.go:7 MOVQ 0x18(SP), AX   # a = tmp1
     main.go:7 MOVQ AX, 0x8(SP)
     main.go:7 MOVQ 0x10(SP), AX   # b = tmp2
     main.go:7 MOVQ AX, 0(SP)
     main.go:8 MOVQ 0x8(SP), AX    # ret1 = a
     main.go:8 MOVQ AX, 0x30(SP)
     main.go:8 MOVQ 0(SP), AX      # ret2 = b
     main.go:8 MOVQ AX, 0x38(SP)
    

`go build -gcflags "-N -l"` 中，-gcflags
给编译器传参数的，第一个参数不要对代码进行优化，因为我们需要知道它完整的处理过程；第二个参数不要内联，其实 `//go:noinline`
已经处理过不要内联了。

    
    
    go tool objdump -s "main\.test" test
    

反汇编看结果。这个函数的栈帧空间 28，按照 Go 语言函数调用规则还会使用 BP\IP。很显然 30 是第一个返回值，38
是第二个返回值，首先把两个返回值内存清零，确保是零值，如果函数调用失败，返回的是垃圾数据，所以把它重置为零值。接下来就比较简单，我们知道用反汇编 SP
加上偏移量来确定位置。

在当前栈帧指向 8，0 相当于处理 `a, b := 1, 2`，接下来指向 18 位置，临时用中间对象或者中间变量等于3，接下来把 08 即变量 a 放到
AX 里面，然后 AX+2 又写回到 10。现在产生了两个临时变量 18 和 10，实际上完成 `b+1, a+2` 计算，编辑器生成的指令很奇怪，a+2
用指令生成了一次，b+1 直接计算出来结果。正常来说临时变量二也可以像临时变量一一样直接计算出来，编译器优化还是有缺陷。接下来计算完以后，把临时变量一 18
通过 AX 间接地写到 08 赋值给 a，临时变量二 10 通过 AX 间接地写到 0 赋值给 b，最后拷贝到返回值里面。

我们可以根据反汇编实际上明确了先计算右边，然后依次对左边进行赋值。

### 未使用变量引发的错误

    
    
    var x int
    
    func main() {
        y := 1
    }
    
    
    
    $ go build
    ./main.go:6:2: y declared and not used
    

该规则仅针对局部变量。

定义一个变量，不使用它编译器会提示出错。但是这里有个坑需要注意，比如定义全局变量 x 和局部变量 y，编译器提示出错局部变量 y 没有使用，而全局变量 x
不提示。从设计上来讲，编译器可以把未使用的变量优化掉，很多编译器可以优化掉死代码的。所以 Go
语言很多设计有点莫名其妙，起码对于比较严谨的语言来说，编译器起码输出警告信息，因为输出信息分成两类，一种是错误，一种是警告。

### 动态修改字符串变量

    
    
    var BuildTime string
    
    func main() {
        println(BuildTime)
    }
    
    
    
    $ go build -ldflags "-X main.BuildTime=$(date +'%Y.%m.%d')"
    

  * 仅支持字符串
  * 可设置非导出成员

介绍一个小技巧，对于变量初始化都是在代码里实现的，初始化变量还可以在编译命令行上面。

比如说提供字符串类型变量，但是没有赋值默认的值是空字符串，可以通过命令行的方式用链接器传一个值。`$(date +'%Y.%m.%d')` 是 Shell
命令返回特定格式的当前时间，然后给链接器传参数 `-X` 用来修改特定字符串初始化值，字符串的全名是包和它的名字。

这个小技巧可以用来初始化版本号、编译时间、加密密码不能写在代码里的场景。但是有个限制只能针对字符串的格式，字符串是导出成员和非导出成员都可以，如果是其他类型可能通过字符串赋值以后做一些类型转换。

### 命名建议

合理而严谨的命名规则，有助于提升代码可阅读性和可维护性。

  * 全局变量建议使用完整且有明确含义的单词；
  * 局部变量建议使用短名和缩写，以便区分全局变量；
  * 不要使用保留关键字、内置函数，以及常用标准库成员名称；
  * 专有名词建议大写（escapeHTML）。

变量最关键的是变量的命名。变量的命名对于代码可阅读性是很重要的，我们最好就近访问变量，不要让变量的跨度特别长，如果跨度长最好给它稍微长的名字。命名习惯可能会导致可阅读性和可维护性的问题。

  * **可阅读性** 就是不会产生明显的歧义。歧义就是变量名不能确切地知道它的位置，就可能有问题。读代码的人不见得像你一样是功力深厚的人，可能产生歧义就不是一个好的方式。
  * **可维护性** 就是避免名称遮蔽，当进行重构的时候不应该有明显的依赖关系，这种依赖关系不应该因为代码挪的位置而造成破坏。

对于变量来说有几个简单的建议。

  * 第一，全局变量建议使用完整且有明确含义的单词。可能是两个单词组成的，一个单词比较通用可能会引起一些误解，需要用两个单词明确的表达，但是不要太长。
  * 第二，局部变量建议尽量使用短名和缩写，一个函数最好不要超过一个屏幕，用短名和缩写区分全局变量和局部变量避免歧义。

一般相对来说，全局变量是完整的单词甚至是多个单词组成的。对于局部变量但是跨度非常长的，最好给单个单词或者某个单词的缩写来表示。对于小的内部作用块，我们给一个字母，这会给大脑暗示作用域到底有多长，也便于我们更好的维护。变量命名符号的长度其实给自己一个暗示，还有避免对重构依赖性，对于变量命名是否定义新变量等，通过名字就知道干什么的。

我们在全局变量定义和局部变量定义语法大体差别是什么呢？全局变量，我们更希望给一个有意义的名称，比如计数器
counter。局部变量，给个简短名称便于阅读和维护，因为在代码中有大量长名称的话非常不方便阅读。

不要使用保留关键字、内置函数、常用的标准库成员名字。用成员名字会给别人造成误解，有些 IDE 环境也可能不能正确地定位到位置。

另外有些专有名词最好大写，写成小写会非常别扭，命名方式要遵循大家的阅读习惯。

    
    
    // comment ...
    var (
        counter int = 0x100
        data    string
    )
    

从编写习惯上来说，我们更希望把变量分组，比如有两个变量做同一个目的，它们需要配合使用把它们分成一组，给这一组提供注释说明。因为它们之间实际上存在一些逻辑关联，我们希望把一些相关的完成同一件事的变量进行分组。还有基于语法习惯，我们希望用分组方式来写，因为这样形成一个语法意义上的块，表示批量定义一批变量，阅读起来更方便。全局变量利用分组的概念形成不同的注释说明。

程序等于算法加数据，算法是通过修改数据的内容和样式来体现不同逻辑的结果，所以说对于变量的维护涉及到算法内部流程是否清晰、是否易阅读、是否好维护。

关于注释的问题，假如只是一行加注释通常会建议写在后边，对一整块做加注释建议写在前面。

### 原理：变量的本质

所有的变量都会被翻译成内存地址，因为符号名最终是没有任何意义的。所有的变量都是可寻址的，不管是全局变量还是局部变量最终是要求可寻址的，但是变量可以寻址并不代表一个计算中间结果可以寻址。

变量代表着一段或者多段存储内存。变量实际上就是一种内存，因为在很多高级语言里大家忽略对内存的这种概念。定义一个变量，这个变量存储数据，但数据究竟存在哪，我们知道存储器有很多种，存储器体系来说寄存器、L1、L2、L3
三级缓存、主存。虚拟内存里有部分数据可能会交换到磁盘上，还有硬盘上存储、网络上存储。

当声明一个变量的时候，变量存在哪里差别比较大。其实 CPU 默认情况下生成所有的指令只跟虚拟空间打交道，虚拟空间大部分情况下指的是主存。

每个程序中有 VA 地址空间，VA地址空间都是单独的地址，它通过 MMU 映射到物理内存上，比如一个变量 x
映射到某个位置。但是考虑这个位置的内存可能是复用的，例如恰巧这个内存可能是 ZeroValue
状态，或者因为缺页，正在使用的内存页交换到磁盘上去把这块内存空出来，然后交给 x
映射。操作系统并不保证物理内存被重新初始化过，也就意味着有种可能是，变量所指向的物理内存没有初始化过。所以内存必须是被初始化过才能使用，否则不能保证变量指向的目标是什么。

不同的语言对语法可能有些不同，我们遵循这种语法规则定义变量。对于编译器来说是不会在乎的，编译器翻译成某种中间语言，比如汇编。汇编最后怎么样去处理，这是汇编器的问题。

