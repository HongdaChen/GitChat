### 接口

接口（interface）代表一种“约定”或“协议”。允许在非显式关联的情况下，组合并调用其他类型的方法。

  * 接口是多个方法声明的集合。
  * 接口可解除依赖关系，屏蔽实现细节。
  * 只要方法集包含对应方法即为实现，无显式声明。
  * 类型可实现多个接口，以面向不同服务。

调用一个对象的成员有两种方式，第一种是直接调用，另外一种方式是通过接口间接调用。

接口代表一种行为上的约定或协议。接口是设计上的概念。接口本身是多个方法集合。接口好处解除依赖关系。技术细节不关心，符合实现方式可以。

方法集归根结底是为实现接口而准备的，接口到底是怎么样实现的？我们现在已经为接口调用准备好了对应的方法，接下来接口到底怎么样把一个普通的对象变成一个接口呢？或者说怎么样通过接口来调用真实的对象方法呢？

我们实现一个类型 X，X 有 a、b、c 三个方法，现在有个接口 I，要求必须要实现 a、b、c。这样的情况下就说 X 实现了 I 接口，接下来可以 I
等于 X 的实例，I 可以调用 a，这个最终会还原成 X.a 的调用。

我们想分析下“I 等于 X
的实例”怎么实现的？就是说接口怎么存储一个真实的对象，还想了解用接口调用一个方法的时候究竟是怎么实现的，就是说接口怎么找到真实的方法，怎么知道那个方法在哪？

这是接下来需要了解的：第一，接口怎么存储对象实例；二，通过接口调用和普通方法调用究竟什么区别。

很多语言里都会使用大量接口，接口到底是什么样的？我们说我们定义一个类型，声明字段方法。接口就是一个声明。

大部分语言对接口实现方式类似，动态语言没有明确接口一说，是按名字来寻址和按地址寻址不太一样，大多数静态语言对接口实现方式理论上非常相似。

### 接口和抽象类的区别

这句话代表两层意思，既然两个东西放在一起，它们肯定有很多相同的地方，在很多时候有相互替代场景。首先看它们相同的地方在哪里，然后再去找不同的地方，要求对抽象基类体系和接口体系有清晰的认识。

### 接口定义

    
    
    type Xer interface {
        A(a int) //签名包括方法名、参数和返回列表，不包括参数名。
        B()
    }
    type X int
    
    func (X) A(b int) {}
    func (*X) B()     {}
    
    var o X
    var _ Xer = &o //利用编译器检查接口实现。
    

  * 不能包含字段。
  * 方法只能声明，不能定义。
  * 可嵌入其他接口。
  * 通常以 er 作为命名后缀。

接口通常情况下用 er 的方式作为后缀，接下来定义方法签名。一个方法签名包括方法名，参数列表，参数列表不包含参数名字，只要类型和参数的数量，还有返回值。

类型 X 包含两个方法 A 和 B，但是接口和类型之间并没有说 X 一定实现了这个接口，这是 Go
语言很别扭的地方。怎么能保证一定实现接口，我们通过简单的方式来确保。比如有个 os
把它赋值给一个接口，变量名用的是下划线，也就是会被优化，但是编译器必须保证这个语法是对的，就是右值必须实现这个接口，这涉及方法集概念。利用编译器检查可以确保
X
必须实现这个接口。因为有时接口定义和类型定义可能不在一个文件里，甚至不在一个包里。以后扩展接口的时候怎么能保证代码逻辑是正确呢？用一些技巧来避免语言本身设计上的一些很奇怪事情。

接口约定一个协议，更多的是表达了一些技术参数，所以包含一系列的声明，但是不能有定义。不能有字段，因为字段会涉及内存分配。

### 编译器根据方法集判断接口实现

    
    
    type Xer interface {
        A(int)
        B()
    }
    type X int
    
    func (X) A(b int) {}
    func (*X) B()     {}
    func main() {
        var o X        // T
        var e Xer = &o // *T
        println(e)
    }
    

接口包含 A 和 B 然后去实现这个接口，接下来调用的时候先创建 o，直接把 o 赋值给 Xer 报错，缺少 B 因为 O 的方法集里面是没有
B，必须把改成 &o 拥有 A 和 B 这两个方法符合这个接口定义。所以使用接口的时候通过方法集处理，使用实例调用的时候是通过方法来调用的。

### 接口内部实现

    
    
    type iface struct {
        tab  *itab
        data unsafe.Pointer
    }
    type eface struct {
        _type *_type
        data  unsafe.Pointer
    }
    

接口实际上是由两个结构体定义的，iface 包含有方法的和 eface
没有方法的。接口实际上是一种在运行期分配的内存实例。当创建一个接口对象变量的时候，它存在着这样的一个变量，类型 T 有 A 和 B(*T)
分配给接口的时候，接口它本身是个数据结构由两个字段 tab 和 data 构成。首先创建一个拷贝，这会涉及到拷贝的过程，接下来把它的地址赋值给
data。Go 语言设计接口的时候，把拷贝的复制品设计成不可寻址的，因为它是内部的，并没有把这个结构公开，也就是它以后可能会发生改变。

T 情况：调用 A 的时候，拷贝一份实例；调用 B 的时候接收的是 *T，需要地址，但是不可寻址，显然这种用法不行违反安全协议了。*T
情况是把内存地址指针复制进来，这个指针指向原始实例。调用 A 的时候，直接通过这个指针找到原始的 T 复制一份放进来没有问题。调用 B
的时候直接把指针拷贝一份放进来也是合法的。

当 *T 放进来的时候都是合法的，这两个规则对应它的方法集。把 T 放进来，复制品是原始的完整对象是把这个对象拷贝。A 不可寻址没关系，所以 A 合法。B
要操作它的内存地址，但是这块内存是不可寻址的，所以 Go 语言规则很简单，内存地址不可寻址。当扔进来的是 T 复制品的时候，只有A是合法的，B
的内存模型不合法。当扔进来了是 *T 实际是一个指针，A 操作指针拷贝原始对象没有修改内存，A 是合法的。B 也一样拷贝内容。所以 T 可能对应 A 而
*T 对应 A 和 B，正好对应方法集的概念。

接口内部实现有个问题就在于，为了实现接口的这种内存模型，变相的搞出方法集这个概念。如果搞不清方法集的概念，使用接口就会出问题。

好的设计可能方法全部是 *T 没有 T，只有一种模型就简单了。最早可能没有必要有方法这种概念，按照函数来设计，T 和 *T
作为第一个参数，后来把函数转换成方法的时候也很正常，因为编译器自动处理。可能是接收一个复制品，接收一个指针也没问题，当这个概念继续设计接口时候和内存模型起冲突了，又搞出了方法集这种概念。一步一步推导到最后越搞越复杂，所以接口是在
Go 语言设计里缺乏一致性，接口的本来目的为了简化，用接口抹平 OOP 里多态和继承概念。但是 Go 语言搞出方法集的概念，其他语言不存在。

很显然，方法集的目的是为了适应接口的内存模型。因为它并不想把接口的内部实现对外公开。接口直接用，内部实现不公开，内存不能选址。就会导致两种情况，第一种把值拷贝进来。那么对
A 合法对 B 不合法，因为 B 要拿到这块内存地址作为第一个参数。把 *T
拷贝进来，这块内存是指针的复制品，没有操作它的内存地址操作的是它的内容是合法的。

做 OO 模型设计的时候，可能砍掉继承。用函数的方式来实现，接下来用语法糖的方式包装方法，通过方法再推导接口的时候和前面的设计缺乏连贯性。

所以一个语言的设计其实跟软件架构是一样的，必须有宏观的概念从大往细节设计。

    
    
    $ go build && go tool objdump -s "main\.main" test
    

接口调用会涉及到 itab 和 data，就是两个指针构成的。itab 里存的是一些原始类型信息。

    
    
    LEAQ go.itab.*main.X,main.Xer(SB),AX
    LEAQ 0x10(SP),AX
    

go/src/runtime/runtime2.go：

    
    
    (gdb) p e #变量
    $1 = {
     tab = 0x4784c0 <X,main.Xer>,
     data = 0xc00002e768
    }
    (gdb) p &o
    $2 = (main.X *) 0xc00002e768 #拷贝内存地址
    (gdb) p/x e.tab.fun[0] #对应的方法
    $8 = 0x44eb80
    (gdb) p/x e.tab.fun[1] #对应的方法
    $9 = 0x44ea90
    (gdb) info symbol 0x44eb80 #符号表查找对应方法名
    main.(*X).A in section .text
    (gdb) info symbol 0x44ea90 #符号表查找对应方法名
    main.(*X).B in section .text
    

