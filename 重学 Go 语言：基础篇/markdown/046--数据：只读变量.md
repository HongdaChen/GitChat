### 只读变量

切片主要是内存操作，除此之外和内存操作有关的内容。在 Go 语言里没有只读变量的概念，在有些语言有 readonly
就变成只读的了，这个功能很实用，不允许修改。

有些时候我们不允许修改一些很关键的安全信息，除了不允许修改以外，可能还不允许对方看到。任何一段内存其实有四种状态，可读、可写、不可见、可执行。

我们所谓的 readonly 变量，归根结底就是只读不允许写，很显然以现有的功能，我们是做不到这一点的。

一段虚拟地址空间，所有的变量、栈、堆、text 段其实都是映射到虚拟地址空间上面的，然后通过 MMU
映射到物理内存上面去。那么我们能不能自己在虚拟地址空间上面映射一段内存，就是在 GC
以外的空间映射一段内存，自己来控制这段内存的读写权限、读写执行。如果把写权限关掉就变成只读的了。

我们自己在虚拟地址空间上开辟一段内存，自己管理这段内存，控制它是读、写、执行。所以我们需要用到系统调用。在 Linux 系统编程中有 mmap
函数，就是在虚拟空间上映射一段内存，PROT_READ 读、PROT_WRITE 写。MAP_ANONYMOUS
匿名代表和文件不进行关联，就是在内存用用就可以了，例如可执行文件需要和内存某段映射起来。匿名的好处是没有文件开辟空间就可以了，另外 MAP_PRIVATE
代表私有的不跟别人共享。

Go 封装了一些系统调用：

> <https://golang.google.cn/pkg/syscall/>

这里我们可以看到很多系统调用，如果不全还可以通过[扩展包](https://godoc.org/golang.org/x/sys/unix)来找。这里面最全的是：

> <https://golang.google.cn/pkg/syscall/#Mmap>

首先我们需要开辟一段内存，开辟多大呢？我们说过，操作系统都是按照页来管理的，在我们申请内存的时候最好以页为单位，当然这可能会有浪费。管理内存权限是按照页分配权限的，不能按照一页里面一个片段来分配，申请完了之后可以转换为数组存不同的数据。

默认情况下 `syscall.PROT_READ|syscall.PROT_WRITE`
是可读写状态，`syscall.MAP_PRIVATE|syscall.MAP_ANON` 是私有和匿名的，拿回来返回的 m
实际上就是字节切片，有了字节切片我们可以把它转换成任何想用的类型，因为内存中所有东西都是字节，syscall.Munmap 调用是把内存释放掉。

    
    
    func main() {
        m, err := syscall.Mmap(-1, 0, syscall.Getpagesize(), syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_PRIVATE|syscall.MAP_ANON)
    
        if err != nil {
            log.Fatalln(err)
        }
    
        defer syscall.Munmap(m)
        //可以转换成任何方式来使用，比如转换成整数指针使用。
        p := (*int)(unsafe.Pointer(&m[0]))
        //赋值
        *p = 100
        fmt.Printf("%p: %v\n", p, *p)
    
        //修改内存的权限为只读
        syscall.Mprotect(m, syscall.PROT_READ)
        //读没有问题
        fmt.Printf("%p: %v\n", p, *p)
        //只读权限后，下面操作就会出错，系统引发的错误信号
        *p = 200
        fmt.Printf("%p: %v\n", p, *p)
    
        //把写权限加上去
        syscall.Mprotect(m, syscall.PROT_READ|syscall.PROT_WRITE)
    
        *p = 200
        fmt.Printf("%p: %v\n", p, *p)
    
        //修改内存的权限为不可见
        syscall.Mprotect(m, syscall.PROT_NONE)
        //操作就会出错，系统引发的错误信号
        fmt.Printf("%p: %v\n", p, *p)
    }
    

显然，我们除了语言本身提供的功能以外，我们还要适当地使用操作系统提供的一些功能，这个功能是超出语言本身的限制，多数语言都能支持这种系统调用。我们可以通过系统提供的功能做一些语言不具备的能力。

我们完全可以把一个函数的代码拷贝到这里，然后把指针转换为函数指针，然后就能执行这段函数代码，这样能做代码注入。有很多内存操作不见得非要限制于语言本身，利用读写和不可见其实可以做很多事情，比如有些时候，我们需要在内存中保护一些敏感数据，有个库用来验证用户的敏感信息，包含信用卡信息密码；这些信息从后台数据库读进来之后，理论上不想是给别人访问的，因为对方通过扫描内存实际上可以找到这样的数据。只有我想要访问的时候打开，不想访问的时候关闭，从一定程度上提高内存中敏感数据的安全。

还有可能需要 mlock 函数把一段内存锁定，当一段内存长时间不用的话会被 MMU
交换到磁盘上，把内存中的数据交换到磁盘上是非常危险的，当你的数据交换到硬盘上，突然机器挂了，敏感数据是保存在磁盘交换文件中的，这个时候，如果有人把磁盘拿走去扫描是能找出敏感数据的，因为磁盘交换文件是有格式的，只要了解这些格式就能把信息恢复出来。mlock
函数可以把某段内存锁定物理内存里，不允许 MMU 交换到磁盘空间。

### 手动内存分配和 sync.Pool 的性能差异

sync.Pool 利用了运行时内部机制提升了性能，大多数情况下足够用了，但是 sync.Pool
缺乏几个很关键的功能。接口只有两个方法：一个是取出来，一个是放进去。如果取的时候没有新的缓存对象，它就会调用 New
函数创建一个新的，除此之外没有任何的控制。这对于我们来说粒度有点粗，例如数据库的连接缓冲池，通常有这样几个开关，第一个最大打开的连接数，第二个最大空闲连接数。

第二点，所有方法都是用的接口类型，把一个对象转换成一个接口类型有一定的性能损耗的。标准库提供是一种通用对象池，并不能明确的说我要用什么样的对象数据，所以它用接口是非常合理的。对于我们来说，我们自己去写一个缓存结构，我们很明确的知道我们需要缓存什么样的数据，可能是某个结构体。同时必须严格控制必须打开多少个，最少的时候要保留多少个空闲在里面，我自己控制这段逻辑的时候，显然这个对象池其实就不够用。我们可能就需要数组实现一个。

还有个问题在于，它在内部实现时候它是基于同步机制，这个同步机制对于我们来说是个黑盒子我们没有办法控制。我们可能需要自己控制这些东西，因为我们的逻辑一次取 3
个，经常有这样的做法，比如 4 个并发的操作，每个操作一次取 3 个。大家做数据库操作通常这样，很多时候做批操作，比如插入 10
条记录用批操作的方式去提交，这样比单次提交速度快很多。同样的，对对象池操作一次取多个，那么对于它内部来说你每次取都进行一次加锁解锁操作，对于我们来说可能性能不行，我自己控制比较好。我一次取
3 个只要加一次锁，比加 3 次锁性能要高很多。

还有最后一个比较麻烦的问题，在垃圾回收的时候，我们根本没法控制缓存的对象会不会被回收。

比如我们要缓存 Data 数据结构，我们创建一个对象池
&sync.Pool，必须传递个函数目的是当对象池没有的时候必须给我个函数，用函数创建新的对象。在这个函数加了一个跟踪的方法，类似于析构函数，如果这个对象一旦被垃圾回收了，打印信息知道被垃圾回收了。从对象池取四个对象出来，很显然取的时候因为对象池是没有的，所以它创建新的四次，接下来把新创建的加到切片中去。然后立即释放还给对象池。最后执行垃圾回收。

    
    
    type Data struct {
        x int
    }
    
    func newData() interface{} {
        fmt.Println("new.")
    
        d := new(Data)
    
        runtime.SetFinalizer(d, func(*Data) {
            fmt.Println("finalizer.")
        })
        return d
    }
    
    func main() {
        pool := &sync.Pool{
            New: newData,
        }
    
        var datas []*Data
    
        for i := 0; i < 4; i++ {
            d := pool.Get().(*Data)
            println(d)
            datas = append(datas, d)
        }
    
        for _, d := range datas {
            pool.Put(d)
        }
    
        for {
            runtime.GC()
            time.Sleep(time.Second)
        }
    }
    

我们看到创建新的四个对象，一旦把它们还回对象池，垃圾回收就全部释放掉了，也就是说下一次需要重新创建。这样一来我们没有办法控制缓存池里面到底留下多少个对象，因为垃圾回收器会把所有空闲的对象全部干掉下次重新创建。为什么用缓冲池，其实有几个理由，一是对象频繁的使用，第二是创建对象要花费很大代价，比如创建数据库连接是要花费很大代价的。

我们可以基于 sync.Pool 做个包装，额外使用结构体引用它。sync.Pool
有几个问题：第一，类型转换，第二，没有办法做细节控制，第三，没有办法阻止会被垃圾回收。标准库里面做些简单事情可以，但是性能要求比较高的场合并不适合。我们尽可能使用标准库，一旦标准库满足不了需求的时候，我们就得自己去写，你就得控制所有的细节。

    
    
    type Pool struct{
        sync.Pool
        []idle //所有空闲对象使用这个引用确保不会被垃圾回收
        maxOpen
        maxIdle
    }
    
    // 可以控制一次取多少个出来，还避免了类型转换
    func Get(n int) []*Data {
    
    }
    

