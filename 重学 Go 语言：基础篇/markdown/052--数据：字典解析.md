### 字典

哈希表，称之为字典，是我们日常开发中使用频率非常高的类型，例如 Python
中最常见的复合结构就是链表和字典。其实在很多语言里，字典承担了更多的责任，甚至用来模拟整个对象，就是复合的对象实例，其实 Python
本身它的实例数据就是以字典方式来保存的，我们管这种东西叫做名字空间。

所以说字典这种数据类型使用频率非常的高，越来越多语言会把字典作为内置类型来实现，理由是可以各个方面进行调优。比如借助运行时编译器进行深层次的优化，让垃圾回收器对它做特别的照顾。

链表和字典现在大部分语言都会内置这两种类型，因为这两种类型使用机率非常的高，除此之外最常见的就是类，Go
语言中可能就是结构体。从语言角度设计思想可能不同，但是从实现角度差别不大。

键值对数据结构编程中出现的频率非常高，Go 语言哈希表的设计比较典型。实际上就是一个数组，把 key 分布到这个数组中，每个数组元素称之为桶。每一个 key
计算哈希分布到对应的桶上，桶是一个数组结构，数组结构是由三个连续的区块组成，连续存储 8 个 tophash、8 个 key、8 个 value。当 key
被哈希到桶上的时候就演变成小范围的数组操作。

相比较使用链表结构，数组结构是连续的，可以充分利用数组缓存的亲和性来提升性能。除此之外，专门设计的 tophash 第一个作用就是 key
找到在哪个桶，桶的数量是有限的，有很多不同的 key 放在同一个桶里面。

如果 key 是字符串直接去遍历效率很低，判断两个字符串数相等需要付出很大的代价，tophash 计算 key
的哈希值，把哈希值的高位存储到对应的索引号里，整数类型在 CPU 的指令匹配速度非常快。

这样无论 key 是什么类型，先用 tophash 预判一下。因为哈希值的高位不相同的话，没必要判断 key 是不是相等，只有 tophash
匹配通过才去判断 key 是否相等，所以 tophash 第一次预判来提高访问效率。

第二个作用通过 tophash
可以知道哪个地方是有空位。如果桶满了还需要往这个桶里放，则再申请新的桶挂到这个桶下面形成链表结构，在链表的基础之上提升局部节点的性能，局部节点变成小范围的数组便利效率会高很多。哈希表两种方式，要么是开放地址要么是链表。

日常编程使用字典多数情况都是非常小的字典，8 个以内的字典频率比较高。如果 8
个使用一个桶实现，直接把复杂的哈希结构直接变成小范围的数组操作达到很高的性能。

字典可以当数据表来用，key 相当于数据表里面的行号，value 相当于其他字段。所以说作为一种不需要预先定义的动态复合结构，字典的使用几率非常高。

但是字典的性能一直是非常关注的问题。我们知道在 Go 语言中，字典是由 runtime 层面进行优化，hashmap.go 基本上都是基于内核来设计的，因为
hash 表性能做的不好的话会有很大问题。

还有一点 hash 表在垃圾回收很容易出问题，所以说如何合理使用字典是一个很大的话题。Python 的核心是名字空间，Python
所有的名字空间都是由字典来实现的，所以字典的性能非常关键。

### 字典基本实现方式

首先什么叫哈希函数？其实哈希算法比较宽泛，有很多种不同的实现，它是把一段比较长的数据用一定的算法计算出类似一种摘要信息，这个摘要信息可能是很短的一个字节序列，也可能是个整数。比如早期常见的做法，像
CRC 类似于哈希做法，CRC 是通过一定的算法计算出所有字节数据的值得出一个整数，如果改变了这里面的某个值，那么 CRC
的结果就不一样，早期很多操作系统都会用 CRC 来校验数据判断文件是否完整的，后面还出现类似像 MD5，它通常会做类似签名防止输入被修改过。

字典其实有很多种不同的实现。最经典的两种开放地址法和链表法。像 Python 里面的字典就是用开放地址法，更多的实现是用链表法。

#### 开放地址法（Open Hashing）

首先任何一个 Key
通过哈希函数自己定义的算法得出一个结果，这个结果假设是个数字，这个数字对于某个固定长度进行取模，得出来的余数肯定是在这个固定长度范围之内。这是很简单的一种定位算法，就是我们可以把任何的数据通过哈希算法得到一个整数，这个整数可能会很大，然后我们把它想定位在有限空间内，很简单的做法对它进行取模操作。

那么我们为了存储 Key-Value 结构怎么做呢？

首先我们提供一个基本的存储信息，最常见的提供一个数组，上面任何一个 Key1
我们都可以定位到数组某个下标上面，具体怎么存，可能是个复合结构，可能是结构体。我们计算 KN 的时候，它得出来的哈希数不一样，但是取模以后可能会和 K1
是一样的，因为取模之后范围有限的有冲突，可能和 K1 定位的索引号是一样的，当它存储的时候发现已经有数据了。

开放地址法的做法是重新对 KN
进行计算，它会把哈希数增加一个变量进行调整，再取模的时候索引号可能发生变化，那么它找到下一个存储位置，如果下一个也被占用了，继续通过调整变量继续找合适的存储点。如果空间不够用的话，可能对这个数组做扩容处理。这种做法的核心是调整哈希算法，在哈希算法里面提供一个变量来实现。

这种方式的优点是，对于很小的字典具备很好的操作性能，因为数组内存是完整的一块内存，对于大部分日常开发时候小字典都很小，我们可以把这个数组用完了不释放，直接放在某个缓存里面去，下次直接拿出这整块内存进行复用，因为这块内存是完整的，这样的话在复用层面上来说会非常的方便，只要把上面的数据覆盖掉。

所以对于这种开放地址法来说小字典具有很好的操作性能。它没有很复杂的通过二级指针来寻址，它可以把内存进行复用。因为对于小字典来说，按照分布概率对于 10 个
KeyValue 键值对的，我们可以创建 20 个这种大小的数组，那么这种固定长度的数组可以缓存，所以在管理上来说，它的效率会很高。

这就是 Python 之所以使用开放地址法的原因。因为它们对大量的项目代码统计发现字典多数时候都是用很小的字典结构。当你频繁使用的时候，Python
里面对于内存管理的话性能不是特别好，那么它不惜一切代价把所有东西使用缓存，所以它把字典缓存起来是很合理的，因为 Python
里面使用字典的频率实在太高了，任何一个对象都会各种各样的使用大量的字典。

开放地址法有个很大的问题在于当超出容量限制的时候需要做扩容，需要对数据进行重新哈希处理。优点是访问性能很好，内存可以复用，缺点是扩容时候需要付出代价，所以它更适合不需要扩容的小字典。

#### 链表法（Closed Hashing）

链表法同样需要提供一个数组，当K1取模定位位置，可以直接存，如果 KN
也定位到同样位置，把它作为一个链表放在下面去，理论上只要有重复的就一个一个的往下面加。那么我们访问 KN
的时候，我们先找到那个位置，然后对这个链表进行遍历找到你其中对应的那个数据。这个看上去其实就相当于用一个数组管理 N
个链表，数组的目的就是管理分布式链表的数据结构。本来用一个链表就很长，现在把链表打断之后分成很多链表，这样确保每一个节点里面链表长度很小，那么对这个链表遍历的时候性能相对来说比较好一点。这就是很典型的链表法实现。

![enter image description here](https://images.gitbook.cn/8495f170-219e-11ea-
bb46-07e0f92c6feb)

链表法优点是数组不需要扩容，增加数据只需要往链表后面追加就行了。缺点是当我们找到位置的时候，需要对链表进行遍历，我们知道链表的时候性能不是特别好。第二个问题是所有的内存快比较零碎想复用的话并不容易，因为就算复用只能复用数组那块内存，下面所有节点都得
Free 掉，所以这种复用没有多大意义。还有个原因可能某个链表会很长，其它链表可能很短，不平衡，性能上会带来一定的问题，它的好处在于理论上它支持足够多的
KeyValue 数据，不需要做复制处理，因为链表本身每个节点都是独立分配内存的，但是它的访问性能会很差。

### 用数组改进链表法性能

假设我们有链表法的字典，我们对于它做性能优化应该怎么做？首先我们需要调整哈希算法，尽可能让它发布均匀，来实现每个链表的长度相对来说比较短。用数组提高访问性能，每个链表挂的节点可以替换成长度为
4 的数组，如果超出 4 个再申请 4 个，每 4 个为一组把它构成链表。

![enter image description
here](https://images.gitbook.cn/1b1e1d20-219a-11ea-8811-95226eac252d)

那么这地方就会带来几个好处，第一，内存块的数据变少了，第二，遍历数组比遍历链表快，第三，每个内存块长度固定，可缓存起来。用数组改进链表法性能，因为用数组来减少对链表节点，可以把原来多个节点打包成数组改善性能。

我们有很多种方法来改善性能，前提是得知道字典怎么实现的。我们通过什么样的方式进行提升呢？第一，减少内存分配，第二，尽可能复用内存块，第三，尽可能让它有缓存亲和性。用空间换时间是很正常的做法。

