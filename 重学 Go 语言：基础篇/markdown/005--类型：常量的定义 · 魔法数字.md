### 常量定义

    
    
    const x, s = 1, "abc"
    
    func main() {
        const a = 1
        {
            const a = "abc"
            println(a)
        }
        println(a)
    }
    

常量的定义跟变量差不多，我们可以进行类型推断，可以同时定义多个，可以在函数内部定义，也可以在包块内定义。

    
    
    const x int32 = 100
    const s uintptr = unsafe.Sizeof(0)
    const n int = len("abc")
    const (
        a int = 1 * int(unsafe.Sizeof("abc"))
        b
    )
    

  * 如指定常量类型，则左右类型必须一致。
  * 必要时，可进行类型转换。
  * 支持编译期能计算结果的表达式。
  * 在常量组中，如不指定类型和初始化值，则与上行表达式相同。

如果明确指定类型，左右值必须保持一致。

第二个常量定义的右边不见得是字面量，也可以是在编译时候可以计算出结果的表达式。

另外常量组，当你只写一个名字没有提供任何的类型和初始化值，它实际上把上面表达式复制下来，这时语法糖比较容易引起误解。

### 为什么使用常量

> 魔法数字，让代码具备更好的阅读性。

最常见的例子我们需要改善可阅读性和好维护。举个例子来说假如有个公式，计算一个尺寸，这个尺寸由多个尺寸组成的。

    
    
    func test() {
        x := 3.14159
    }
    
    func main() {
        //size = (dataSize + ptrSize + extSize) * percent * 3.14159
        size := (100 + 8 + 30) * 100 * 3.14159
    }
    

这种写法看上去没有任何问题，而且编译器会优化得很好，直接把这个数字计算出来。但是问题在于这段代码不太好维护，很显然需要写一个注释放在旁边，上面例子看上去还是非常简单的，如果再复杂点怎么办呢？

还有一个原因，比如在代码中出现一个预值会在很多地方出现，我们要改这个预值就需要改很多地方，这就会很麻烦。我们通常的做法是定义一个常量。

    
    
    const pi = 3.14159
    
    func test() {
        x := pi
    }
    
    func main() {
        const (
            dataSize = 100
            ptrSize  = 8
            extSize  = 30
            percent  = 100
        )
        size := (dataSize + ptrSize + extSize) * percent * pi
    }
    

常量有全局的，这样的好处就在于，我们在多个文本当中若想调整的话，只需要在定义常量的地方调整就行了。

常量也可以是局部的，使用常量替换掉以后可阅读性就会好很多，同时我们在编码当中强调的观点是 **把逻辑和数据分离**
。很显然常量是数据部分，数据部分即使不看，只看逻辑部分大概就知道这个公式想表达的是什么意思，因为从这些单词当中我们就能看出来这个公式想干嘛。但是如果换成一堆数字的话，这行代码的可阅读性就会差很多。所以写代码时候注意，有些编译期的数据我们最好把它分离掉。

我们常常把在代码中出现的数字或者字符串称之为魔法数字。

    
    
    func grow(size int) {
        size *= 2
    }
    

当然不是所有的魔法数字都要使用常量来定义，比如有些时候我们进行扩容，大部分扩容算法的扩容倍数是根据算法固定的，即 2
倍扩容，因为我们会对这个算法做详细的描述，包括我们为什么要扩容 2 倍，很多时候是基于统计来确定的。类似这种时候我们就没有必要把 2
换成一个常量，你看注释了解算法的时候，这个 2 本身就是有确切的含义的。

### 常量分组

阅读 malloc.go 源码，看到有些时候有些常量就是未定义好的。

常量将数据和逻辑分离掉，逻辑并不见得是一堆代码，一个公式同样也是一个逻辑。在函数式编程当中，所有的函数都可以看做成公式和表达式。

逻辑上有相关性的常量我们通常放到同一个组里面去，注释可以引用同一个组定义的常量。为了阅读方便最好放在一起在表示文法上我们可以看成同一个段落，这样的好处是写注释的时候可以针对一大段来写然后对它进行自然分段。

在我们看来，代码不同的块有一定的上下文含义的，写代码的时候不管是空行还是把代码组织到一块也好，还是排序缩进，这些最终目的是让我们代码阅读性更好。

任何时候代码块不要太长，太长不好维护，因为有些时候调整顺序也是很重要的。

大代码块里面分成很多小的代码块，小代码块相互之间是有关系的，用空行隔开同样便于我们阅读。就算在一个代码块中，内部隔开多个小的块，这样便于阅读。除了空行，同一组代码块进行对齐，适当的添加空格区分常量是有意义的。

### 默认表达式

还有一种类似位移的算法，比如分配空间，我们更习惯按照计算机思路来表达，因为计算机是按照二进制位表达。同样是魔法数字的表达，不同的方式可阅读性也会不一样，习惯于
`1<<10` 的写法代表1K，这个才是正常的计算机表达方式，很多源码中都使用这种方式。

    
    
    buf := make([]byte, 1<<20) //1MB
    

### 编译期表达式

常量未必是魔法数字，也可以看上去像是函数调用。

    
    
    func main() {
        const x = unsafe.Sizeof(0)
        println(x)
        const y = len([8]byte{})
        println(y)
    }
    

unsafe.Sizeof(0) 看上去像一次函数调用，我们说过函数调用是发生在程序运行期的。但是我们看到它并没有执行函数调用，而是把值计算出来了。首先 0
根据默认代表 int 类型，计算出 int 类型的长度，编译器本身就可以知道，编译器就可以推导出来。[8]byte{} 数组的长度是固定的，8
个元素，元素的类型是 1 个字节。

其实内联、参数编译器也做了动态的所谓运算优化，它实际上可以推导出值究竟多少。所以说常量未必是个数字或者字符串，还有可能是在某个编译期就能计算出来的结果。

    
    
    const ptrSize = unsafe.Sizeof(uintptr(0))
    //const ptrSize = 8
    

我们为什么要写成这样？在 64 平台下确定是 8，但是 32 位显然是错的。

    
    
    $ go run main.go
    $ GOARCH=386 go run main.go
    

很显然是因为可维护性比较好，可阅读性更强。

