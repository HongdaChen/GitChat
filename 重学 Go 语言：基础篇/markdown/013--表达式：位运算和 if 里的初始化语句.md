### 保留字

保留字是语法上的一些关键字。和内置函数不同，大部分语言使用保留字作为符号名可能会出问题，所以不允许在编码中使用保留字。Go 语言内置函数在 builtin
包中，它不需要导入包就可以直接使用，编译器会把它翻译成特殊的函数调用。一些语言允许定义和内置函数相同的函数，我们建议内置函数、内置类型、语法上的保留字不要使用，因为很容易引起误解。

### 运算符（Operators）

每种语言都会有特殊的运算符，有些运算符在其他语言里可能没有，系统语言里面有特殊的运算符，尤其是位移操作。另外运算符可能会涉及优先级问题，Go
语言优先级相对来说比较简单，也没有结合律一说。

#### 使用位运算实现 bit flag

运算符中最常见的是位运算符，做应用开发很少会使用二进制位操作，文件系统使用位运算设置权限。

一个字节是由八个二进制位组成，二进制位标记为 1
表示特定的状态，这样一个字节表示八种状态。很多时候适当使用二进制位操作有助于减少内存使用、提高性能，尤其对于系统级软件来说，任何时候的性能要求都是很苛刻的。我们经常看到布隆结构或者位图数据结构使用二进制位去重。

    
    
    // 定义好的权限
    const (
        read = 1 << iota //0001
        write            //0010
        exec             //0100
        setuid           //1000
    )
    
    func bitFlags() {
        var bits int64
    
        bits = bits | read | exec | setuid //用或操作设置权限
        // bits |= read //单个设置
        fmt.Printf("%08s, %t\n", strconv.FormatInt(bits, 2), bits&exec > 0)
    
        bits = bits ^ exec ^ setuid //取消用异或
        fmt.Printf("%08s, %t\n", strconv.FormatInt(bits, 2), bits&exec > 0)
    }
    
    
    
    00001101, true
    00000001, false
    

用 64 位整数保存二进制，因为寄存器本身就是 64 位的，如果想增加枚举值在后面加就行了，如果标记位设置二进制权限只要用或（`|`）操作，取消用异或
XOR（`^`）操作。

#### AND NOT 和 XOR 的区别

Go 语言有很特殊的位运算符：`AND NOT` 按位清除。下面一个例子首先设置 write 和 exec 权限，用两种方式移除 write 和
setuid 权限。结果有什么不同？

  * 异或（XOR：`^`）操作：反而设置 setuid 了
  * 按位清除（AND NOT：`&^`）操作：正确移除 write 和 setuid

    
    
    func xorAndnot() {
        var bits int64
    
        bits = bits | write | exec //设置读写权限
        fmt.Printf("%08s\n", strconv.FormatInt(bits, 2))
    
        a := bits ^ write ^ setuid //XOR 移除write和setuid，setuid反而加上去了
        fmt.Printf("%08s\n", strconv.FormatInt(a, 2))
    
        b := bits &^ (write | setuid) //AND NOT 移除write和setuid
        fmt.Printf("%08s\n", strconv.FormatInt(b, 2))
    }
    
    
    
    00000110
    00001100
    00000100
    

### 对齐函数

这个函数意思是给个数字 n 按照 a 对齐。例如 3 按照 4 对齐，输出4，5 按照 4 对齐是 8。

这个函数在对象复用、加密算法中使用。

    
    
    func round(n, a int) int {
        return (n + a - 1) &^ (a - 1)
    }
    

### 流控制

Go 语言的流程控制与其他语言对比算是很少了。

#### if 里的初始化语句

    
    
    //go:noinline
    func count() int {
        return 3
    }
    func main() {
        if x := count(); x > 0 { // x := count(); if ...
            println("a")
        }
        // println(x) // undefined: x
    }
    

除变量作用域（整个 if...else...）外，和普通调用并无区别。

流控制语句基本上是选择、循环。Go
语言有个很特殊的写法，在流控制语句里面提供初始化语句，这个初始化表达式用于执行一个函数，也可以创建一个块变量。其他语言里可以在 for 循环定义变量。

那我们来看一下 if 初始化函数和普通函数到底特殊在哪。对上面代码进行反汇编，可以看到首先调用 count() 函数，接下来做一次比较操作 `CMPQ
$0x0,0(SP)`，判断它是否大于零，`JG 53` 大于就跳转执行 printlock
函数，不跳转的话结束当前函数。对比两种写法汇编指令几乎一模一样，从性能上来说没有差别。

写法上唯一的差别是 x 的作用域，x 的作用域在整个 if 语句的 block 块里面，在外面没有办法访问
x，这属于编译器做语法检查的时候出现的问题，和生成指令没有关系。所以两种写法区别在作用域上面，而不是带来一些性能上的提升。

所以 if 初始化函数和普通函数，从某种意义上来说，其实也算是一种语法糖。

    
    
    func intIF(x int) {
        println(x)
        if x > 0 {
            x += 200
        }
        println(x)
    }
    
    
    
    func intIF(x int) {
        if println(x); x > 0 {
            x += 200
        }
        println(x)
    }
    

if 支持初始化表达式，这个表达式用来执行一个函数或者创建一个块变量。

上面两种写法从编译效果看没有区别。从源码上代表两个分块关系。第一种是很明确的执行判断，第二种是为了执行判断准备的基本条件。

#### 减少缩进层次

    
    
    func main() {
        x := 10
        if err := check(x); err == nil {
            x++
            println(x)
        } else {
            log.Fatalln(err)
        }
    }
    
    
    
    func main() {
        x := 10
        if err := check(x); err != nil {
            log.Fatalln(err)
        }
        x++
        println(x)
    }
    

在上面示例中，if
块承担了两套完全不同的逻辑：错误处理和后续正常业务逻辑，这两个逻辑根本没有任何关系。基于重构原则，我们应该保持代码块功能的单一性，任何时候一个函数或者代码块最好只做一件事情。在正常阅读模式下，我们更关心正常逻辑怎么执行，对于错误处理我们可忽略它。

常见下面的例子：

    
    
    func main() {
        f, err := os.Open("./test.dat")
        if err == nil {
            fmt.Println("OK")
        } else {
            log.Fatalln(err)
        }
    }
    

推荐做法是这样的，if 块只是处理错误，后面表达的是正确的逻辑。这样的话阅读源码时候可以直接忽略掉，因为错误处理对于业务逻辑来说没有关系的。

    
    
    func main() {
        f, err := os.Open("./test.dat")
        if err != nil {
            log.Fatalln(err)
            return
        }
        fmt.Println("OK")
    }
    

上面是最常见的写法：检查结果返回错误或者对参数或者一些条件做前置检查。实际上分成两种逻辑。第一个称之为正常逻辑，正常执行属于一块。第二种是逻辑是出错的时候，它们实际上是完全分开的。

因为在阅读代码的时候，会下意识地把出错忽略掉。出错并不属于阅读的内容，出错只是一种例外。代码的可阅读性和写法是有很大关系的。

当函数里面出现缩进层次或者嵌套层次的，比如多级 for 循环嵌套或者多级 if 语句嵌套，或者说 if
语句同时承担两套逻辑的时候，那就需要重构。每部分只负责一个单一的事情，不应该承担两个或者是两个以上的责任，主干和细节分清楚。

#### 避免条件表达式过长

有些时候条件表达式非常复杂，不方便阅读，条件很难测试。因为这个条件可能会依赖前面的一些变量，最好的方式把非常复杂的表达式写成独立的函数，给个很友善的名字，这样的话专门针对这个函数测试这个条件。因为我们很多时候并不关心函数细节是什么，阅读代码时候非常干净，看流程不用关心细节，使用框架把流程和细节分离，是编写代码常见的做法。

我们阅读代码的习惯是先看流程再看细节，因为细节和流程没有关系。细节只依赖于输入的参数，至于细节代码放在哪里并不关心。同样地，对于流程来说，只关心调用了哪些模块，至于模块内部做什么不关心，只关心通过符号名称知道模块干什么用的。

比如用来检查条件、创建数据库，至于怎么创建、创建什么数据库不关心。所以编写代码时候流程和细节分离，一旦发觉代码某些细节影响阅读，尽可能重构出去。一来便于测试，二来不干扰阅读。

【支付宝红包口令：98142435】

