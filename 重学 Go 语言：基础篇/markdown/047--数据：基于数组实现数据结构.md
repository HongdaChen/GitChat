很显然数组带来很大的好处，直接的好处有几点：

  * 第一，它是一块完整的连续的内存而且只需要一次性分配
  * 第二，数组本身访问效率很高
  * 第三，我们可以对数组进行复制，因为数组只有一块内存，我只要把这一块的内存完整复制就可以了，而其他的很多复合结构可能有多块内存组成的，我们想复制的时候并不容易。

比如切片还好点只有两块内存，像链表可能有很多块内存，我们想复制一个链表的时候，就得遍历了一块一块复制，所以数组先天具备了性能上的优势。我们承认数组在操作上的确有很多麻烦，但数组的性能不能忽略。

接下来我们看，能不能用数组实现常用的数据结构。第一，我们使用数组带来的性能优势，第二，把数组转换为另外的访问方式带来操作上的便利性。把这两者结合起来，因为直接操作数组，很多时候比较麻烦，像插入、删除这些操作不是很方便。所以我们接下来把数组和其他数组结构访问上的便利性结合起来。

### 栈（Stack）

栈是很典型的先进后出（FILO）数据结构。其实我们在前面接触很多的栈，调用堆栈本身就是一个栈结构，它是一个内存空间，地址从高位到低位分配。

首先高位记录一个位置，比如使用 BP 寄存器保存，另外一个位置用 SP 寄存器来处理当前栈顶的位置。加一个数据即 Push 操作 SP
往上减，弹出一个数据即 Pop 操作 SP 往下增。很显然用一个数组加两个字段来模拟 SP、BP 就可以了。

我们怎么样去做呢？最简单的做法就是，第一种方式，使用一个结构体，指针属性指向一个数组，数组天生就包含了起始位置 BP 和容量
cap；或者这个数组直接内联，然后 SP 属性记录栈顶的位置就可以实现简单栈的管理。

还有个简单的方式，使用一个数组，把位置一当作 BP 寄存器使用，假如我们需要分配四个元素项的栈，那么实际分配就是 4+1，把索引 0 当作 BP
来用，以后就是操作数组后面的空间。这样的方式与结构体类似，因为结构体本身内存也是连续的，一块是数组，一块是 BP，本质上是一回事。

当然也可以用数组方式做，只需要有个地方记录一下 BP 的值，所以整个栈结构实现起来非常简单。

s 是一个动态的内存，所以我们用切片的方式去创建，切片看上去和数组是一样的，我们的目的是获得一个动态数组。我们把容量 +1，用 0 来当作 BP
寄存器来用。

  * 首先初始化的时候，0 指向栈底的位置，然后往里加数据的时候 BP 往上移，所以 BP 初始化的时候指向最后一个位置。
  * 接下来往里面加数据，读取 BP 寄存器的值，如果这时候 SP 指向 0 的位置栈已经满了，先判断栈是否已经满了，满了的话返回一个错误，如果不满的话直接把数据写进去；同时往里压数据的时候，每压一个数据，BP 寄存器往上移一次，表示下次可以往新的地方写。
  * 弹出数据的时候，BP 寄存器记录的是最后一次可写的位置，可写和可读的数据中间应该差一个，首先加上 1 调整 BP 寄存器位置，如果这个位置指向最低表示没有数据了，表示为空，如果有数据就返回，同时调整 BP 寄存器，因为我们知道弹出数据的时候，SP 往下做加法，压数据的时候，SP 往上做减法。
  * 整个操作很简单也就是 4~5 行核心代码。

如果不用数组用链表实现队列和栈最简单的，但是链表在内存管理上有很大的缺陷。

    
    
    type Stack []int
    
    var (
        ErrStackFull  = errors.New("stack full")
        ErrStackEmpty = errors.New("stack empty")
    )
    
    func NewStack(cap int) Stack {
        s := make([]int, cap+1)
        s[0] = cap
        return s
    }
    
    func (s Stack) Push(v int) error {
        i := s[0]
        if i == 0 {
            return ErrStackFull
        }
    
        s[i] = v
        s[0] = i - 1
    
        return nil
    }
    
    func (s Stack) Pop() (int, error) {
        i := s[0] + 1
        if i == cap(s) {
            return 0, ErrStackEmpty
        }
    
        v := s[i]
        s[0] = i
    
        return v, nil
    }
    

### 队列（Queue）

队列是很典型的先进先出（FIFO）数据结构。队列如果是一个数组结构，我们从左往右加数据，实际上有两个属性需要注意的，第一个是写 W 的位置，第二个是读 R
的位置。

比如我们可以连续写 3 个格子，写的位置就到位置 4，读的位置还是停留在位置 1，所以读和写的位置是不一样的。这地方就有个问题，我们怎么维护读和写的位置？

比如说写满了以后就不能写了，我们通常会实现一个“环状队列”：比如写满了，接下来读操作，读到位置 3，那么 1~2 空间就重新可用了，写的位置就会调整到位置
1。这就有个麻烦，W 可能大于 R，W 也可能小于 R，我们怎么处理这个呢？

记录当前元素数量记录 W 和 R 的位置，因为 W 和 R 默认都为 0，当往里面写的时候数量会递增，当数量等于容量的时候表示满了，假如数据数量是
2，在位置 2 和位置 3，W 写的时候写在位置 4，写满了，这时候数据数据不等于容量。怎么知道 W 需要回头呢？所以 W 和 R
除了要和数据数量比较，还需要和容量即最后一个索引号比较。如果等于最大的索引号，W 就需要回头。

  * 第一个背景，假设有这样的一个容器，4 个格子，我们有个指针一直做加法，那么到一定程度就超出了容器的限制，不管这个指针超出多大，指针与容量取模操作结果值肯定是在容量范围之内，任何一个数字除以一个固定容量，余数肯定会在这个范围内。
  * 第二个背景，队列 R 和 W 最大的麻烦是队列有长度限制，因为有长度限制，所以 R 和 W 有回头操作，假如长度没有限制无限长，那么 W 永远大于等于 R，W 减去 R 肯定是当前数据长度。这样的话，队列长度无限的，判断逻辑就非常简单。

我们把第一个背景和第二个背景组合到一起，如果变成一个环，假如这个队列是环状的，这个环是无限大小的，那么 R 到 W
区域就是有数据的。问题是在真实情况下，我们的队列肯定是有限制的，我们用抽象大小的环来处理 R 和 W 的值。第一个用抽象处理 R 和 W，避免 R 和 W
回头操作；第二个在数据读写的时候，去做取模操作，因为取模操作可以映射到真实的容量具体位置上。

那么接下来需要判断事就很简单，要么写满了，要么是空的没数据。

    
    
    type RingQueue struct {
        data []int
        head int
        tail int
    }
    
    var (
        ErrQueueFull  = errors.New("queue full")
        ErrQueueEmpty = errors.New("queue empty")
    )
    
    func NewRingQueue(cap int) *RingQueue {
        return &RingQueue{
            data: make([]int, cap),
        }
    }
    
    func (q *RingQueue) Push(x int) error {
        if (cap(q.data) - (q.tail - q.head)) == 0 {
            return ErrQueueFull
        }
    
        n := q.tail % cap(q.data)
        q.data[n] = x
    
        q.tail++
        return nil
    }
    
    func (q *RingQueue) Pop() (int, error) {
        if q.tail == q.head {
            return 0, ErrQueueEmpty
        }
    
        n := q.head % cap(q.data)
        x := q.data[n]
    
        q.head++
        return x, nil
    }
    

这是很简单的数据结构，一个数组，一个读一个写，写的位置作为头 head，读的位置作为尾 tail。头和尾之间的区域就是有数据的区域。往里面写 Push
的时候，先判断当前是否有真实的地方有空位，假如无限大小的，tail 减去 head 是有数据的区域，总长度减去有数据的长度就是空位长度，所以
`cap(data) - (tail - head)` 就是是否有空位。

tail 和 head 一直累加和总长度没有关系，首先判断是否有空位，如果空位等于 0
就表示已经满了，直接返回一个错误。如果没有满，把尾部的信息取模操作，就是把抽象的环映射到真实的数据结构上面。接下来在真实位置写，然后把抽象环上的 tail
值累加。

读操作其实也是一样的，所以说这地方只有两个概念构成，抽象大小的环处理 tail 和 head
的位置，这两个位置只是要判断有数据的长度或者是空位的长度，有数据的长度大于零代表有数据，空位的长度大于零代表有写的位置。对应映射固定长度的队列，有数据队列上肯定有数据的，有空位队列上肯定有空位的。

这样一来我们就不需要处理 tail 和 head
前后的问题了，把这个逻辑变得很简单。有些时候我们需要用抽象的概念去处理复杂的逻辑，就是把复杂的逻辑抽象化，我们借助抽象的概念来处理简单的索引位置，这是一个很典型的环状设计。

    
    
    func main() {
        s := NewRingQueue(3)
    
        fmt.Println(s.Push(1), s)
        fmt.Println(s.Push(2), s)
        fmt.Println(s.Push(3), s)
        fmt.Println(s.Push(4), s)
    
        fmt.Println(s.Pop())
        fmt.Println(s.Pop())
        fmt.Println(s.Pop())
        fmt.Println(s.Pop())
    
        fmt.Println(s.Push(4), s)
        fmt.Println(s.Push(5), s)
        fmt.Println(s.Pop())
    }
    

### 缓冲区（Pool）

缓冲区的特征是对象复用缓存，假设用一个数组实现缓存，所谓缓存无非就是重复使用这几个格子，对象可能是事先创建好的，也可能是事先创建好的连接。我们无非就是要取出下一个可用的。

最简单的方式，我只需要有一个头，头默认情况下首先把数组串起来，这样首先在第一种状态时取出可用的状态，当我们第一个取出来以后，头就变成
1，这地方记录的是数组的序号。同样地用完放回去以后，Value 先指向头指向的对象，就把新放进来的对象放到了头部，接下来把头指向
Value，每次返回的对象放到头就可以了。

头指向第一个可用元素，当我们去拿数据的时候只需要把头的第一个节点取出来就可以了，然后这个头就指向下一个节点。返回数据的时候，首先把原来那个链表挂在你返回对象的上面，这样这个对象就加入到链表里面了，变成了这个链表的第一个节点，然后把这个头信息指向你自己，链表就被合并了。

### 链表（Linked List）

单向链表和双向链表，每个节点 Node 都是一个单独的内存，我们遍历的时候需要做多次寻址操作。比如读数据的时候，先读那个地址，再根据地址读取数据。

还有个问题，它的内存是零散的，不利于缓存，假如我们需要遍历，因为它们的地址空间是分散的，所以缓存的命中率就会很低。我们知道 CPU
默认情况下是缓存连续的内存，访问效率就会很高。

还有另外一个问题，假如我们要复制整个链表的话，遍历所有的节点 Node，每个节点 Node 进行复制，还需要修改里面的指针。如果复制的话，先复制节点
Node，复制完节点 Node 的地址和原来的地址肯定不一样的，复制下个节点 Node 时候，P
的指针需要重新修改到新的地址，所以复制操作本身变得很复杂，整体链表的性能并不是特别好。我们可以很方便地往里面添加或者删除，因为只需要调整里面的指针就可以了，但是它本身的性能并不是特别好。

**那我们既想有链表的方便，同时又想有很高的性能怎么做？**

用数组实现的前提，首先需要预分配足够大的空间，因为在性能优化上面，用空间换时间是一种很常见的策略。比如想很多内存分配软件都会用空间换时间，提前去分配足够的空间。

假如用一个数组，首先额外分配一段空间，这个空间干嘛呢？存个 Head 指向第一个节点，再保留一个可写区域 W，可写区域指向空位，这个空位本来是存储
Value
的，但是现在没数据，没数据可以把这个空间转换为指针来用，因为整数和指针的长度是相等的，只要这个空间大于或者等于指针，把它指向下一块的空白内存，本身就串起链表了。这样就节省了指针的空间。

这带给我们内存复用的思路。同块内存在不用的情况下，我完全可以用来干别的，只不过转换一种类型就可以了。这样一来首先把空白区域串起来了。

**有数据的区域呢？** 假如这东西不是一个链表，只是个缓冲区 Pool，Pool
本身关心的是空位，没有使用的区域，因为使用的区域都已经弹出不用关心了，所以这种结构对于 Pool 结构就够用了。

**那么对于链表呢？** 链表有两块区域，下一个可写的位置实际上用 W 来处理的，现在怎么把读的数据串起来呢？也就是说必须要有个管理机制，因为原始结构的
Next 指针就是管理机制。

