在上一个主题中，我们从组件设计原则出发讨论了“为什么这个框架的代码结构要这么设计？”这一问题。该问题的提出背景在于很多同学在学习开源框架的源码时通常都会陷入代码的细节而无法把握代码的整体结构。今天，我们同样围绕“框架和结构”这一主题，从另一个角度出发讨论如何把握框架整体结构，即基于架构演进过程分析代码结构。

### 如何从易到难对框架进行逐步拆解？

我们再来回顾一下上一篇文章中讲到的 Dubbo 框架，我们知道 Dubbo 源代码包含了
common、remoting、rpc、cluster、registry、monitor、config 和 container
等八大核心包结构，这些包基于稳定抽象、稳定依赖等组件设计原则进行设计。从组件设计上讲，我们看到的是一个成熟、稳定且符合设计原则的 Dubbo 框架，但我相信
Dubbo 的开发人员也不是一开始就把 Dubbo
设计成现在这个代码结构。换个角度，如果现在我们自己来设计这样一个框架，我们通常会采用一定的策略来一步一步从简单到复杂、从核心功能到辅助机制逐步实现和完善框架，这也是软件开发的一个基本规律。针对这个角度，当我们想要解读
Dubbo 这样的框架而又觉得无从下手时，可以考虑如下所示的一个核心问题：

**_如何从易到难对框架进行逐步拆解？_**

Dubbo 是一个典型的 RPC 框架，关于 Dubbo 中 RPC
的实现方式，我们在后续的文章中会有详细介绍，这里不做展开。在此之前，我们可以大致来想象一下设计和实现一个 RPC 的基本思路和步骤，见下图。

![05.01](https://images.gitbook.cn/2020-05-25-052743.png)

在上图中，我们看到首先势必需要实现一个最基础的 RPC 组件，用来完成一对一的服务提供者和消费者之间的远程访问。

有了 RPC
基础组件之后，我们就能够实现远程通信了，但采用的是代码中嵌入远程服务信息的网络通信手段。这种做法比较直接，但对于一个服务框架而言显然是不利于系统开发和集成的，这时候我们就希望通过一定的手段来使远程调用本地化，即实现透明化远程调用。目前实现这一目标的主流做法就是代理（Proxy）机制。

现在服务访问已经非常简单了，但还只是一个一对一的模式，需要添加集群访问模式。集群能够为我们提供负载均衡、集群容错等机制。

最后，如果 RPC
中的服务提供者和消费者的数量逐渐增多，那么就需要添加服务治理机制，实现服务的自动发现和注册。同时，为了监控系统中服务的状态，一般还需要添加一定的服务监控措施。

### Dubbo 中的架构演进过程

Dubbo 作为一个优秀的 RPC 框架，在设计整个代码结构中也基本采用了以上思路。同时，Dubbo 也充分体现了功能演进思想，下图展示的就是 Dubbo
代码结构的逐步演进过程：

![05.02](https://images.gitbook.cn/2020-05-25-052745.png)

显然，以上代码结构体现了从简单到复杂、从核心功能到辅助机制逐步实现和完善的设计过程。

  1. 首先 Protocol 是核心层，构成 RPC 基础组件，如果不需要达到透明化调用效果，使用 Protocol 层就可以实现低层次的远程方法调用；
  2. 在 Protocol 基础之上，添加 Proxy 封装透明化动态代理，这样调用远程方法就如同调用本地方法；
  3. 透明化调用实现之后，就需要考虑负载均衡和集群容错机制，Cluster 层承载了这方面的功能；
  4. 在现有各种序列化工具的基础上，为了提升网络传输性能和扩展功能，Remoting 层实现了自定义 Dubbo 协议作为整个框架的一大扩展点；
  5. Registry 和 Monitor 分别提供服务路由、治理和监控相关辅助功能。

在本节后续内容中，我们将围绕上图中的五个阶段来对 Dubbo 的代码结构进行梳理，帮忙读者能从宏观上把握
Dubbo。请注意，我们现在在讨论的还是代码结构，不会也不应该对每个组件的内部结构和实现方法做过多展开，大家也需要从宏观上来学习后续的内容，避免陷入细节。事实上，这些组件的实现方法和细节在我们后面的课程中结合
Dubbo 框架都会有详细阐述。

### Protocol：RPC 基础组件

Protocol 作为 Dubbo 中最基本的 RPC 组件，完成了服务的发布和调用功能。Protocol 接口定义如下，为了先从结构上对 Protocol
有基本了解和把握，这里去掉了相关的@SPI("dubbo")和@Adaptive 等核心注解。这些注解与 Dubbo
中采用的微内核架构模式有关，我们会在后续讨论架构模式时会具体展开。本文中介绍其他接口或类时也会先忽略这些注解以降低理解复杂度。

    
    
    public interface Protocol {
    
        int getDefaultPort();
    
        <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;
    
        <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;
    
        void destroy();
    }
    

从方法命名上不难看出，Protocol 接口中的核心方法就是 export()和 refer()，前者用于对外暴露服务，而后者则用来对远程服务进行引用。

对于 Protocol 接口而言，在 Dubbo 中存在一大批实现类。Protocol 的类层结构如下图所示。

![](https://images.gitbook.cn/2020-05-25-052746.png)

从命名上也不难看出，RedisProtocol 和 MemcachedProtocol 是提供把对 redis 和 memcache
的客户端调用访问封装成接口调用格式的协议；InjvmProtocol 用来完成进程内的接口访问和服务提供；ThriftProtocol 支持 thrift
协议格式的接口转换，而 DubboProtocol 支持 dubbo 协议格式的接口转换。其中的 AbstractProxyProtocol
抽象类下的几个实现类 HessionProtocol、HTTPProtocol 等都是基于各自的接口库来实现协议接口转换

Protocol 的各个实现类中，最重要的就是 DubboProtocol，我们会在后续剖析分布式服务组件的课程中对其进行详细的展开。

### Proxy：透明化远程调用

当使用 Dubbo
运行远程服务调用时，我们所做的事情就是在配置文件或代码中添加对某个服务的引用，整个过程让人感觉并没有执行任何与远程方法调用相关的网络连接、数据传输、序列化/反序列化等操作，就像在调用一个普通的本地方法一样。远程调用本地化背后用到的就是动态代理机制。所谓动态代理，可以理解为在系统运行期间，为目标类生成二进制的
class 文件并运行，当系统运行完程，这个 class 文件也会消失。在 RPC 架构中，这些 class
文件就能帮我们自动实现诸如网络连接、数据传输、序列化/反序列化等具体操作。

我们看到在上一节的 Protocol 接口中，export()方法会传入一个 Invoker。什么是 Invoker？在 Dubbo 中，Invoker
是一个核心模型，其它模型都向它靠扰或转换成它，它代表一个可执行体。Invoker
有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。如果这里的 Invoker 是一个远程实现，就需要用到本节介绍的 Proxy 机制。

在远程调用过程中，当 Invoker
对象创建完毕后，接下来要做的事情是为服务接口生成代理对象。有了代理对象，我们就可以通过代理对象进行远程调用。代理对象生成的入口方法为在
ProxyFactory 接口的 getProxy()方法中，ProxyFactory 接口定义如下。

    
    
    public interface ProxyFactory {
    
        @Adaptive({Constants.PROXY_KEY})
        <T> T getProxy(Invoker<T> invoker) throws RpcException;
    
        @Adaptive({Constants.PROXY_KEY})
        <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;
    }
    

在 Dubbo 中，ProxyFactory 接口的实现类比较明确，即 JavassistProxyFactory 和
JdkProxyFactory。ProxyFactory 接口的类层关于如下图所示。

![](https://images.gitbook.cn/2020-05-25-052751.png)

这里的 JavassistProxyFactory 基于动态字节码实现动态代理，而 JdkProxyFactory 则使用 JDK 中自带的 Proxy.
_newProxyInstance_ ()静态方法生产代理类。

动态代理是一个值得作为专题进行讨论的话题，在本课程后续会有专题进行详细讲解，我们将介绍其在基于 Dubbo 的远程调用和基于 Mybatis
的数据库访问中的实现过程和原理。

### 面试题分析

#### Dubbo 框架代码的整体演进过程是怎么样的？为什么要这样设计？

  * 考点分析

这是一个关于 Dubbo 的常见问题，面向架构师或高级别的开发人员，主要考查 Dubbo 框架的整体结构，从而判断面试者对 Dubbo 的宏观掌握情况

  * 解题思路

这个问题在回答上就一定要有一张本文中介绍的 Dubbo
架构演进图，并能够按照自己的思路将核心几个步骤进行展开说明。所以，从这个角度上讲，这个问题并不难，只要记住这张架构演进图，并用自己的语言进行组织，通常都能够描述清楚。

  * 本文内容与建议回答

本文给出了一个 RPC 架构的基本演进过程，以及 Dubbo 框架中的特定演进案例。内容上不难理解，我们也给出了容易记忆的表述方式来介绍 Dubbo
框架整体架构演进的各个要点。

### 小结与预告

本篇从“基于架构演进过程剖析代码结构”角度出发探讨了阅读开源框架代码的另一种方法，并基于 Dubbo
这一特定框架讨论了它的架构演进过程，该过程可以分为五大步骤。本篇给出了这五大步骤中的前两步，下一篇我们将继续讨论后续的三个步骤，并尝试将这些步骤整合在一起。

