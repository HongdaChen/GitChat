今天我们来探讨一个非常经典的架构模式，即微内核模式（Microkernel Pattern）。微内核架构模式在 Dubbo、ShardingSphere
等众多知名开源框架中都得到了应用。在介绍该架构模式之前，让我们先来探讨一个话题，即如何构建插件式系统？

### 如何构建插件式系统？

正如《基于可扩展性设计剖析代码结构：常见系统可扩展性实现方法》一文中提到，扩展性是软件设计的永恒话题。实现系统可扩展的方法有很多，包括回调、模块化、管道过滤器、Java
SPI 机制等，这些方法从不同的角度出发实现扩展性，我们在前面的课程中已经做了概述。

从实现扩展性的策略上讲，插件式系统是我们追求的一个目标。我们希望打造如下图所示的效果，调用者能够通过基于配置的插件机制动态获取它想要的任何插件。

![18.01](https://images.gitbook.cn/2020-05-25-52619.png)

上图看似简单，但想要打造功能完备的插件式系统并不容易。这时候我们就面临一个核心问题，即引出本节内容想要讨论的核心话题，即：

**_如何构建插件式系统？_**

我们知道很多编程语言具有动态加载机制。基于编程语言的动态加载机制，我们就可以实现插件化系统，在配置时而非编译时连接类。同时，通过引入工厂模式和配置化思想，我们也可以在动态加载机制上实现更为完善的自定义封装。本节内容我们关注的是架构模式的应用，所以我们将基于架构模式中的微内核模式来实现上图中的效果。

### 什么是微内核模式？

微内核架构模式结构如下图所示，有时也被称为插件架构模式（Plug-in Architecture
Pattern），通过插件向核心应用添加额外的功能，可以实现功能的独立和分离。

![18.02](https://images.gitbook.cn/2020-05-25-052620.png)

微内核架构包含两部分组件，即内核系统（Core system）和插件（Plug-in
Component）。微内核架构的内核系统通常提供系统运行所需的最小功能集，插件是独立的组件，包含特定的处理、额外的功能和自定义代码，用来向内核系统增强或扩展额外的业务能力。

微内核是内核的一种精简形式。将通常与内核集成在一起的系统服务层被分离出来，变成可以根据需求加入选件
这样就可提供更好的可扩展性和更加有效的应用环境。使用微内核设计，对系统进行升级，显然只要用新模块替换旧模块，不需要改变整个系统架构。

那么插件是什么？插件一般由以下几部分组成：插件暴露的接口（一般称为叫 API）、插件内部实现、插件扩展点以及插件配置。其中插件扩展点我们一般设计为
SPI（Service Provider Interface，服务提供接口）。

微内核模式的本质是管理插件以及协调插件之间的调用。插件插件本身是一个很大粒度的扩展点，可以整个被替换。同时插件可以提供自己的小粒度扩展点。这样整个系统就是由一个微内核加很多插件组成一个具备很强扩展性的系统。

### 微内核模式的基本实现：Java SPI 机制

微内核架构风格在 Dubbo 中应用广泛，通信框架 Mina、Netty 和 Grizzly，序列化方式 Hession、JSON，传输协议
Dubbo、RMI
等都是这一架构风格的体现。我们可以通过简单的配置就能对这些具体实现进行排列组合构成丰富的运行时环境。微内核架构风格提供的是一种解决扩展性问题的思路，Dubbo
中实现这一思路的就是 SPI 机制。

SPI 是提供给服务提供商与扩展框架功能的开发者使用的接口，如果系统需要提供新的 API 实现并打包代码，那么通过 SPI 机制我们就可以在不修改 JAR
包或框架的时候为该 API 提供新实现，这就是 SPI 所面向的主要应用场景，也是插件化所需要解决的核心问题。

SPI 约定在 META-INF/services/目录中创建以接口全限定名命名的文件该文件内容为 API
具体实现类的全限定名。当服务的提供者提供了服务接口的一种实现之后，在 jar 包的 META-
INF/services/目录同时创建一个以服务接口命名的文件，该文件里配置着实现该服务接口的具体实现类，而该具体实现类必须有一个不带参数的构造方法。SPI
机制的实现步骤如下图所示。

![18.03](https://images.gitbook.cn/2020-05-25-052621.png)

而当外部程序装配这个模块的时候，就能通过该 jar 包 META-
INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。基于这样一个约定就能很好的找到服务接口的实现类，而不需要在代码里硬编码指定。JDK
提供了服务实现查找的一个工具类 java.util.ServiceLoader 来实现 SPI 机制。

接下来通过一个示例来演示基于 Java SPI 的实现过程。该示例非常简单，让我们先从一个 IHello 接口开始：

    
    
    public interface IHello {
    
        void sayHello();
    }
    

然后我们针对该接口，提供两个简单的实现类，分别是 Hello1 和 Hello2，如下所示。

    
    
    public class Hello1 implements IHello{
    
        @Override
        public void sayHello(){
            System.err.println("hello world---1");
        }
    }
    
    public class Hello2 implements IHello{
    
        @Override
        public void sayHello(){
            System.err.println("hello world---2");
        }
    }
    

这些代码都很简单，我们把它们放在一个名为 SPIProvider 的工程中，假设该工程的类路径为
com.tianyalan.spi。作为服务的提供者，这时候我们就需要在 META-
INF/services/文件夹里提供一个服务定义文件，基于类路径规则，该文件只能被命名为
com.tianyalan.spi.IHello。作为演示，我们先在该文件中写入前面定义的 Hello1 的完整类路径，即
com.tianyalan.spi.Hello1。然后，我们把该工程导出为一个 jar 包备用。

加下来要做的事情是新建另一个代码工程，该代码工程需要引用前文中所生成的 jar 包，并完成如下所示的 Main 函数。

    
    
    public class Main {
        public static void main(String[] args) {
    
            ServiceLoader<IHello> loader = ServiceLoader.load(IHello.class);
    
            for (IHello hello : loader) {
                System.out.println(hello.getClass());
                hello.sayHello();
            }
        }
    }
    

现在，该工程的角色是 SPI 服务的使用者，这里使用了 JDK 提供的 ServiceLoader 工具类来获取所有 IHello 的实现类。我们知道现在在
jar 包的 META-INF/services/com.tianyalan.spi.IHello 文件只有一个
com.tianyalan.spi.Hello1 类的定义，所以这时候我们只能获取 Hello1 的实现。执行这段 Main 函数，我们将得到是输出为：

    
    
    class com.test.Hello1
    hello world---1
    

接下来我们调整 META-INF/services/com.tianyalan.spi.IHello 文件中的内容，写入
com.tianyalan.spi.Hello1 和 com.tianyalan.spi.Hello2，并重新打成 jar 包供 SPI
服务的使用者进行引用。再次执行 Main 函数，则可以得到一下输出：

    
    
    class com.test.Hello1
    hello world---1
    class com.test.Hello2
    hello world---2
    

至此，完成的 SPI 提供者和使用者的实现过程演示完毕。这个示例非常简单，但确是 Dubbo 中实现微内核架构的基础。

### 面试题分析

#### 微内核模式的组成和作用？

  * 考点分析

该题考查微内核脚骨的基本概念，微内核模式的作用还是提供了一个高度可以扩展的实现机制，是很多开源框架中实现系统扩展性的首选架构模式。

  * 解题思路

所谓的微内核，就是说肯定存在一个内核系统提供了一个运行时环境。然后外部功能可以通过插件的方式集成到这个运行时环境，内核系统能够动态管理这些插件的生命周期。关于微内核架构的基本概念本文都做了纤细的说明，回答时只要有条理的进行说明即可。

  * 本文内容与建议回答

从知识体系上讲，本文对微内核架构的基本概念和构成要素都做了介绍。回答这个问题时的一个建议是，可以把设计思想拔高到架构层次，从扩展性角度进行切入。同时，微内核架构确实应用非常广泛，像
Dubbo 框架以及本课程中没有提到的 ShardingSphere（Apache
孵化的一款分库分表中间件）等开源框架都用到了这个架构模式。如果能够有所发散，展示一些自己的知识面，是一种加分策略。

#### 如何理解 SPI 机制？

  * 考点分析

这道题同样也是考查基本概念，即考查面试者对 SPI 机制的理解程度。考点还是很明确的，需要面试者具备相应的知识体系。

  * 解题思路

首先要明白 API 和 SPI 的区别，API 面向的是框架的用户，而 SPI 面向的是框架的开发人员。SPI
在本质上是提供给服务提供商与扩展框架功能的开发者使用的接口。回答这个问题时，我们可以先围绕 SPI 的定义，即服务提供接口 Service Provider
Interface 来进行展开。然后，结合微内核架构的设计思想给出进一步的说明。

  * 本文内容与建议回答

本文介绍了 SPI 机制的一种具体实现，即基于 JDK 的 ServiceLoader 类完成 SPI 实现的加载和管理。并给出了基于
ServiceLoader 类的具体使用案例，也是理论联系实践的一种介绍方法。回答该问题时，先介绍理论，然后再给出案例的说明即可。当然，如果你对 JDK 的
ServiceLoader 类的实现有兴趣，也可以进行进一步的深入学习，我们在接下来的课程也会基于 Dubbo 框架再次对微内核模式以及
ServiceLoader 类进行讨论。

### 日常开发技巧

在设计和实现一个需要考虑可扩展性需求的系统时，使用 JDK SPI
实现插件化模块或组件是一个很好的选择。日常开发过程中，这种场景实际上是比较多的，只是容易被忽视。如果我们能够抽象出一种插件化的场景，就可以参考本文中介绍的
JDK SPI 实现示例并应用到具体项目中。实际上，很多开源框架中应用 SPI 机制的实现方式并不会比本文中的代码示例有更多的复杂度。

### 小结与预告

本文系统架构了微内核架构的基本概念以及 JDK 中所提供的实现方式。Dubbo 框架中实现微内核架构采用了与 JDK
所提供的这套机制类似的设计思路，但并没有直接照搬而是重新提供了一套自己的实现机制。下一篇，就让我们把话题转换到 Dubbo，看 Dubbo 中应用 SPI
机制的具体过程。

