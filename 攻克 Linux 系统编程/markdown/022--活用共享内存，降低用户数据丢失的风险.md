在之前的课程中，我们介绍过，共享内存是一种非常高效的进程间通信机制。在本节课中，我们会
**从共享内存可以脱离进程而持续保持的特性出发，探讨它在降低用户数据丢失风险方面的应用** ，主要包括以下几部分内容：

  * 共享内存特性概述
  * 共享内存相关接口
  * 使用共享内存保存用户数据
  * 共享内存作为网络消息队列
  * 关于共享内存的大小

### 1 共享内存特性概述

**共享内存是进程间通信的一种机制**
。当不同的进程连接同一块共享内存时，操作系统实际上是把相同的物理内存页映射进不同进程的虚拟地址空间内，所以，虽然不同的进程都是在各自的虚拟地址空间内操作，但是实际上会修改相同的物理内存，任何进程做出的修改，也因此能立即被其他进程读取到，而不需要经过内核中转。

另外， **共享内存具有内核持久性**
，也就是说，它所包含的内容，即使当前没有任何进程在使用它，也会在内核中一直存在，直到系统关闭或重启。所以，当某个进程因为预料之外的原因而退出时，它保存在共享内存中的数据也不会丢失，只要进程重新启动，就可以再次连接并使用它。

**本节课的内容就是结合共享内存可脱离进程长期保持的特性，探讨它在保存用户数据方面的应用。**

### 2 共享内存相关接口

目前，Linux 系统提供两套共享内存接口：System V 标准接口和 POSIX 标准接口。

#### 2.1 System V 标准接口

在《第 06 课：探究进程间通信技术，优化数据传输效率》一节中，我们介绍了 System V 标准的共享内存，它包括以下三个接口：

    
    
    int shmget(key_t key, size_t size, int shmflg);
    void *shmat(int shmid, const void *shmaddr, int shmflg);
    int shmdt(const void *shmaddr);
    

其中：

  * shmget 函数用于创建或获取一块共享内存；
  * 创建之后，shmat 函数负责把创建的共享内存附加到进程内指定的虚拟地址上，附加之后，进程就可以像使用自己的堆内存一样使用这块共享内存了；
  * 使用完成之后，shmdt 用于断开进程与该共享内存之间的连接。

使用这套接口创建共享内存时，需要在创建时就指定预分配的大小，而且，这个大小是固定的，不能动态调整。正因为如此，在使用这套接口操作共享内存来保存数据时，需要尽量减少数据对象大小的变化，如果由于软件版本更新，数据对象的大小发生了变化，就需要删除旧的共享内存并重建。

#### 2.2 POSIX 标准接口

后来出现的 POSIX 标准接口， **把 Linux 中一切皆文件的设计思想继续延伸，将共享内存也抽象成了文件来执行操作** 。

它提供的专用接口只有两个：

    
    
    int shm_open(const char *filename, int oflag， mode_t mode);
    int shm_unlink(const char *filename);
    

  * shm_open() 函数负责打开或创建一个由文件名标识的共享内存对象，如果执行成功，该函数会返回一个代表该对象的文件描述符，后续可以使用通用的文件接口对内存对象执行操作。比如，可以使用 fstat() 确定文件长度，使用 fcntl() 修改文件属性，等等。

  * 当确定不再需要某个共享内存对象时，用 shm_unlink() 删除它。一旦所有的进程都解除了对这个对象的映射，这个共享内存对象就会被系统删除，其中的内容会被清空。

对于新创建的共享内存块，其文件长度默认是 0，通常会紧接着使用 ftruncate() 把它设置为需要的长度，然后使用内存映射函数
mmap()，把它的内容映射到进程的虚拟地址空间，接着就可以像使用本地堆内存一样使用该共享内存了。如下是一个使用该接口创建共享内存的示例函数。

    
    
    char * CreateShm(const char * name, size_t len)
    {
        int shmfd = shm_open(name, O_CREAT | O_RDWR, 0);
        if(shmfd < 0) {
            printf("shm_open failed\n");
            return NULL;
        }
    
        if(ftruncate(shmfd, len) == -1) {
            printf("adjust shm size to %d failed\n", len);
            shm_unlink(name);
            return NULL;
        }
    
        char * addr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);
        if(addr == MAP_FAILED) {
            printf("mmap shm failed\n");
            return NULL;
        }
    
        close(shmfd);
        return addr;
    }
    

使用如下语句就可以创建一块 1 M 大小的共享内存，用于保存用户数据：

    
    
    char * puserdata = CreateShm("/userdata", 1024 * 1024);
    

### 3 使用共享内存保存用户数据

**共享内存的内核持久性是一个非常有用的特性**
。利用此特性，进程保存在共享内存中的数据，在系统重启之前都可以被保存下来，如果进程把一些比较重要的数据存放在共享内存中，就可以避免由于程序的不稳定而造成的数据丢失。

但是， **在共享内存中保存数据，有一点需要着重考虑，就是它每次挂载的目标地址不是固定的**
。所以，当需要引用共享内存中的数据对象时，不能直接使用地址值，而需要考虑其他的引用方法。

**一个直接的思路是，使用相对于共享内存首地址的偏移量来表示共享内存中的地址，就可以做到不论加载地址如何变化，都能正确地引用**
。下面给出一个可选方案供读者参考。

例如，我们需要在共享内存中保存 N 种固定长度的数据对象，其类型标识为从 1 到
N，每种类型具有不同的长度和不同的数量。这时候，我们可以使用如下的结构来标识一个保存在共享内存中的对象。

    
    
    typedef uinon uuid {
        struct {
            short TID;
            short IDX;
        } SSID;
        int SID;
    } UUID;
    

在这个结构中，我们把 32 位的对象 ID（SID） 拆分成类型（TID）和索引（IDX）两部分。为了能方便地从对象 ID
确定它的存储位置，我们还需要在共享内存的头部保存一个所有数据的索引表。可以如下图所示进行设计：

![存储排布设计](https://images.gitbook.cn/16674bb0-4286-11e9-bb2c-779598067917)

如此一来，我们用对象的类型 ID 在这个索引表中找到该类对象的起始地址，然后加上元素大小 *
索引，就能找到它的保存位置了。不管共享内存的附加地址如何变化，只要以附加地址的起始位置为基准执行计算就可以了。

如果不想每次都查索引表计算偏移量，还可以考虑把对象 ID 扩充，把对象相对附加起始地址的偏移量直接编码到对象 ID 里面，可以实现更高的查询效率。

另外，如果需要在共享内存中的对象上保存堆内存地址，同样需要在进程重新启动后执行重建，否则，也可能会引用到错误的地址。

### 4 共享内存作为网络消息队列

**对于网络服务器程序，共享内存还可以用来作为需要处理的网络消息的缓冲队列**
，这样，当进程非正常退出时，未处理的网络消息可以被保存在消息队列里面，而不会丢失。等进程再次启动时，可以继续处理。

如果再把接收和处理网络数据的任务分别交给两个不同的进程，让它们之间使用共享内存作为消息缓冲和传送的通道，那么，只要接收进程足够稳定，不轻易宕机，即使处理进程不太稳定，只要能异常退出后有办法让它快速重新启动起来，就可以让错误的影响范围只限制在有限的几个消息内，而不会因为在一个消息上发生的错误，导致对所有用户的服务产生影响。

### 5 关于共享内存的大小

在 Linux 中，共享内存是在临时文件系统 tmpfs 的基础上实现的。

tmpfs 是一种基于内存的文件系统。所谓的基于内存，就是说它的存储空间是由 Linux 内核中的 VM（虚拟内存）子系统管理的。VM
可使用的内存包括物理内存和交换分区，所以， **一个系统中可以创建的共享内存的大小，不可能超过物理内存与交换分区大小的总和** 。

实际上， **默认情况下，系统会把 tmpfs 文件系统的大小限制在物理内存的一半** 。可以通过修改文件系统挂载参数的方法调整共享内存的大小限制，例如，在
/etc/fstab 文件中增加如下配置项，可以把共享内存大小的上限调整为 2G。

    
    
    tmpfs    /dev/shm    tmpfs    defaults,size=2048M    0 0
    

但是，要注意的是，交换分区是使用磁盘虚拟出来的，而磁盘的访问速度要比内存慢得多。而当系统中物理内存不能满足活动内存的总量需求时，内核会把一部分物理内存中的数据换出到交换分区上，从而会影响进程的执行速度。

所以，开发人员需要合理分配共享内存和其他动态内存的大小，必要的时候，可以把对性能至关重要的内存锁定（使用
mlock()）在物理内存，保证它们不会被换出到交换分区。

### 6 总结

在本节课中，我们 **回顾了共享内存的两种标准接口** ，并 **介绍了如何利用共享内存的内核持久性防止由于程序稳定性造成用户重要数据丢失的情况出现。**

如果读者对此有更多的新点子，欢迎在读者群一起讨论学习。

