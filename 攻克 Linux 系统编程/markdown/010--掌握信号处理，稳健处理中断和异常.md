信号在操作系统中有悠久的历史，信号的概念和使用方式都非常简单，但是要编写出真正实用而稳定的信号处理程序却并不容易。

本节课我们就来深入地了解一下 **Linux 中信号处理的底层细节** ，帮助读者 **更好地利用系统的各种信号** ，主要包括以下几方面内容：

  * 信号的基本概念
  * 信号处理流程
  * 可重入与异步安全
  * 信号处理程序注意要点
  * 信号对阻塞的系统调用的中断

### 1 信号的基本概念

信号是操作系统中当某个事件发生时对进程的通知机制。当进程接收到信号时，如果存在该信号的处理程序，进程就会被中断，并转去执行指定的信号处理程序。

进程因收到信号而被中断的时机是不可预料的，在这一点上，对信号的处理与硬件中断很像，所以有时也被称作 **软件中断** 。

另外，信号也可能是由程序自身或其他的程序产生和发送的，这一特性可以 **用作进程间一种原始的同步或通信手段** 。

对于系统程序开发人员来说， **常见的信号有以下几种** 。

  * SIGSEGV：如空指针引用、数组越界等导致出现了错误的地址值，野指针访问到了没有映射的地址，或试图更新没有写权限的内存页等情况下会引发该信号。
  * SIGBUS：试图访问的内存地址没有按照指定的要求对齐时就会引发该信号，常见于一些移动设备。
  * SIGFPE：算数运算错误所引发的信号，最常见的如除零引起的异常。
  * SIGINT：当在 Shell 中用 Control+C 终止一个没有反应的进程时，就会向该进程发送这个中断信号。
  * SIGKILL：该信号的编号为 9。Linux 系统管理员常用的 kill -9 命令，就是向目标进程发送该信号，该信号的默认处理方式是终止进程，而且该行为不能被修改，所以，它总是能终止一个运行中的进程，但是僵尸进程和 1 号进程（init）例外。
  * SIGTRAP：当使用 GDB 单步或断点调试的时候，利用的就是这个信号。
  * SIGILL：某些错误的 C++ 使用方式，会导致编译器生成一条无效指令，当执行到该条指令时，就会引发一个 SIGILL 信号，导致程序终止。
  * SIGALRM：当使用 setitimer 设定的定时器到期时，进程就会收到一个这样的闹钟信号。

完整的信号列表可以在 signal 的手册页中找到，有兴趣的读者可以详细阅读一下。

在 Linux 中， **系统对信号的处理方式大体可分为以下几种** ：

  * 终止进程
  * 终止进程，并产生核心转储文件（Core Dump）
  * 执行用户自定义的信号处理函数
  * 忽略该信息

其中，终止进程的操作是早期系统对所有信号的默认行为，也正因为此，进程间发送信号的命令被叫做 kill。

后来随着计算机技术的发展，信号技术也逐渐扩大了它的应用范围，比如 Google 的性能测试工具 gperftools，利用 SIGALARM
信号实现对运行中的进程执行位置的周期性采样，实现统计方式发现性能热点的功能；还有的网络游戏服务器程序，会利用信号来触发脚本和配置文件的重新加载，实现不停服的游戏数据更新。

### 2 信号处理流程

基本的信号处理的流程非常简单，就是 **当指定信号传递给进程时，内核就会打断进程主程序的执行，并代表进程来执行一段信号处理程序**
。当信号处理程序运行结束后，内核会将被打断的进程从被打断的位置恢复执行。如下图所示：

![](https://images.gitbook.cn/c4439970-2457-11e9-9209-e73ae1e9a759)

其中的信号处理器程序，可能是系统默认的处理程序，比如对信号 SIGKILL 和 SIGSTOP 的处理程序；也可能是应用自己对特定信号安装的一个处理程序。

安装信号处理程序的函数有两个：

    
    
    sighandler_t signal(int signum, sighandler_t handler);
    int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
    

  * signal 函数比较简单，其作用就是为指定的信号安装一个信号处理函数，并返回旧的处理函数以备有用。sighandler_t 是一个函数指针，其定义为：

    
    
    typedef void (*sighandler_t)(int);
    

  * sigaction 的功能更加强大一些，它可以对安装的信号处理程序执行更加精细的控制，同时，如果指定了 SA_SIGINFO 标志，在信号发生时还能获取到关于信号的更多信息，如发送信号的进程 ID、发送者 ID、引发信号产生的指令地址等。sigaction 结构的定义中通常包含如下的几个字段：

    
    
    struct sigaction {
       void     (*sa_handler)(int);
       void     (*sa_sigaction)(int, siginfo_t *, void *);
       sigset_t   sa_mask;
       int        sa_flags;
       void     (*sa_restorer)(void);
    };
    

更加详细的信息，可参考 sigaction 的帮助手册。

到此为止，一切都很简单和直接，但是现实世界往往更加复杂，比如：

  * 信号处理程序的执行也是需要时间的，在这段时间内又产生了新的信号怎么办？
  * 信号处理程序自己引发了信号怎么办？
  * 一个进程接收到信号的频率超过了自己的信号处理程序的处理能力会发生什么？

要对这些问题也能从容应对，就需要更加深入和细致地了解信号处理的底层细节。

### 3 可重入与异步信号安全

在继续深入之前，我们需要先明确两个概念：可重入与异步信号安全。

#### 3.1 可重入函数

SUSv3 对 **可重入函数的定义为**
：当函数由两条或多条执行路径调用时，即使交叉执行，其效果也与各执行路径以未定义的顺序依次执行时一致，那么该函数就是可重入函数。

换句话说，如果同一个函数不管被外界以怎样的顺序交叉调用，每个调用者都能获得正确的预期结果，而不会互相干扰，那么该函数就是可重入的。只用到了函数内的局部变量的函数一定是可重入的，而如果函数内包含对全局或静态数据结构的更新，那么该函数就很可能是不可重入的。

要特别注意上面定义中使用的术语是“ **执行路径**
”，而不是线程。执行路径是个比线程范围更大的概念。中断处理程序和线程都定义了不同的执行路径，但是它们两者有很大的区别：

  * 主进程与中断处理程序是不会并行执行的，同一时刻只会执行其中一个，而且执行顺序是固定的，中断处理程序执行完成之前，绝不会执行主程序；
  * 而一个进程中的多个线程可以同时在不同的 CPU 核心上并行执行。

可重入函数的定义对象是执行路径，而不是线程。 **信号处理函数需要是可重入的。**

比如常用的 malloc 和 free 函数，因为它们的内部会去更新一个全局的可用内存块的链表，所以是不可重入的。

试想一下，如果一个正在执行中的程序在 malloc 函数中更新可用内存块链表的中途被信号中断，如果在信号处理程序中也调用了 malloc
函数，也去更新这个链表结构，那么对链表的更新操作会乱序执行，就有可能造成链表结构的损坏。所以， **malloc 不能在信号处理函数中使用** 。

而同时，在 malloc 和 free
的内部实现中，当更新全局的内存块链表时，会使用某种锁机制进行保护，多个线程同时调用也不会造成错误，所以它们是线程安全的，
**可以在不同的线程中放心的使用** 。

在信号处理程序中使用锁是没有用的，因为信号处理程序虽然定义的是另外一条程序执行路径，但是它与主程序之间实际还是串行的执行关系。如果使用的是互斥锁，会造成信号处理程序不能获得锁而阻塞；而如果使用递归锁，会起不到保护关键结构的效果。

#### 3.2 异步信号安全

**异步信号安全** 的定义是，如果能在信号处理程序中调用而不会发生错误，这个函数就是异步信号安全的。

它比可重入函数的要求又放宽了一点。可重入的函数一定是异步信号安全的；同时还有些函数虽然是不可重入的，但是如果设置了不能被信号处理器打断，那它也是异步安全的。

如何设置函数不被信号中断呢？内核中会为每个进程都维护一个信号掩码，掩码对应的信号会被内核阻塞而暂时不发送给进程，直到该信号的掩码被移除时为止。

内核提供了一个系统调用可以让应用随时修改进程的信号掩码：

    
    
    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
    

其中 how 参数可以指定对 sigset 结构中指定的信号的处理方式，可以取值：SIG_BLOCK（阻塞信号）、SIG_UNBLOCK（解除阻塞）和
SIG_SETMASK（将 set 指定的信号集赋值给信号掩码）。前两个标志的作用不言自明，SIG_SETMASK
常用于对信号处理状态的恢复，修改信号集掩码时会在 oldset 中返回之前的掩码状态，在信号处理结束之后，就可以使用如下的调用来恢复之前的设置：

    
    
    sigprocmask(SIG_SETMASK, oldset, NULL)
    

### 4 信号处理程序注意要点

#### 4.1 让信号处理函数可重入

在技术上，信号处理程序可以做任何事情，但是在工程实践中，信号处理程序应该力求只做必要的事情，尽量减少运行时间。另外，要做到不论程序在何处被信号处理中断，也不论信号处理程序被以怎样的顺序执行，程序都能正确运行，可以有两种选择。

  * **选择一** ：让信号处理程序的代码是可重入的。也就是说不去更新任何全局的数据结构，而且在信号处理程序中不使用任何不可重入的库函数。
  * **选择二** ：如果信号处理程序中一定要用到某个非异步安全的函数，而且在主程序中也会用到这个函数，那么在主程序中执行该不安全函数之前， **应该阻塞相关信号的传递，防止在该函数内被该信号中断而引发错误** 。

如果决定采取第二种选择，以让信号处理程序能利用更多的系统功能的话，那就需要让项目的所有开发人员都知道系统中有哪些信号处理函数用到了哪些非异步安全函数，并且在主程序中用到这些非异步安全函数的时候，阻塞相关的信号，完成之后再恢复信号处理掩码。

在工程规模比较大的时候，这个要求的执行难度实在太高，所以，通常会采用第一种选择，提高对信号处理函数的要求，让主程序只关注业务逻辑，而不用太多考虑与信号处理程序的相互影响。

#### 4.2 信号处理程序小心处理全局数据

如果严格保证了信号处理程序的可重入性，也就是完全不使用任何全局数据，那就不会有任何问题。但是，有时候，信号处理程序也需要一些全局或静态数据来辅助完成特定的功能，这时候要注意的要点就是，
**信号处理程序也可能会被信号所中断，要仔细考虑这种情况下的处理逻辑**
，如果自己可能中断自己，那么即使使用的全局数据不与主程序共享，也有可能会引起问题，这时就需要在信号处理程序中暂时屏蔽有可能产生冲突的信号。

#### 4.3 小心对全局 errno 的影响

如果信号处理程序中调用的某个系统函数会修改 errno，那么还需要在信号处理程序的入口先保存当前 errno 的值，并在信号处理程序返回之前将 errno
恢复，否则，有可能会影响主程序中被中断的系统调用的返回结果。

#### 4.4 保证全局共享变量操作的原子性

有时候，在信号处理程序与主程序之间进行必要的信息交换是必须的，这时候，一种可能的设计是在信号处理程序中更新某个全局变量的值，而在主程序中只做检查，而不做任何修改。

这样的设计不会产生可重入的问题，但是需要注意， **任何在主程序与信号处理程序中共享的变量都应该用 volatile 关键字来修饰**
，以告诉编译器，这个变量是易变的，不要把对它的操作优化成寄存器直接取值的方式。否则，可能会出现在信号处理程序中已经更新了某个变量在内存中的值，但是主程序在接下来的检查中却读不到最新值的情况，而且这样的错误非常难调试。

实际上，对信号处理程序来说， **只用 volatile 关键字是不够的，还需要更加严格的限制**
。因为在某些平台上，对变量的读写操作可能并不是用一条指令完成的，而信号处理程序可能会在这些指令序列的中间某个位置将主程序中断，这时依然无法保证程序的正确性。所以，C
语言标准提供了一种能保证读写操作原子性的整数类型：sig_atomic_t，对这种类型的数据的读写操作是原子的，不会在中间被打断。

所以，如果需要在信号处理程序与主程中用全局变量来传递信息，应该使用：

    
    
    volatile sig_atomic_t variable;
    

这样就能保证安全了吗？其实，还是不见得。它只能保证在信号处理程序中更新，在主程序中读取该变量的操作是安全的。但是如果需要在主程序中执行更新，而在信号处理程序中读取该变量的值的话，还
**需要注意 C 语言的 ++ 和 -- 操作符** 。

因为 C 语言标准并没有把这两个操作符纳入 sig_atomic_t 类型的保障范围，在有些精简指令集系统上，一句 variable++
语句，可能会被翻译成连续的多条指令，所以仍然有可能在这些指令序列的中间被打断。

在工程应用中，如果需要在主程序中对共享变量 variable 执行 ++ 和 --
操作的话，还需要确定该语句在你的产品的目标平台上生成的汇编代码序列，如果产生的是多条指令的话，还需要一些额外的必要措施才能保证万无一失，比如更新变量过程中临时屏蔽信号传递。

#### 4.5 注意连续信号被覆盖的问题

关于信号处理程序另外一个需要知道的事实是，在被屏蔽的状态下，连续收到的多个标准信号（1 — 31
号）是不会被排队的，而是重复的信号会被默默丢弃。也就是说，如果在信号屏蔽期间有多个相同的信号被发送给了进程，那么在进程解除该信号的屏蔽位时，只会收到一个此类信号。

所以， **最好不要依赖收到的信号的数量做什么事情** ，除非你能完全准确地预期到目标信号的接收频率，并且能确定你的信号处理程序的处理能力是足够的。

如果确实 **需要准确的信号数量信息，应该使用新的实时信号** ，实时信号的内容不在本课的讨论范围之内，后面可能会有别的课程对此专门讨论。

#### 4.6 为信号处理程序提供备选栈

信号处理程序经常被作为程序中处理异常状况的手段，以尽量保证程序的稳定性，或者在异常出现时能准确记录异常出现时的状态。所以，信号处理程序还需要考虑一种特殊的异常，就是
**进程的内核栈超过系统限制** 。

此时，内核会产生 SIGSEGV 信号，但是因为这时栈空间已经耗尽，所以进程会直接终止，而程序自己安装的 SIGSEGV 信号的处理函数会得不到执行。

这种情况下， **可以预先为信号处理程序准备一块预留好的内存区，作为信号处理函数的备选栈** 。函数 sigaltstack
可以完成这个任务，同时，在给指定信号创建处理函数的时候，需要指定 SA_ONSTACK 标志。sigaltstack 的函数原型和使用的结构定义为：

    
    
    int sigaltstack(const stack_t * sigstack, stack_t * old_sigstack);
    
    typedef struct {
        void * ss_sp;       //备选栈的起始地址
        int    ss_flags;    //备选栈操作标志：SS_ONSTACK 启用 SS_DISABLE禁用
        int    ss_size;     //备选栈空间大小
    }stack_t;
    }
    

**这个功能对运行在无盘工作站上的程序特别有用** 。因为没有硬盘，无盘工作站上运行的程序通常会自己对 SIGSEGV
信号编写处理函数，在崩溃发生时收集必要的现场信息并把信息通过网络发到某个能保存这些信息的位置。这种场景下，就应该使用备选栈特性保证栈空间耗尽时产生的崩溃信息也能被正确地捕获和收集。

### 5 信号对阻塞的系统调用的中断

虽然信号处理程序执行完成之后，会返回到主程序被中断的位置继续执行，但是如果中断的位置发生在某些系统调用的位置时，系统并不会当做什么也没发生一样继续执行没有完成的工作，比如一些可能产生阻塞的系统调用，它们会返回错误码指示自己被信号打断过。

这时候，业务代码就需要正确的处理这种情况。如果去看一些网络库的源码，经常会看到如下的代码段：

    
    
    static void block_readpipe(int pipefd, void *buffer, int sz) {
        for (;;) {
            int n = read(pipefd, buffer, sz);
            if (n<0) {
                if (errno == EINTR)
                    continue;
                fprintf(stderr, "socket-server : read pipe error %s.\n",strerror(errno));
                return;
            }
            // must atomic read from a pipe
            assert(n == sz);
            return;
        }
    }
    

上面的代码段出自云风的开源游戏服务器 Skynet。在这段代码中，在从管道里面读取指定字节的数据时，对 EINTR 错误做了特殊的处理，即：

  * 当发现 read 系统调用返回了错误，而错误代码是 EINTR（被打断）的时候，当做什么也没发生，继续读取后面的数据；
  * 其他类型的错误才会被作为管道出错的情况来处理。

其原因，就是因为在管道上的 read 系统调用时会阻塞的，如果当进程阻塞在 read
系统调用上时收到了信号，那么在执行完对应的信号处理程序之后，在再次返回主程序时，read 系统调用会返回错误码告知进程自己被打断过。

如果在 Socket 上执行阻塞的读取操作时，如果给 Socket
设置了超时时间属性，那么当阻塞时间超过设置的超时时间时，也会有一个信号出来打断阻塞的系统调用，这时，错误码会被设置为 EAGAIN 或者
EWOULDBLOCK，表示这次读取超时了，到此为止了，想要更多的数据就再试一次吧。

在 Linux 的标准中，规定在这种情况下，把 errno 设置为 EAGAIN 和 EWOULDBLOCK
都是可以的，所以，要想让你写的程序兼容性更好，总是应该把这两个错误码一起检查。

此外，在设置信号处理函数是，还可以指定 SA_RESTART
标志，用来告诉操作系统，如果这个信号打断了某些系统调用，那么在信号处理程序执行完成之后，自动重启被打断的系统调用，而不需要应用程序像上面处理 read 的
EINTR 一样手动重启。

不过，并不是所有的系统调用都可以被自动重启，具体的情况有一套很复杂的规则，可参见 _The Linux Programming Interface: A
Linux and UNIX System Programming Handbook_ （中文版《Linux/UNIX 系统编程手册》）一书第 21.5
章《系统调用的中断和重启》。

对 Linux 开发者来说，理解信号中断可能对进程执行产生的影响，并正确处理几种特殊的中断类型，能让写出的程序更加健壮和稳定。

### 6 总结

本节课我们深入 **讨论了 Linux 中的信号处理程序**
，虽然概念和用法都很简单和直接，但是由于信号处理程序有比常规业务逻辑代码更多的限制和要求，编写稳定可靠的信号处理程序
**通常需要更多的专业经验和更加严谨的设计和编码** 。

通过本节课的学习，希望读者 **掌握对信号的处理方法** 的同时，还能 **深刻地理解需要注意的各种要点的底层原因**
，从而设计和编写出稳定可靠的系统程序。

