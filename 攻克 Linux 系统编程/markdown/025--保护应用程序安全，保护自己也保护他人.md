本文我们讨论的主题是如何写出尽可能安全的应用程序。而要知道什么样的程序是安全的，就要先讨论程序会受到什么样的安全威胁，也就是常见的对应用程序的攻击手段，针对每种攻击手段，我们会给出提高程序安全性的防范建议。

要讨论的内容主要包括：

  * 栈溢出攻击原理与防范
  * 堆溢出攻击原理与防范
  * 格式化字符串漏洞攻击与防范

### 1 应用程序安全概述

在互联网的世界里，安全是个永恒的话题，黑白两方的较量从来没有停止，在可预见的将来也将一直持续下去，而且，随着越来越多的商业活动转移到互联网上，安全问题也将受到越来越多的关注。

在大多数人的理解中，计算机安全与密码学和权限管理的关系比较大，而与常规的业务逻辑开发好像并没有太大的关系。实际上，应用程序执行过程中的任何一环都可能成为被攻击的目标。通过本节课的内容，读者们将会了解到，常规的业务逻辑缺陷是如何成为被攻击利用的目标，变成安全链条中薄弱的那一环的。

### 2 栈溢出攻击原理与防范

栈溢出是最常见、危害最大的软件漏洞类型之一，在互联网上传播的第一个蠕虫病毒“Morris 蠕虫”，就是用栈溢出漏洞实现的。

要理解栈溢出攻击的原理，需要对计算机程序中函数的调用和返回过程的底层细节有清晰的理解，
**尤其是这样一个问题：计算机是如何保存某个函数调用的下一条指令地址，实现函数执行完成之后跳回函数调用处，继续往下执行的？**

我们都知道，函数的执行需要栈，大多数函数都有自己的栈帧，里面存放着当前函数内的局部变量、调用本函数之前的寄存器值等信息。以使用最广泛的 x86 CPU
为例，它有两个专用的寄存器 RSP 和 RBP，分别指向当前函数的栈帧的头和尾。当某个函数 A 需要调用另外一个函数 B 时，CPU 会依次把当前 Call
指令的下一条指令地址、当前的栈尾指针 RBP 的值等数据压栈，然后把 RBP 赋值为当前的 RSP，并把 RSP 的值上移，调整到新的位置，这样就构造出 B
函数需要的栈帧。

当 B 函数执行完毕之后，CPU 会先把 RSP 调整到当前的栈尾，然后从栈内弹出之前保存的 RBP 值，赋值给 RBP 寄存器，这样就恢复到了调用 B
之前的栈帧，然后，再把之前保存好的 Call 指令的下一条指令地址出栈，赋值给当前的指令指针寄存器 RIP，就实现了程序在函数调用之后继续执行。

#### 2.1 栈溢出攻击的实现

**这里存在漏洞的关键在于，函数返回后，继续执行的下一条指令地址是从内存的某个位置读出来的，如果内存中的这个值在函数返回之前被修改，那么程序的执行流程就会被修改**
。

而造成这个值被修改的常见原因，就是对函数内某个局部数组的操作，发生了越界，如果越界范围越过了当前函数栈帧的尾部，就会把之前保存在栈中的 RBP 和 RIP
值修改掉。

在大多数情况下，栈溢出会导致程序在函数返回后崩溃。但是，如果攻击者精心构造溢出数据，把保存 RIP
值的内存位置修改成某个特定的值，就可以实现控制代码执行流程，让它去执行自己定义的一段代码的效果，而这段代码，可能是一段病毒，也可能是一段获取系统权限的
Shellcode。

例如，如下的一段代码，就是典型的有栈溢出漏洞的程序，它把外部的输入复制到一个局部缓冲区内，然后执行一些自己的逻辑，但是并没有严格地检查输入数据的长度，就使得外部精心构造的输入数据，可以控制
check_param 函数返回之后的执行流程，从而实现攻击的目的。

    
    
    void check_param(char * param)
    {
        char buffer[128];
        strcpy(buffer, param);
        ......
    }
    
    int main(int argc, char * argv)
    {
        check_param(argv[1]);
        ......
    }
    

#### 2.2 栈溢出的防范

从上面的分析可以看出，只要对栈内数组操作的边界执行严格仔细的检查，杜绝任何数组越界访问的行为，就可以阻止栈溢出攻击。

在上面的程序中，只需要把 strcpy 改成具有边界检查功能的 strncpy，就可以堵住这个漏洞：

    
    
    void check_param(char * param)
    {
        char buffer[128];
        strncpy(buffer, param, sizeof(buffer));
        ......
    }
    

### 3 堆溢出攻击原理与防范

与栈溢出类似，分配在堆上的内存也会发生溢出，溢出之后也会修改掉一些本不该被修改的数据。只是利用堆溢出控制程序执行流程的过程更加复杂。

#### 3.1 内存释放漏洞攻击

这是最常见的对内存溢出攻击方式，要理解这种攻击的实现原理，需要 **先理解一下 glibc 的堆内存管理策略** 。

当用户通过 glibc
的动态内存分配函数申请一块内存时，库函数不会每次都去向操作系统请求同样大小的内存，而是会一次性申请一块相对大块的内存，然后把这大块内存做些分割，并把合适大小的一块返回给应用程序。当应用程序再次申请内存时，库函数会先在已从操作系统拿到的内存块中查找，是否已经有能满足要求的内存块，如果有就直接返回。

应用程序持续不断的申请和释放内存块，库函数还需要尽量避免内存碎片的产生，所以，当用户释放一块内存时，它会检查该块内存的前后两块相邻内存的空闲状态，如果它们也是空闲的，就把这几块连续的空闲内存块合并。而这个合并操作，就是删除双向链表的某个中间节点。示例代码如下：

    
    
    void unlink(malloc_chunk *P, malloc_chunk *BK, malloc_chunk *FD)
    {
        FD = P->fd;    //当前节点的前项指针
        BK = P->bk;    //当前节点的后项指针
        FD->bk = BK;   
        BK->fd = FD;
    }
    

上面是一个典型的从双向链表中删除某个指定节点的操作，其中 P 是要删除的中间节点，而 BK 和 FD 分别是 P
节点的后一个和前一个节点。这段代码能够被利用的关键在于，它有两个内存写操作:

    
    
    FD->bk = BK;
    BK->fd = FD;
    

而写内存的地址和写入的内容，都来自于相邻内存中的数据。所以，如果程序中存在堆溢出缺陷，攻击者就可以用精心设计的输入数据，去操作 malloc_chunk
结构中的指针值，使得在执行这个内存写操作的时候，去修改攻击者希望修改的数据。

比如，可以把内存地址修改成计算得到的 GOT 表中某个库函数的地址，而写入内存的值修改成某段 Shellcode
的入口地址。这样，当程序在后面调用到这个库函数之后，就会实际去执行自己提前准备好的 Shellcode，从而达到攻击的目的。

原理很容易理解，但是操作起来就需要高超的技巧和精确的计算了。而且，并不是任意大小的堆内存溢出都能够被利用来实现程序流程控制，因为在 glibc
的内存管理策略中，为了加快小块内存的分配和释放效率，大小不超过 64 字节的内存块是用 fastbin
组织管理的，而不会被链接在双向链表结构中，它们在释放之后不会执行前后内存块的合并操作，因此不会成为上面介绍的堆溢出攻击方法的目标。

#### 3.2 堆溢出攻击的防范

与栈溢出类似， **封堵堆溢出的关键也在于，程序中用到的所有内存操作，都要严格检查操作边界** ，比如，任何用到 memcpy、strcpy
等函数的地方，都要对输入数据执行严格的长度检查，保证其不会操作超出预定义的缓冲区的内存。对于通过复杂计算得到的数组下标，也要小心处理，确保其落在有效的范围内。

### 4 格式化字符串漏洞攻击与防范

**格式化字符串漏洞产生的原因在于，程序没有对外部输入的内容执行严格的检查和过滤** ，当这样的数据作为参数传递给某些格式化操作函数，如
printf、fprintf 等时，就可能被恶意用户利用。比如，一个最简单的存在格式化字符串漏洞的程序如下：

    
    
    int main(int argc, char * argv[])
    {
        char buffer[1024];
        strncpy(buffer, argv[1], sizeof(buffer)-1);
        printf(buffer);
        return 0;
    }
    

在这个程序中，虽然使用了带有边界检查功能的 strncpy 函数执行内存的复制，没有溢出漏洞，但是在使用 printf 函数输出 buffer
内容时，并没有对外部输入内容执行任何形式的验证和检查。这样，外部输入的数据中，如果带了“%s”或“%x”等格式符时，就会意外的输出一些本不该显示出来的内容。甚至，还可以精心构造带有“%n”格式符的输入，实现向某个内存地址写入数据，让程序返回时，去执行某段自定义的
Shellcode，达到攻击加利用的目的。

#### 4.1 格式化字符串漏洞的防范

**要防范这种漏洞，只要对输入数据执行严格的格式检查就可以了**
。好在这种漏洞的识别难度不大，通过代码审查流程就能够很容易的识别出来。而且，在大多数的商业软件中，直接使用外部输入数据作为格式化字符串函数的输入参数的情形并不多见，因此这种漏洞比较少见。

但是，这种格式化字符串攻击的思路，可以扩展到很多其他的领域。比如，常见的 SQL
注入攻击，其实现思路与之很相似。而防范手段也一样，就是不要完全信任任何的外部输入，对每个来自外部世界的输入都要执行严格的合法性检查。

### 5 总结

本节课 **通过介绍三种比较常见的软件漏洞的产生原因，以及被利用来执行攻击的实现原理**
，向读者展示了业务软件实现中的小疏忽，是如何成为被攻击和利用的目标，并产生严重后果的。

实际上， **软件漏洞的存在形式远不止本节课介绍的这三种，软件攻击的手段更是多种多样**
，比如，比较常见的还有利用整数溢出漏洞的攻击、利用双重释放漏洞的攻击，等等。此外，还有的攻击行为是以窃取进程敏感信息为目的的，比如，有种攻击方式是持续向目标进程发送结束信号，让目标进程产生
core dump 文件，从而可以在 core dump 文件中搜索敏感信息。

网络的世界很精彩，也很不安全。希望通过本节课的内容，读者们能够对应用程序的安全性有更加深刻的认识，在日常的开发中就注意到一些可能造成系统安全漏洞的点，避免让自己成为整个安全链条中的薄弱环节。保护自己的系统，保护自己的用户，也为保护整个互联网贡献一点自己的力量。

