本文我们要介绍 Linux 上两个非常有用的工具：ltrace 和 strace。在分析软件的运行过程、调试疑难
Bug、执行性能分析和调优等方面，它们都是非常有用的辅助工具。另外，我们还会介绍与之相关的一个功能强大的系统调用：ptrace。充分理解并掌握 ptrace
的使用，能够实现一些很“酷”的功能，主要包括以下几方面内容：

### 1 概述

Linux 开发人员，有时会遇到如下这样的开发需求。

  * 某个服务在特定条件下会发生系统调用错误，但是开发时没有在该处添加详细的错误日志，而当前又不具备修改源码重新编译发布的条件。还有什么办法能确定引发系统调用错误的具体的原因呢？
  * 需要统计某个服务对库函数和系统调用的执行频率和分别的时间消耗，以发现性能瓶颈并执行优化。
  * 手头有一款第三方的软件，想从整体上理解它的执行流程和工作原理。但是它的源代码是不公开的，还有没有别的办法能看到它与系统交互的大体流程呢？

对于这样的开发需求，正是我们今天要介绍的 ltrace 和 strace 两款工具的用武之地。其中：

  * ltrace 能跟踪进程对库函数的调用情况；
  * strace 能跟踪进程的所有系统调用和信号处理情况。

在使用这两个工具的时候，都不需要修改目标进程的任何源代码，也不需要重新编译，而只需要使用工具启动目标进程，或者直接附加到已经运行的进程上去，就可以执行指定的监控。可以说，这两个工具是
Debug 和性能分析的利器。

后面的内容，会详细介绍它们常用的跟踪选项，以及各自的工作原理。

### 2 ltrace

ltrace 能够跟踪用户空间的进程对共享库中的函数的调用，它是通过 hook
动态加载库，在调用动态库函数的位置插入一些垫片代码（shim），把对库函数的调用重定向某个自己的函数内，在该函数内再去执行原来的库函数调用，但是会额外地截获对库函数的传入参数和返回值。

常用的 ltrace 参数有如下几个。

  * -c：统计对库函数的调用次数和每个函数的用时，并在程序退出时打印统计的摘要，这个选项对分析进程在库函数上的热点消耗非常有用。
  * -f elfname：用 ltrace 启动指定的可执行文件，并马上跟踪它的运行过程。如果使用的某个第三方程序会在启动时出错，又没有提供足够的出错信息，可以用这个选项来启动，或许可以从库函数的调用和返回值信息中，找到出错的确切原因。
  * l library：只跟踪对指定的动态库内函数的调用。
  * -p PID：附加到某个执行中的进程并执行跟踪。
  * -o output：把跟踪结果输出到指定的文件。

例如，把 ltrace 的 -c 命令获取应用到 ls 命令上，可以获取到类似如下的信息：

    
    
    [root ~]# ltrace -c ps
    % time     seconds  usecs/call     calls      function
    ------ ----------- ----------- --------- --------------------
     50.77    0.033589       33589         1 __libc_start_main
     25.69    0.016994         166       102 readproc
      3.70    0.002447         489         5 bsearch
      2.84    0.001877          72        26 strlen
      2.70    0.001784          81        22 sigaction
      2.57    0.001703          85        20 fwrite
      2.21    0.001459          69        21 strcmp
      0.93    0.000617         154         4 dev_to_tty
      0.93    0.000616          68         9 getenv
      0.87    0.000575          71         8 __snprintf_chk
      0.57    0.000375          93         4 escape_command
      0.54    0.000356          89         4 strcasecmp
    ......
    ------ ----------- ----------- --------- --------------------
    100.00    0.066163                   267 total
    

使用 ltrace 的 -p
选项附加到某个运行中的进程上，就可以监视到该进程的一切库函数调用行为。如果有木马程序在后台悄悄地读取你的敏感文件，利用这个工具就可以暴露出它的一切行踪。如下是使用
-p 选项附加到某个游戏服务器进程后的输出结果：

    
    
    [root ~]# ltrace -p 30318
    pthread_mutex_lock(0xc9fd00, 0xc3b8cf40, 0xc3b8cec0, 0xffffff40 <unfinished ...>
    <... pthread_mutex_lock resumed> )                                               = 0
    pthread_mutex_unlock(0xc9fd00, 0xc9fd68, 0, 1 <unfinished ...>
    <... pthread_mutex_unlock resumed> )                                             = 0
    epoll_wait(8, 0xc3b8cf40, 128, 0xffffffff <unfinished ...>
    <... epoll_wait resumed> )                                                       = 1
    

可以看到，这个服务器进程使用的是 epoll 网络模型，现在正在无所事事地等待着到来的网络消息。

另外，ltrace 也提供了跟踪系统调用的选项 -S，可以跟踪到进程所有的系统调用和返回值。但是，要注意的是，由于 ltrace 工作原理的原因，被
ltrace 跟踪的进程，其执行速度会大大地减慢。如果只想跟踪进程的系统调用，建议使用另外一个在这方面更加专业的程序 strace。

### 3 strace

strace 是一个专门用来追踪用户进程与 Linux 内核之间交互的辅助工具。它的监控目标包括系统调用、向进程发送的信号，以及进程运行状态的变化情况。

strace 提供的参数与 ltrace 很像，比较常用的也是那么几个：

  * -c：统计进程执行的系统调用次数和时间消耗统计信息；
  * -f：以子进程启动指定的可执行文件并执行系统调用跟踪；
  * -p：附加到一个正在执行的进程并执行跟踪；
  * -o：把跟踪结果输出到一个指定的文件。

例如，使用 strace 的 -c 选项统计 ps 命令的输出，会得到类似如下所示的信息：

    
    
    [root ~]# strace -c ps
    % time     seconds  usecs/call     calls    errors syscall
    ------ ----------- ----------- --------- --------- ----------------
     49.15    0.001957           8       235           read
     20.72    0.000825           3       247        12 open
      8.26    0.000329           1       236           close
      7.99    0.000318           3       120         9 stat
      3.77    0.000150          75         2           getdents
      3.31    0.000132           3        42           mprotect
      1.43    0.000057           1        68           mmap
      1.21    0.000048           8         6           munmap
      1.16    0.000046          12         4           readlink
      0.75    0.000030           1        24           rt_sigaction
      0.65    0.000026           5         5           write
     ......
    ------ ----------- ----------- --------- --------- ----------------
    100.00    0.003982                  1039        25 total
    

另外，strace 提供的一个非常有用的选项是 `-e trace=xxx`，可以指定只追踪指定名字或类型的系统调用，如 `-e
trace=open,close,read,write` 表示只跟踪 open、close、read 和 write
这几个系统调用，还有几个内置的分类选项：

  * -e trace=file：跟踪与文件操作有关的系统调用； 
  * -e trace=process：跟踪与进程控制有关的系统调用；
  * -e trace=network：跟踪与网络通信有关的系统调用；
  * -e strace=signal：跟踪与信号处理有关的系统调用；
  * -e trace=ipc：跟踪与进程通讯有关的系统调用。

另一个非常有用的选项是 -i，它能输出系统调用的入口地址，经常被黑客用来确定 hook 对象的内存位置。

    
    
    [root~]# strace -i ps
    [00007f7fcc37d937] execve("/usr/bin/ps", ["ps"], [/* 21 vars */]) = 0
    [00007faa0f367bdc] brk(NULL)            = 0x2396000
    [00007faa0f36890a] mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7faa0f56f000
    [00007faa0f368807] access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
    [00007faa0f3687a7] open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
    [00007faa0f368734] fstat(3, {st_mode=S_IFREG|0644, st_size=42145, ...}) = 0
    [00007faa0f36890a] mmap(NULL, 42145, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7faa0f564000
    [00007faa0f3688b7] close(3)             = 0
    ......
    

### 4 ptrace

其实，不管是 ltrace 还是 strace，都是在一个功能强大的内核函数 ptrace 基础上实现的。ptrace 是一个系统调用，它的函数原型为：

    
    
    #include <sys/ptrace.h>
    long ptrace(enum __ptrace_request request, pid_t pid,
                       void *addr, void *data);
    

这个系统调用使一个进程能够观察和控制另外一个进程的执行，并且可以查看或修改被跟踪的进程的内存和寄存器。 **它最主要的应用场景是实现调试器。**

该系统调用的执行原理是，当有进程调用了 ptrace 系统调用之后，Linux
内核会标记目标进程的状态为被跟踪状态。当进程执行任何系统调用，或者从系统调用中返回，或者接收到信号时，如果内核发现该进程处于被跟踪的状态，它会暂停当前进程的执行，并把控制权交给跟踪进程，这就让跟踪进程有机会查看或修改被跟踪进程执行系统调用时使用的寄存器和内存数据。

在这个系统调用中，第一个参数可以指定多种不同的跟踪选项，常用的跟踪选项有：

  * PTRACE_TRACEME：这个选项用来标记当前进程为可被父进程跟踪的状态，是由子进程主动设置的。ltrace 和 strace 用 -f 选项启动一个可执行文件进行跟踪，就是启动一个子进程，让子进程主动设置 PTRACE_TRACEME 选项，然后用 execv 去执行指定的可执行文件来实现的。这样设置之后，子进程的每次系统调用，以及每次从系统调用返回时，都会被内核暂停，然后把控制权交给父进程，让父进程有机会收集甚至修改子进程的系统调用参数和结果。

  * PTRACE_PEEKUSER：从被跟踪进程的用户空间偏移指定地址的位置读取一个字长的数据。比如，在 x86 CPU 上，当进程执行系统调用时，会用几个固定的寄存器执行参数的传递，而当内核暂停被跟踪进程的执行，并把控制权交给跟踪进程时，跟踪进程只要通过当前寄存器的地址，就能找到执行系统调用时传递的参数。

  * PTRACE_POKEUSER：将 data 参数地址处的一个字长的数据，拷贝到被跟踪进程用户空间偏移 addr 的位置。这个选项使得跟踪进程能够修改被跟踪进程任意位置处的数据。这个选项使得跟踪进程有能力修改被跟踪进程执行系统调用时的真实参数。

  * PTRACE_GETREGS 和 PTRACE_SETREGS：获取和修改被跟踪进程当前的寄存器值。

  * PTRACE_ATTACH：这个选项用来附加到一个正在运行的线程，pid 参数用来指定目标线程 ID。在附加到目标进程之后，跟踪进程会给目标进程发送一个 SIGSTOP 信号，但是使用这个选项的 ptrace 系统调用执行之后，目标进程并不一定会马上停止，跟踪进程应该紧接着使用 waitpid 来等目标线程停下来。

  * PTRACE_DETACH：这个选项执行与 PTRACE_ATTACH 相反的操作，它会结束对目标进程的跟踪，并清理掉目标进程的被跟踪状态。

ptrace 还有其他一些控制选项，比如控制系统调用跟踪的 PTRACE_SYSCALL，恢复进程执行的 PTRACE_CONT
，等等。这个系统调用被设计的主要目的，是为了给用户层实现调试器提供支持，但是因为它强大的功能，它的应用范围远不止调试器。

比如，利用一个进程不能被另外多于一个进程跟踪的特性，有些游戏会使用自己实现的监视线程去启动并附加到游戏逻辑线程，来实现阻止被外部调试破解的效果。有的还会在监视进程与被附加的业务线程之间增加验证逻辑，一旦发现附加的进程不是预期的监视进程，就退出程序的执行，这就更加加大了被动态调试破解的难度。

再比如，代码注入技术，也可以借助 ptrace 系统调用来实现。使用 PTRACE_POKEUSER
选项，就可以把一段自己的可执行程序，拷贝到目标进程的地址空间内，只要拷贝的目标地址计算精确无误，就可以实现不影响目标进程正常运行的情况下，让目标进程执行一段额外的代码。这段额外的代码可以是出于调试目的增加的追踪信息，也可以是一个小木马，或者恶意病毒。

其他方面的应用，就希望读者自己去发现、挖掘。也欢迎广大读者在课程交流群自由讨论，共同进步。

### 5 总结

在本节课中，我们 **介绍了 Linux 中跟踪系统事件的两个功能强大的工具 ltrace 和
strace，这两个工具是分析进程执行流程和性能数据统计的利器** 。

另外，还 **介绍了这两个工具依赖的底层系统调用 ptrace，这是个功能异常强大的系统调用** ，熟练掌握
ptrace，是进阶到高级别系统开发者的必经之路。

