进程隐藏技术在主机和网络安全领域有很实用的应用。

比如，对红方，安全人员会在蜜罐系统上隐藏一些敏感进程，防止引起入侵者的警觉；对黑方，有些木马程序会使用进程隐藏技术让自己躲过系统管理人员的排查和监控，从而让自己能不被察觉地在被攻击系统上长期运行。

前者对自己的系统有完全的控制权，所以，采用修改 Linux
内核，增加进程隐藏机制的方式就可以很干净地实现；而后者，因为要尽量隐蔽自己的行踪，所以通常不会直接修改 Linux 内核，而是会采用加载附加的内核模块，或者
hook 并修改系统调用结果的方式来实现。

在本节中，我会 **对以上多种进程隐藏技术做原理性介绍，并针对那些恶意隐藏技术，讨论相应的防范措施** ，主要包括以下几方面内容：

  * 红方进程隐藏技术
  * 黑方进程隐藏技术
  * 反进程隐藏措施

### 1 概述

在 Linux 中，系统管理员通常会使用 top 或 ps 命令，查看当前正在运行的进程的资源占用和运行状态。而进程隐藏技术的预期效果，就是
**让指定进程的信息不显示在 top 或 ps 命令的输出中，从而使其不被他人查看到** 。

在《第 17 课：深入虚拟文件系统，文件哲学的延伸》一节中，我们介绍过，Linux 会为所有运行的进程在 /proc
目录下创建对应的目录树，从中可以获取到很多关于进程运行状态的信息。系统管理常用的 top 和 ps 命令，就是从 /proc 目录读取进程信息并显示。

所以， **进程隐藏技术，一个可行的思路，就是篡改系统对 /proc 目录的读取结果，或者直接修改 /proc 目录本身**
。下面讨论的技术，都围绕这个中心展开的。

### 2 红方进程隐藏技术

所谓的红方，指的是以保护系统安全为目的而采取各种措施的一方，是相对于非法入侵他人系统的黑方来说的。

红方实现进程隐藏通常有两种方式：

  * 一种是使用 Linux 中对内核有保护作用的加固选项，来隔离系统中的多个用户；
  * 另一种是修改内核，从最底层增加进程隐藏机制。

#### 2.1 Linux 加固选项

Linux 是一个多用户操作系统，出于安全方面的考虑，有时不希望普通用户看到其他用户正在运行的进程。针对这种需求，Linux 从内核版本 3.2（或
RHLE/CentOS 6.5）开始，提供了一个叫做 hidepid 的加固选项，只要使用这个选项挂载 proc 文件系统，就可以使非 root
用户只能看到自己启动的进程。

使用的挂载命令如下：

    
    
    mount -o remount,rw,hidepid=2 /proc
    

也可以把 proc 文件系统的加载选项添加到 /etc/fstab 中：

    
    
    proc /proc proc defaults,hidepid=2 0 0
    

hidepid 选项的取值可以有三种。

  * 0：默认值，表示不对普通用户隐藏任何进程信息，所有用户都可查看到当前系统中运行的所有进程，而且，所有用户都可以访问 /proc 目录，只要某个目录项和文件对 other 组开放了读权限。

  * 1：表示普通用户使用 ps 和 top 命令查看不到其他用户正在运行的进程，也不能进入其他用户的进程的 /proc/PID 目录，但是可以在 /proc 目录下看到其他用户启动的进程的进程 ID。

  * 2：表示任何普通用户都没有权限进入 /proc 目录查看任何信息，只能通过 top 或 ps 命令来查看，而且这两个命令的结果里面，也不会包含其他用户启动的任何进程信息。

#### 2.2 修改内核实现进程隐藏

Linux 的加固选项只能用于在正常系统上管理正常用户。而对于专门为入侵者准备的蜜罐系统，它就远远不能满足要求了，因为即使开启了加固选项，root
用户还是可以查看到所有用户的所有进程。而入侵者在攻下系统之后，往往能够成功获取到系统的 root 权限。

所谓的蜜罐系统，是安全人员故意给攻击方准备的一些诱饵主机，一方面故意暴露出来诱骗攻击者对其实施攻击，另一方面，在攻击者攻下蜜罐系统之后，不让他发觉自己落入了蜜罐之内，而是让他以为自己已经成功攻下了进攻目标，从而可以对其实施行为记录和分析，甚至反向追踪到进攻者。

为了实施行为记录或反向追踪，蜜罐系统上需要运行某些服务进程，对 root 用户也不显示，以防止引起进攻者的警觉。

**因为蜜罐系统的部署人员，对系统拥有完全的控制权，所以，可以采用修改内核的方式，给某些特殊进程增加特殊的处理逻辑，实现隐藏的目的** 。

**具体的实现方式，也是围绕着 proc 文件系统做文章** 。我们已经知道，内核会为每个运行中的进程在 /proc
目录下创建相应的目录项，记录各种运行状态信息。top 和 ps 命令，也是靠读取 /proc
目录下的进程信息来工作的。所以，在内核中，只要让某个满足条件的进程不在 /proc 下创建目录项，就可以实现比较彻底的隐藏了。

网上已经有人通过增加 Hide 信号的方式，在内核中支持了进程的主动隐藏。 **这种技术实现的关键点在于，找到内核为进程创建 proc
目录项的位置，跳过某些满足条件的进程，详情可以访问：**

> <https://blog.csdn.net/billpig/article/details/6038330>

在蜜罐系统上，只要使用修改后的内核，让监控和记录进程在 proc 目录下不创建任何包含进程信息的目录项，就可以实现进程的隐藏，从而躲过进攻者的注意了。

### 3 黑方进程隐藏技术

对黑方来说，隐藏进程的目的在于，在被攻破的系统上放置自己需要的后门或恶意程序，他们放置的程序肯定不希望被系统管理员看到，从而实现长时间隐蔽运行的目的。

**黑方隐藏进程的主要实现思路也是围绕 /proc 目录展开的**
。因为进攻方希望尽量隐藏自己的行踪，所以通常不会采用更换系统内核的方式，也因此很难做到如蜜罐系统一样，直接屏蔽进程在 /proc 目录下创建目录项的行为。
**它们通常会采用对 /proc 目录的读取结果执行附加处理的方式，达到隐藏特定进程的目的** 。

而修改 /proc 目录读取结果的时机，可以选择在内核层，也可以选在用户态应用层。下面分别讨论。

#### 3.1 内核层修改 /proc 目录读取结果

读取目录项的系统调用是 getdents，在内核中对应的函数为 sys_getdents，函数原型为：

    
    
    long sys_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count);
    

其中：

  * fd 为指向目录文件的文件描述符；
  * dirent 是存放读取到的目录项数据的缓存地址；
  * count 是 dirent 指向的数据缓冲区的字节长度。

该函数成功执行时，会返回读到的数据的字节数。

所以，如果能定位到系统调用函数表，找到 sys_getdents 函数的对应项，把该函数替换为修改后的 getdents
函数，在替换后的函数中，把要隐藏的进程的信息移除，就能实现进程隐藏的效果了。

**以上的逻辑要付诸实施，需要把代码编译成内核模块并加载，在模块初始化函数中执行系统调用表的替换就可以了。**

在一些较新的系统上，系统调用表所在内存是写保护的，所以在执行替换时，还需要首先解除对应区域的写保护，并在修改之后恢复。具体的修改方法，请读者自行查找相关资料。另外，在
64 位系统上，对应的系统调用是 64 位版本 sys_getdents64。

#### 3.2 用户态修改 /proc 目录读取结果

在用户态，进程是不能获取和修改内核中的系统调用表的，所以，就需要想办法修改 ps 和 top 命令的输出结果。

最简单粗暴的方法，就是直接用修改过的 ps 和 top 可执行文件替换掉原始的文件。而 **技术含量更高一点的做法，则是动态地替换系统的库函数**
。下面主要讨论后一种做法。

ps 和 top 命令，在读取 /proc 目录内容的时候，都用了库函数 readdir，其函数原型为：

    
    
    struct dirent *readdir(DIR *dirp);
    int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);
    

后者是多线程安全版本。

只要能替换这两个库函数的实现，使其从查询结果中删除掉要隐藏的进程的相关记录，就可以实现在 ps 和 top 命令的输出中隐藏目标进程的效果。但是，
**在这种实现方式下，/proc 目录下目标进程的目录项是隐藏不掉的** 。

那么，如何替换这个函数呢？

**Linux 提供了一种动态链接库预加载机制，使用该机制，用户可以在可执行程序运行之前先预加载用户自定义的动态链接库** 。因为 libc
运行库里面的函数，都是定义为弱符号（week）的，所以，如果用户在预加载的动态链接库里面，定义了函数签名与某个库函数一模一样的函数，那么库函数就会被自定义的函数所代替。

动态链接库预加载机制使用起来非常简单，只要在环境变量 LD_PRELOAD 或在 /etc/ld.so.preload
文件中指定需要预加载的链接库文件，系统就会在启动任何可执行文件之前，首先加载指定的动态链接库。

在区块链技术大热的 2018 年，就有很多系统被黑客暗中植入了挖矿程序，而这些程序的隐藏手段，就是用了 Linux 的预加载机制，通过修改
ld.so.preload 文件指向自己提供的包含替换掉的 readdir 函数的动态链接库，把自己的挖矿进程隐藏起来。

### 4 反进程隐藏措施

知道了进程隐藏自身的方式，也就不难想出相应的应对措施了。

围绕 /proc 目录做文章的用户态进程隐藏技术，不可避免地需要对系统做出一些更改：

  * 或者需要加载额外的内核模块；
  * 或者需要替换可执行文件；
  * 或者需要修改 LD_PRELOAD 变量或 ld.so.preload 文件。

所以， **首先** ，在生产环境下运行的服务器上，对任何的内核模块添加行为，都应该发出预警通知。

**其次** ，对几个比较敏感的目录（如 /usr/bin/、/usr/sbin 和 /etc/ 目录）执行文件变化监控，是很有必要的。

**另外** ，管理员还可以准备一套自己编写的 ls、top 和 ps 程序，在实现读取目录内容的功能时，不使用标准库函数，而是直接使用 getdents
或 getdents64 系统调用，这样做也可以在一定程度上提高发现可疑进程的能力，毕竟在内核上做修改的难度还是要稍微大一些。

### 5 总结

入侵与反入侵技术自计算机诞生以来就一直在相互的较量中不断演化，进程隐藏技术作为黑客技术中一个非常小的分支，也经历了长期的变化过程。

本节课所介绍的进程隐藏技术，仅仅是众多技术中的冰山一角，比如还有下面这些进程隐藏技术：

  * 利用 bash 的功能修改显示的进程名；
  * 利用几个长得很像的数字和字母，把自己伪装成正常进程；
  * 利用 ptrace 或病毒技术感染其他进程，使得自己的逻辑附加到其他进程上去执行；
  * ……

**本节课的目的在于向读者展示 Linux 系统调用的一个实际应用领域** ，希望通过该简单展示，能帮读者 **深化对某些编程知识点的理解** ，
**认识到深入理解系统底层的强大力量** ，并引起读者对于系统安全更深层次的思考。

也希望读者以本节课的内容为主题，结合《第 16
课：监控文件系统，谁动了我的文件》一节中关于文件系统监控的内容，尝试实现一个简单的能发现可疑的应用层进程隐藏行为的监控程序。

