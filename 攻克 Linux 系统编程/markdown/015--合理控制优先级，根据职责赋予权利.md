Linux 是一个多用户多任务的操作系统，即使是在单核心 CPU
的系统上，用户也感觉系统中的多个进程在同时运行。实际上，内核使用的是一套固定的调度策略，多个进程轮流使用
CPU，并快速地轮流切换。但是，对于不同功能的进程，它们的任务优先级和对实时性的要求是不一样的，有什么办法能控制进程这一行为呢？

在本节课中，我们就来介绍一下 Linux
中影响进程被内核调度的参数，并介绍控制这些参数的系统调用及它们的使用方法。深入理解它们的作用和底层的实现机理，能帮助开发者更加合理地控制和分配不同功能的进程的权责，主要包括以下几方面内容：

  * 普通进程优先级
  * 实时进程优先级
  * 进程的 CPU 亲和力

### 1 普通进程优先级

如果没有特别指定，在 Linux 中创建的进程都是普通进程，它们在内核中是 **以时间片轮转的方式** 被依次调度的。

更具体地说，如果一个运行中的进程发生了以下任意一种情况，内核会把它暂时调度出 CPU，转而调入其他符合运行条件的进程继续执行：

  * 进程自己主动休眠（如主动调用 sleep）；
  * 进程因为执行了阻塞的 I/O 操作，而需要等待慢速的 I/O 完成；
  * 进程已经用光了当前分配给自己的时间片。

**默认情况下，所有进程都会被分配相同长度的时间片** ，所以，长期来看，抛开进程自己主动休眠和调用阻塞 I/O 的部分，每个进程能获得的 CPU
总时间是差不多的。

有时候，这样的默认行为不能满足我们的要求。比如，如果一个进程执行的计算工作特别重要，我们希望这个进程能被分配更多的执行时间，大多数对用户提供应用功能的进程都会有这样的需求；再或者，我们希望某个进程只有在系统空闲下来的时候才去执行，比如提供内部数据审计功能的验证进程。这时候，我们应该如何去做呢？

#### 1.1 Nice 值概述

实际上，Linux 开发人员经常使用的 top 命令的输出中，就包含 **进程的优先级信息** ，如下所示：

    
    
       PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
      2814 mongod    20   0  976948  41976   5868 S   0.7  2.2   1:20.21 mongod
      4022 root      20   0  157788   2332   1584 R   0.3  0.1   0:11.63 top
         1 root      20   0  190920   3892   2452 S   0.0  0.2   0:02.39 systemd
         2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd
         3 root      20   0       0      0      0 S   0.0  0.0   0:00.12 ksoftirqd/0
         5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H
         7 root      rt   0       0      0      0 S   0.0  0.0   0:00.06 migration/0
    

其中：

  * PR 列标识进程的优先级（Priority）
  * NI 列表示进程的 Nice 值

**这两个值的数值越小，表示要求获得的 CPU 时间越多。**

对于优先级为数字的进程来说，PR 与 NI 的值总是对应的，PR 的取值范围为 0 — 39，而 NI 的取值范围为 -20 — 19，PR 的值总是等于
20 + NI。

Nice 在英文中是“和善”的意思，这里进程的 Nice 值，也表示进程的和善程度，Nice 值越高就越和善，越和善的进程，越不会与别的进程争抢 CPU
资源。

在内核的实现中， **Nice 值是内核考虑调度哪个普通进程的一个权重因素** 。Nice 值越高的进程，被分配到的总运行时间片就会越短；相反，Nice
值越低，就表示该进程希望能得到更多的 CPU 资源。

#### 1.2 控制进程的优先级

Linux 提供的修改和查看进程优先级的系统调用分别为：

    
    
    int setpriority(int which, id_t who, int prio);
    int getpriority(int which, id_t who);
    

其中，which 和 who 参数联合指定要操作的进程或进程组（详情请参考帮助手册），setpriority() 中的参数 prio 和
getpriority() 的返回值都是操作目标的 Nice 值。

因为 Nice 值可以是负数，所以， **使用 getpriority() 系统调用之前需要先把 errno 显式设置为 0** ，如果返回值为负数，再联合
errno 区分是遇到错误，还是目标的 Nice 值本身就是负值。

#### 1.3 调整优先级的限制

系统对进程的优先级调整，会施加一定的限制条件，防止被进程滥用。

在 2.6.12 版本之后的 Linux 中， **特权进程能够自由地修改任意进程的优先级**
；而非特权进程只能修改自身，或者同一个有效用户启动的其他进程，并且修改的幅度会受到系统限制的制约。

**ulimit 命令的 -e 选项可以查看当前允许的调整范围** ，它的值表示优先级提高的上限，若限制值为 LIMIT_N，则表示 Nice
值降低（优先级提高）时，能减少到的最小值为 20 - LIMIT_N。

    
    
    [root]# ulimit -a
    ...
    scheduling priority             (-e) 0
    ...
    

**默认的限制值是 0** ，也就是说不允许非特权进程提高进程的优先级，而只能降低。当这个值大于
20（默认优先级）时，表示非特权进程能够把自身或相同有效用户的进程的 Nice 值调整为负值。

#### 1.4 调整优先级的应用

利用优先级调整的功能，开发者就可以 **根据不同服务的功能特性，合理分配它们的运行优先级** 。

例如，在服务器开发中，经常会有一种内部审计的进程或线程，负责在后台执行一些数据完整性的检查，并在发现错误时报告一些错误信息，提醒开发或运营人员的注意。这种服务的运行不应该抢占对外提供服务的进程的运行资源。这时，就可以把它的运行优先级降到最低，比如，把
Nice 值设置为 19。

再比如，如果查看 Android 平台上一些游戏的主线程，会发现其 Nice 值为负值，表示游戏进程希望获得尽可能多的 CPU
资源，以尽量保证游戏过程的流畅。

在上面 top 命令的输出中，也可以找到一个 Nice 值为 -20 的进程 kworker，这是 Linux 的内核工作队列的工作线程。

### 2 实时进程优先级

#### 2.1 实时进程概述

普通进程的 Nice 值，只是一个影响内核进行进程调度的权重因子，它能影响内核选择让哪个进程获得 CPU
的偏向程度，但是不能完全保证调度的延迟时间，更不能精确控制调度的顺序，但有一些实时应用却可能对这些有更严格的要求。为了
**满足这些实时应用的调度需求，Linux 提供了专用的系统调用来控制实时进程的调度策略和优先级** 。

Linux 中有两种比较常用的实时调度策略，分别是：

  * SCHED_RR（Round-Robin 循环）
  * SCHED_FIFO（先入先出）

使用这两种调度策略的进程都可以在 99 个实时优先级中选择， **其取值从 1（最低）到 99（最高）** ，内核会为每个优先级维护一个任务队列。

  * **SCHED_RR 调度策略** 为每个进程都分配一个固定长度的时间片，如果有优先级相同的进程，它们会以循环时间分享的形式交替执行，一个运行的进程使用完时间片或者自己主动放弃 CPU 时，会被放置到同优先级队列的队尾。

  * **SCHED_FIFO 调度策略** 没有为进程分配时间片，一个进程一旦获得运行权，就会一直运行，直到终止，或者自己主动放弃 CPU。

另外，这两种调度策略的进程，都可以被更高优先级的实时进程所抢占。
**这也是实时性的一个表现方面，即具有严格的执行顺序规则，高优先级的进程总是会被优先服务**
。当抢先执行的高优先级实时进程运行结束之后，被抢占的进程会继续执行。

#### 2.2 实时进程调度的参数控制

设置或修改实时进程调度策略和优先级的系统调用是：

    
    
    int sched_setscheduler(pid_t pid, int policy, const struct sched_param * param);
    

主要参数的含义和取值，请见下面说明。

  * **pid 指定目标进程 ID** ，如果为 0，表示修改调用进程。
  * **policy 参数指定进程采用的调度策略** ，如果决定采用实时调度策略，则可以取值 SCHED_RR、SCHED_FIFO；如果希望采用非实时的普通调度策略，则也可设置为 SCHED_OTHER（普通时间片轮转调度）、SCHED_BATCH（适用于批处理的进程）、SCHED_IDLE（比最大的 Nice 值的运行优先级还要低的后台进程）。

**sched_param 结构定义了一个包含调度优先级的参数** ：

    
    
    struct sched_param {
        int sched_priority;
    };
    

如果只需要修改实时进程的优先级，而不需要修改使用的调度策略，还可以使用一个更简单的系统调用：

    
    
    int sched_setparam(pid_t pid, const struct sched_param * param);
    

此外，Linux 还提供了一个让调用进程能主动放弃 CPU 的系统调用：

    
    
    int sched_yield(void);
    

该系统调用会把调用进程移动到同优先级队列的队尾，从而主动让出 CPU，让同优先级的其他进程有机会运行。如果在同优先级队列里面没有其他可运行的进程，那么
sched_yield 会什么也不做，调用进程会继续执行。

#### 2.3 实时策略的调整限制

**对实时进程来说，优先级较高的可运行进程总是会优先于优先级较低的进程**
。也就是说，只要有高优先级的实时进程满足运行条件，低优先级实时进程就会一直没有机会运行，直到高优先级进程运行完毕，或者主动放弃运行时机。

而且，采用实时策略的进程的优先级要高于采用时间片轮转调度策略的普通进程。所以， **规划实时进程时要特别小心** ，如果系统中的 CPU
核心都被实时进程占据了，而所有的实时进程都在忙碌，而不主动放弃 CPU 资源，会导致系统内的普通进程饿死，更严重的，可能会导致系统假死。

也正因为对实时进程的不合理使用会导致这样严重的后果，在 Linux 中 **引入了一个软限制来控制对实时调度参数的设置** ：

    
    
    [root]# ulimit -a
    ...
    real-time priority              (-r) 0
    ...
    

默认情况下，实时优先级的软限制参数被设置为
0，表示只有特权进程才能随意修改进程的实时调度策略和优先级，而非特权进程只能降低自身的优先级，或者把调度策略从实时修改为非实时。如果该软限制设置为
N，那么非特权进程也可以修改实时调度策略和优先级，但是优先级最大不能超过 N。

#### 2.4 实时进程的应用

对大多数的应用来说，通过使用普通进程，并调整 Nice 值就可以实现功能上的设计目的， **只有系统中对时效性有特殊要求的服务进程才会采用实时调度策略**
。

例如，本文最开始的 top 命令的输出示例中，就有一个采用实时调度策略的服务进程：

    
    
    7 root      rt   0       0      0      0 S   0.0  0.0   0:00.06 migration/0
    

其中 PR 列中的 rt 标志，就标识该进程采用的是实时调度策略，对于实时进程来说，NI 值是无效的。

Linux 中的 migration 进程是一个在多个 CPU 之间执行负载均衡的服务进程，它会在必要的时候把在一个 CPU
上运行的进程迁移到相对空闲的其他 CPU 上，迁移过程可以在被迁移的进程运行过程中进行。另外，在每个 CPU
上执行的看门狗进程（watchdog），也是使用实时调度策略的例子。

### 3 进程的 CPU 亲和力

不管是普通进程还是实时进程，它们在被内核调入调出 CPU 的时候，都不能保证总是在一个固定的 CPU 上执行。

比如，如果之前的 CPU 特别忙，而另外一个 CPU 当前特别空闲，那么迁移程序可能会把这个进程迁移到空闲的 CPU
上，以达到动态负载均衡的目的。在大多数情况下，这样的动态迁移都不会造成任何问题，除非整个系统对任何可能产生的性能问题都特别敏感。

**进程在 CPU 之间迁移时产生的性能影响主要来源于对 CPU 的高速缓存中数据的处理** 。如果进程在原来的 CPU
上运行时，对高速缓冲器的数据产生过更新，那么在切换到新的 CPU
之前，必须使高速缓冲器中的数据失效并重新写入内存，这个过程会产生额外的性能消耗。所以，如果能尽可能地减少进程在 CPU
之间的迁移，就能一定程度上提高系统的整体性能。

为此， **Linux 提供了设置进程的 CPU 亲和力的系统调用** ：

    
    
    int sched_setaffinity(pid_t pid, size_t len, cpu_set_t * set);
    

其中：

  * cpu_set_t 是一个位掩码结构，能够指定目标进程可以运行的 CPU；
  * len 参数指定使用的 CPU 位掩码数据结构的字节数。

在 CPU 位掩码结构中，对 CPU 的编号是从 0 开始的，比如一个 16 核的 CPU，其 CPU 核心的编号分别为 0 — 15。

对 cpu_set_t 数据的操作有如下几个支持宏：

    
    
    void CPU_ZERO(cpu_set_t *set);           //把 CPU 位掩码 set 初始化为 0
    void CPU_SET(int cpu, cpu_set_t *set);   //将指定编号的 CPU 添加到位掩码 set 中
    void CPU_CLR(int cpu, cpu_set_t *set);   //将指定编号的 CPU 从位掩码 set 中删除
    void CPU_ISSET(int cpu, cpu_set_t *set); //检查指定编号的 CPU 在位掩码 set 中是否存在
    

#### 3.1 CPU 亲和力的应用

CPU 亲和力的控制单位是线程，Linux 上的应用可以用它来实现对进程使用的 CPU
核心的精细控制，从而有可能让整个系统达到更优化的性能。只有开发人员最了解自己的程序， **通过精细地控制每个线程的 CPU
亲和力，可以在以下几个方面获得性能提升** 。

  * 如果一个进程内有多个线程需要经常访问同样的数据，那么把它们绑定在同一个 CPU 上能带来性能的提升。因为如果它们在不同的 CPU 上运行，就需要经常执行这样的操作：把 CPU 高速缓冲器中的数据更新到内存，并在另一个 CPU 上从内存重新加载到高速缓冲器。
  * 如果有两个线程都是 CPU 计算密集的，而且都需要经常使用不同的数据，那把它们分别绑定在不同的 CPU 核心上，也会因为能够重复使用高速缓冲器内的数据而带来整体性能的提升。
  * 如果系统中存在关键功能的进程，专门给它们预留一个或几个 CPU，而把其他的所有进程都限制在别的 CPU 上，能提高系统在各种极端状况下的可用性。

### 4 总结

在本节课中，我们介绍了 Linux 所提供的可 **精细控制系统如何为进程分配 CPU 的多个系统调用** ，包括如何调整进程的 Nice
值，以及该调整对进程可获得的 CPU 时间的影响。

还介绍了不同于普通进程的 **实时进程调度策略** ，以及对它们的控制方法。

最后，介绍了 **如何精细地控制进程使用哪几个 CPU** ，并 **列举了这种精细控制可能实现的优化效果**
。相信通过本节课的学习，读者们对自己编写的应用的控制能力可以再上一个新的高度。

