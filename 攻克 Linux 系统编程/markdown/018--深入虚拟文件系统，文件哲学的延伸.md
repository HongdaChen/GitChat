特殊文件系统，指的是在磁盘上没有对应的存储数据的文件系统，这其中最常见的，要属记录进程和内核运行参数的 proc 文件系统。

在本节课中，我们就来 **详细讨论一下 proc 文件系统** ， **包括其中几个常用文件所包含的信息及可能的使用场景** ，主要包括以下几方面内容：

  * proc 文件系统概述
  * proc 文件系统详解
  * 注意事项

### 1 proc 文件系统概述

在 Linux
的内核中，虚拟文件系统转换层（VFS）的存在，使得各种不同种类的文件都可以通过一组统一的系统调用来处理，其中不仅包括保存在不同格式的文件系统上的磁盘文件，还包括各种不同种类的外部设备，以及进程信息和多种内核参数，等等。

特殊文件系统中的文件，其特殊之处在于， **它们的信息并不是保存在外部物理存储设备上的，而是在收到读取请求的时候才由内核动态生成的** 。

proc 文件系统提供了一些内核中各个子系统的信息，它使得在用户空间简单地使用 cat 和 each 命令，或者 read 和 write
系统调用就可以获得内核各子系统的信息，比如 CPU
型号和参数、内存使用量、可用的定时硬件及详细参数、连接的外部设备及映射地址，等等，还可以在系统运行时动态修改内核参数，而不需要重新编译内核的源代码。

  * **在 proc 文件系统引入之前** ，当需要获取或修改某些内核属性时，需要编写专门的特权级程序，并需要深入到内核内存中去操作特定的数据结构。这需要开发者具有专业的内核知识，而且这种做法对内核来说并不安全，增加了外部程序破坏内核稳定性的风险。同时，内核数据结构也会随着版本的演进而发生改变，导致依赖特定数据结构的上层应用也需要做相应的修改。

  * **有了 proc 文件系统之后** ，上层应用就可以使用统一的 read 或 write 系统调用来完成读取或修改内核数据的工作了，不仅增加了应用的可读性和可维护性，同时也降低了内核稳定性被应用程序破坏的风险。

依靠目前的 proc 文件系统， **一个特权进程可以很容易地获取到诸如下面的内核信息。**

  * 当前系统有多少个进程在运行？
  * 每个进程打开了哪些文件？
  * 每个进程当前占用了多少内存？曾经的内存使用最高水位线是多少？
  * 每个进程启动了几个线程？每个线程当前的运行状态是怎样的？
  * 系统自启动之后发生了多少何种类型的中断？

同时， **一个普通进程也可以很容易地获取到当前进程的一些内核数据** ，比如：

  * 本进程启动的线程有哪些？
  * 各线程当前的状态是什么？
  * 每个进程分别用了多大的内存？
  * 当前进程使用的动态链接库，各自被映射的虚拟地址是多少？

### 2 proc 文件系统详解

proc 文件系统的挂载点是
/proc，它最早设计用于提供进程运行时的信息，比如进程的运行状态、进程当前打开的文件、创建的套接字、虚拟内存的排布等，这也是它名字的由来（Process
Data Filesystem）。后来，很多系统级的内核信息也被加入进来，如中断信息、设备映射信息、内存状态，等等。

下面对 /proc 目录下几个常用文件的内容，以及它们的使用场景做详细说明。

#### 2.1 /proc/cpuinfo

**该文件包含了当前系统 CPU 的参数信息** ，包括 CPU
的核心数量、每个核心的工作频率、缓存大小、字宽、地址线长度等。比如，在我的个人电脑上，cat /proc/cpuinfo 显示的部分信息如下：

    
    
    [root]# cat /proc/cpuinfo
    processor       : 0
    vendor_id       : GenuineIntel
    cpu family      : 6
    model           : 69
    model name      : Intel(R) Core(TM) i5-4210U CPU @ 1.70GHz
    cpu MHz         : 2400.985
    cache size      : 3072 KB
    physical id     : 0
    cache_alignment : 64
    address sizes   : 42 bits physical, 48 bits virtual
    

可以看到，我电脑上的 CPU 是 Intel 的低电压版单核 64 位 CPU，工作频率 2.4G HZ，高速缓存 3 MB。同时还能看到，这个 CPU
最高支持 42 位的物理地址总线和 48 位的虚拟地址总线，所以，能支持的最大物理内存是 4 TB，进程的虚拟地址空间最大可以扩展到 256
TB。这也是为什么 64 位的 Linux 要给内核和应用各分配 128 TB 的虚拟地址空间。

#### 2.2 /proc/meminfo

**这个文件显示的是系统中当前的内存状态信息** ，如物理内存总容量、已使用内存、空闲内存、共享内存、交换内存大小，等等。

在日常的开发工作中，开发者通常更偏向于通过 top 命令的输出，查看系统当前的内存使用状况，因为大多数时候，只关心内存的总量和当前的占用量就足够了。

但是 **在某些特殊情况下，还是需要参考这个文件中提供的更加详细的内存状态信息** ，如 slab
内存占用量（记录在一个页框中如何划分和分配小存储区用的内存）、可回收内存量（SReclaimable）、内核栈空间大小（Kernel Stack）、使用
malloc 分配的堆内存总量，以及使用 mmap 映射的内存总量，等等。

#### 2.3 /proc/kallsyms

**该文件是一个符号表，包含了内核的所有全局变量和函数在内存中的地址。**

**这是一个帮助内核开发者调试内核而加入的文件** ，在 Linux 系统崩溃时产生的 Opps
信息中，函数调用堆栈中显示出来的函数名，就是在这个文件的帮助下生成的。

#### 2.4 /proc/kcore

**这个文件是一个动态的内核文件，里面包含了内核在主内存中的全部内容** 。

可以把调试器附加到这个文件上，来查看运行中的系统的当前状态，与使用 core dump 文件调试崩溃的应用程序是一个道理。

#### 2.5 /proc/interrupts

**该文件包含了系统记录的在每个 CPU 上处理的各类中断的计数信息** 。

在 Linux 中，如果没有特殊的处理，通常所有的中断都会交给 CPU 的第一个核心（CPU0）来处理。有一个叫做 Irqbalance
的实用程序可以帮助系统把中断分发给不同的 CPU，实现负载均衡，对多核处理器的性能提升和控制能耗都有明显的作用。

当前的大多数 Linux 发行版都会默认在多核处理器上启动这个服务，但是以防万一，读者可以在自己的系统上确认该服务是否开启，同时通过检查
/proc/interrupts 文件来确定中断是不是均衡地分发到了不同的 CPU 上。

#### 2.6 /proc/loadavg

**这个文件显示系统在过去一段时间的平均负载** ，一个真实的输出如下所示：

    
    
    [root]# cat /proc/loadavg
    0.03 0.07 0.06 2/171 28700
    

从左到右每一列分别显示了：

  * 过去一分钟的系统平均负载
  * 过去五分钟的系统平均负载
  * 过去十五分钟的系统平均负载
  * 采样时刻运行队列的任务数/系统中活跃的总任务数
  * 采样时刻占用最大的线程 ID

**这个文件的输出中的前三个值，经常被用来观察系统负载的发展趋势**
。如果前面的值比后面的值小，说明系统的负载在减轻；反之，说明系统负载开始呈现出上升的趋势。

#### 2.7 /proc/PID/

**这是包含各进程运行信息的目录** ，系统会为每个进程都维护一个以进程 ID
命名的目录，在该目录下保存该进程运行时的各种状态数据，如运行状态（status）、虚拟内存映射信息（maps）、打开的所有文件描述符（fd
目录）、创建的所有网络套接字、开启的所有线程（task 目录），等等。

其中使用比较多的，应该是虚拟内存映射信息。例如，一个 shell 进程的虚拟内存映射信息输出片段为：

    
    
    [root]# cat /proc/self/maps
    00400000-0040b000 r-xp 00000000 fd:00 122637                             /usr/bin/cat
    0060b000-0060c000 r--p 0000b000 fd:00 122637                             /usr/bin/cat
    0060c000-0060d000 rw-p 0000c000 fd:00 122637                             /usr/bin/cat
    00733000-00754000 rw-p 00000000 00:00 0                                  [heap]
    7fe9d3f29000-7fe9d40eb000 r-xp 00000000 fd:00 33720126                   /usr/lib64/libc-2.17.so
    7fe9d40eb000-7fe9d42eb000 ---p 001c2000 fd:00 33720126                   /usr/lib64/libc-2.17.so
    7fe9d42eb000-7fe9d42ef000 r--p 001c2000 fd:00 33720126                   /usr/lib64/libc-2.17.so
    7fe9d42ef000-7fe9d42f1000 rw-p 001c6000 fd:00 33720126                   /usr/lib64/libc-2.17.so
    7fe9d42f1000-7fe9d42f6000 rw-p 00000000 00:00 0
    7fe9d42f6000-7fe9d4318000 r-xp 00000000 fd:00 33720119                   /usr/lib64/ld-2.17.so
    7fe9d44ea000-7fe9d44ed000 rw-p 00000000 00:00 0
    7fe9d4516000-7fe9d4517000 rw-p 00000000 00:00 0
    7fe9d4517000-7fe9d4518000 r--p 00021000 fd:00 33720119                   /usr/lib64/ld-2.17.so
    7fe9d4518000-7fe9d4519000 rw-p 00022000 fd:00 33720119                   /usr/lib64/ld-2.17.so
    7fe9d4519000-7fe9d451a000 rw-p 00000000 00:00 0
    7ffc7e78a000-7ffc7e7ab000 rw-p 00000000 00:00 0                          [stack]
    

在分析程序的崩溃堆栈时，有时就需要对照这个映射信息定位代码或者变量地址所在的库。

在 hook 其他程序的库函数时，也会需要用到这个映射关系：

  * 先找到某个库函数在自身的虚拟内存中的地址，根据映射信息计算相对库加载地址的偏移；
  * 然后查找目标进程的库加载地址，使用之前计算出的偏移量，找到要 hook 的库函数在目标进程的加载地址。

在 /proc/PID/task 目录下，会有一个或多个以线程 ID 命名的子目录，每个目录都包含了与 /proc/PID 目录相似的目录结构，其中就记录了
PID 进程开启的每个线程的详细信息，在这里可以查看比如某个特定线程当前的运行状态、绑定的 CPU 核心，等等。

#### 2.8 /proc/net/

**该目录提供了内核各种网络数据的统计信息** 。最常用的 /proc/net/dev
保存了通过各网络接口传输的数据的统计量，包括出错和冲突的数据包的数量，经常用它来查看网络流量和检查网络传输质量。

另外，Unix、udp 和 tcp 这几个文件分别提供了本地、UDP 和 TCP 套接字的统计数据，arp 文件记录了反向地址解析表。

### 3 注意事项

proc 文件系统的功能虽然强大，但是随着内核功能的增加，被加到 /proc 目录下的文件类别也越来越多，有些类别与其他类别只有非常少的共有特征。

**当前的内核开发趋势，越来越倾向于不再继续在 /proc 下增加功能，而是使用其他更加针对特定问题的解决方案** ，比如提供了更加层次化视图的
sysfs。

### 4 总结

特殊文件系统的存在，使得 Linux 对内核数据的查看和修改具有简单到极致的接口，同时又不失强大而灵活的功能。

除了 proc 文件系统之外，Linux 还实现了多种其他功能的特殊文件系统，例如：

  * 在内存上的简单文件系统 tmpfs，使用它可以优化应用对临时文件的读写性能；
  * 负责管理系统中网络套接字的 sockfs；
  * 管理管道的 pipefs；
  * 从内核向应用层导出结构化信息的 sysfs；
  * ……

它们都是 Linux 文件哲学的体现和延伸。

通过学习本节课，希望读者能 **丰富关于 proc 文件系统的知识，掌握获取某些内核信息的方法** 。

更重要的是，希望读者能仔细领会这其中蕴含的设计思想： **提取共性，统一接口，个性化处理交给最合适的人**
。也希望读者能用这个设计思想来指导和启发解决实际问题的思路。

