共享库的使用在当今的各类计算机系统中都已经非常常见，它的出现让大型项目的组织形式更加灵活，管理更加方便，而且极大地节省了需要的存储和运行空间。本节课我们就来
**深入到共享库的内部去了解一下其工作的细节** ，主要包括以下几方面内容：

  * 共享库产生的渊源
  * 位置独立代码的工作原理
  * 动态链接器的工作过程
  * 共享库的版本维护

### 1 共享库产生的渊源

#### 1.1 静态库

在共享库出现之前，公用功能是以 **静态库**
的形式存在的，它把通用功能模块的多个目标文件打包在一起，用到它的程序只需要在链接时指定这个库文件，链接器就会从这个库中抽取出用到的功能代码拷贝到目标程序中，而不需要每次都对这些通用功能代码重新编译。

静态库体现出了很好的模块化思想，但是随着计算机产业规模的发展， **静态库逐渐暴露出了自身两个比较严重的问题** 。

  * 一是 **磁盘和内存空间占用大** 。静态库虽然加快了编译速度，提高了不同部门间的协作效率，但是在每个与静态库链接的程序中，都会保存一份引用到的通用功能代码的拷贝，而且在运行时，每一份拷贝都要占用相应的物理内存。

  * 二是 **库的版本升级非常麻烦** 。一旦公用库有修改，每个引用到它的程序都需要与新版本的库重新链接。在库与应用是由不同的公司或组织维护的场景下，升级工作将变得异常复杂。通用库中如果有 Bug 修复，使用该库的所有应用都需要分别升级。

#### 1.2 共享库

为了解决这两个问题， **共享库技术应运而生** 。

  * **首先** ，使用共享库的应用在编译链接时，并不把库中的功能代码拷贝到目标文件中，而 **只在目标文件中记录一条引用信息** ，标记引用到的库函数，直到程序运行时才由动态链接器去定位功能代码的位置，因此生成的可执行程序的体积得以明显地减小。
  * **其次，每个共享库在物理内存中只有一份副本** ，多个应用会在各自的虚拟地址空间内映射这同一份可执行文件，因此可以节省可观的内存空间。

共享库的 **这种工作方式大大方便了库的升级** ，当共享库发布新版本时，用户只需要升级这个共享库，所有使用这个库的应用就可以自动获得新库中的特性或 Bug
修复，而不需要单独升级每个应用。

共享库工作的 **关键在于运行时的动态加载和链接** ，所以共享库也叫做 **动态链接库**
。它动态性的主要表现是，同一个库在不同进程中的映射地址是不同的，这是为了解决多个库加载地址可能冲突的问题。

因为统一给每个库都分配一个固定的映射地址和范围几乎是不可能的。一是地址空间没有那么多，二是共享库的数量和每个库需要的内存大小都不好预估，所以动态库干脆让每个进程根据自己的内存使用情况来自由决定库的映射地址，甚至同一个应用的多次运行也可能会把同一个库映射到不同的虚拟地址。所以，
**动态库技术需要解决两个主要的问题** ：

  * 一是库代码需要能在任意内存地址运行；
  * 二是映射之后库之间互相引用的代码能定位到正确的地址。

本节课接下来的两个小节就会详细讲解它们分别是如何做到的。

虽然这里对共享库的产生由来和实现思路的介绍只用了寥寥数言，但是实际上，这个过程经过了前人大量的摸索和尝试，才最终定型为今天这种形式。

#### 1.3 静态共享库

历史上，为了解决模块装载地址的问题，还曾经出现过叫做 **静态共享库**
的解决方案，它是让操作系统统一管理各种模块的加载地址，操作系统划分出一些地址块预留给那些已知的模块。这样的做法让模块可以继续使用固定的加载地址，所以在代码生成和进程装载方面不需要做什么额外的事情，所有的事情都由操作系统在后台处理了。

当功能模块较少，每个模块的规模也比较固定的时候，这种做法还可以勉强应付。但是 **当模块数量变多** ，每个模块 **占用的内存空间不能预估**
的时候，这种做法就 **显得力不从心** 了。

而且，这种做法的 **模块升级也面临很严重的问题**
，因为应用程序在链接阶段就已经绑定了库中函数和变量的地址，所以，如果库有升级，原有的函数和变量地址都不能发生改变，否则会造成地址引用错误，而且这种错误非常隐蔽。由于它的种种限制和弊端，目前静态共享库已经完全被动态链接库所取代，只有在一些非常老的系统上，还遗留着它们的身影。

### 2 位置独立的代码

**当今的共享库可以支持在任意地址加载运行，这种技术叫做位置独立代码** 。要让 GCC 生成位置独立的代码，需要使用 -fPIC
选项，它告诉编译器，需要以特定的方式生成获取变量和函数地址的代码。

特定的方式具体是什么呢？这需要按照访问的变量或函数的不同情况分别讨论。为了能更加直观地介绍不同情况下的处理方法，本节课用下面代码作为示例：

    
    
    #include <stdio.h>
    
    static int static_val;
    extern int extern_val;
    int global_val;
    
    extern void external();
    
    static void internal() {
        static_val = 0x11223344;
    }
    
    void sharefunc(int caller) {
        internal();
        extern_val = 0x55667788;
        global_val = 0x99AABBCC;
        external();
    }
    

这个示例中，包含了以下四种函数和数据的访问方式。

  * **模块内部函数调用** ：sharefunc() 中调用 internal() 函数。
  * **模块内部数据访问** ：访问变量 static_val。
  * **模块间的数据访问** ：访问变量 external_val。
  * **模块间的函数调用** ：调用函数 external()。

把上面的代码编译成动态链接库，代码如下：

    
    
    gcc -fPIC -shared -o libshared.so shared.c
    

然后把生成的动态链接库用 objdump 反汇编出来，查看生成的每种情况的汇编代码：

    
    
    objdump -SD libshared.so > libshared.dump
    

#### 2.1 模块内部的函数调用

这种情况比较简单，虽然模块的加载地址会变化，但是模块内部各个函数之间的相对位置是固定的，所以只要
**使用相对地址跳转来调用模块内部函数，就可以做到与加载地址无关** 。

来看看生成的动态库中 sharefunc() 是如何调用内部函数 internal() 的：

    
    
    00000000000006b0 <internal>:
     6b0:   55                      push   %rbp
     6b1:   48 89 e5                mov    %rsp,%rbp
     6b4:   c7 05 6e 09 20 00 44    movl   $0x11223344,0x20096e(%rip)        # 20102c <static_val>
     6bb:   33 22 11
     6be:   90                      nop
     6bf:   5d                      pop    %rbp
     6c0:   c3                      retq
    
    00000000000006c1 <sharefunc>:
     6c1:   55                      push   %rbp
     6c2:   48 89 e5                mov    %rsp,%rbp
     6c5:   48 83 ec 10             sub    $0x10,%rsp
     6c9:   89 7d fc                mov    %edi,-0x4(%rbp)
     6cc:   b8 00 00 00 00          mov    $0x0,%eax
     6d1:   e8 da ff ff ff          callq  6b0 <internal>
     ......
    

调用 internal() 函数的汇编代码在 6d1 位置处，可以看到，生成的汇编码是 e8 da ff ff ff ，从 Intel
的编程手册中可以查到，e8 是相对地址跳转的 call 指令的操作码，其功能是调用从下一条指令地址算起偏移指定的偏移量的函数，指令的操作数 daffffff
是一个 32 位的偏移量，是 -38 的补码形式。计算一下，从 call 的下一条指令地址算起，0x6d6 - 38 = 0x6b0，刚好定位到
internal() 函数的开始地址。

**这种寻址方式天生就是与加载地址无关的，所以不需要对动态库做特殊处理。**

#### 2.2 模块内部的数据访问

这种情况也不太复杂。在共享库被加载到内存时，同一模块内的代码段与数据段的相对地址也是固定的，因此也可以用相对地址寻址，
**用当前指令地址加某个固定偏移量的方式就可以定位到目标数据** 。

如上面 internal() 函数访问 static_val 的代码（6b4）所示，它用当前 rip 加偏移量 0x20096e 来定位
static_val ，因为当一条指令在 CPU 中执行时，rip 已经被指向下一条指令了，所以当前 rip 的值就是下一条指令的地址 6be，6be +
0x20096e = 0x20102c。模块内未初始化的静态变量的存储位置应该在 .bss 段内，dump 文件的内容也能印证这一点（dump
内容中的汇编指令可以忽略，出现汇编指令仅仅是因为我们使用了 objdump 的 -D 选项，.bss 段中其实没有指令，只有数据，这里初始数据都是 0）：

    
    
    Disassembly of section .bss:
    0000000000201028 <__bss_start>:
      201028:       00 00                   add    %al,(%rax)
            ...
    000000000020102c <static_val>:
      20102c:       00 00                   add    %al,(%rax)
            ...
    0000000000201030 <global_val>:
            ...
    

所以，模块内数据的访问也是采用相对地址偏移的方式完成的，偏移位置是在编译时由编译器计算得到的。

**它也天生是与加载地址无关的，也不需要对动态库做特殊处理。**

但要知道的是，x86 架构的 CPU 到了 64 位的时候才有这种数据访问方式，在 32 位的 x86 CPU 中，指令指针寄存器 EIP 是只在 CPU
内部使用的，不允许应用程序直接访问。所以，在 32 位系统上，编译器用了一个小技巧来获取当前指令地址，把示例程序编译成 32
位共享库（-m32），反汇编会看到如下所示的代码：

    
    
    00000585 <sharefunc>:
     585:   55                      push   %ebp
     586:   89 e5                   mov    %esp,%ebp
     588:   53                      push   %ebx
     589:   83 ec 04                sub    $0x4,%esp
     58c:   e8 af fe ff ff          call   440 <__x86.get_pc_thunk.cx>
     591:   81 c3 6f 1a 00 00       add    $0x1a6f,%ecx
     597:   e8 cf ff ff ff          call   56b <internal>
     ......
    
    000005bf <__x86.get_pc_thunk.cx>:
     5bf:   8b 0c 24                mov    (%esp),%ecx
     5c2:   c3                      ret
    

可以看到，在 58c 行，使用本地相对地址跳转调用了一个函数 __x86.get_pc_thunk.cx ，因为 call
指令会把它的下一条指令的地址保存到栈上，用于函数执行完成之后的返回，所以，在函数 __x86.get_pc_thunk.cx 中把存在栈上的值保存到寄存器
ECX 中，在函数返回之后寄存器 ECX 中的值就是当前指令的地址了。

设计非常巧妙，但是这样一来，可能会影响 CPU 预加载指令的缓存命中率，对性能造成一定的影响。所以，在 x86 的 CPU 上，在模块内变量访问这一点上，
**64 位程序的性能要优于 32 位程序** 。

#### 2.3 模块之间的数据访问

模块间的数据访问就要稍微复杂一些了，因为不同模块加载之后，它们之间的相对位置不再是固定的了，只能等到所有模块都加载完成之后，才能根据实际的加载位置动态调整访问地址。同时，因为有多个进程共享同一份共享库代码，所以不能直接修改代码段中数据访问的地址值。那怎么办呢？

考虑到共享库的数据段在多个进程中是每个进程独立维护的，同时，数据段与代码段的相对地址是固定的，所以，可以
**让代码段到数据段的某个位置去获取变量的实际地址，程序运行时动态调整该数据段相应位置的值，使之指向正确的目标变量地址** 。

在 ELF 中，这个存放外部变量真实地址的区域是
.got（全局偏移表），模块内引用到的每个外部变量在该段中都会被预留出相应的位置，访问外部变量的代码会用相对位置寻址的方式找到这个位置，再从这个位置上读取变量真实的存放地址。程序启动时由动态链接器负责修改
.got 中的每一项，使之指向正确的外部变量虚拟地址。

示例动态库中访问变量 external_val 的代码为：

    
    
     6d6:   48 8b 05 f3 08 20 00    mov    0x2008f3(%rip),%rax        # 200fd0 <extern_val>
     6dd:   c7 00 88 77 66 55       movl   $0x55667788,(%rax)
    

可以看到，代码中首先使用当前指令地址 rip 加一个固定偏移 0x2008f3 来获得一个内存地址，然后用存放在该位置处的地址值来访问变量
external_val 。按照上面的理论，此处的目标地址 6dd + 0x2008f3 = 0x200fd0 应该位于 .got
段内，进一步查看目标文件的内容可以印证这一点：

    
    
    Disassembly of section .got:
    0000000000200fc8 <.got>:
            ...
    Disassembly of section .got.plt:
    0000000000201000 <_GLOBAL_OFFSET_TABLE_>:
    

因为这个动态库还没有被可执行程序加载到内存，所以只能看到这个地址落在了 .got 内。读者可以自己写一个依赖这个共享库的示例程序，在运行时用 GDB
查看相应位置的内容，看看被填入的地址值到底是什么，它应该正好指向外部变量 external_val 的实际存储地址。

**所以，模块间的数据访问是生成了访问固定相对位置的代码，然后在这个位置上保存变化的地址的方式实现的。**

#### 2.4 模块之间的函数调用

模块之间函数地址的确定方式与模块间的数据是类似的，也是用与代码段相对位置固定的一块区域保存外部函数的实际加载地址，运行时让动态链接器根据目标模块的实际加载地址来调整这里记录的地址值。

考虑到这样一个事实，程序或库中直接引用其他共享库的全局变量的情况是相对比较少见的，所以程序启动时动态解析每个外部变量的加载地址通常不会有大问题，但是对共享库中的功能函数的使用会非常多，如果启动时就解析用到的每个外部函数的地址，必然会拖慢程序的启动速度。

为了解决这个问题， **Linux 采用了延迟绑定技术**
，程序启动时并不会解析所有外部函数的符号地址，而是只有在第一次执行到引用这个外部函数的时候，才去执行函数实际地址的查找。ELF
对此有个非常精巧的设计，执行流程如下图：

![](https://images.gitbook.cn/46642010-d3ad-11e8-83c4-93b72872a9ed)

要搞清楚这个工作过程，有必要先解释一下这里用到的几个段。

  * .got.plt 段

全局偏移表，对 64 位的程序，每 8
个字节为一项，每一项记录一个外部函数的实际跳转地址，延迟绑定时解析出的跳转地址就是填到这里面的。这个段内的前三项被保留出来有特殊的用途。

**第一项** 会被设置成 .dynamic 段在本模块内的偏移量。

**第二项** 会保存该模块加载时生成的 link_map 的地址，link_map
又是个比较复杂的题目了，这里只需要知道这是动态链接器在加载共享库时生成的一个结构，通过这个结构，可以索引到很多动态库的信息就可以了。

**第三项** 是符号解析函数 _dl_runtime_resolve() 的地址。

从 **第四项** 开始，每一项对应一个外部函数，动态符号解析函数解析出的外部函数地址会被填入到函数对应的项里面。

  * .plt 段

过程链接表，其中包含若干固定 16 字节长度的项，其中第 0 项保留给符号解析函数 _dl_runtime_resolve()
使用，里面包含了一条压栈指令和一条跳转指令。其余各项分别对应一个需要动态重定位的函数，固定包含三条功能指令。

有了上面的基础知识，再来看调用过程就不难理解了。

**第一步** ，sharefunc() 调用函数 external() 发生在 6f5 处，这里使用相对地址调用跳到了 .plt 段中该函数的过程链接项。

**第二步** ，从该函数的 .got.plt 项中取出跳转目标地址。初始状态下，该表项中的地址又指回了函数的 .plt
项的第二条指令，所以，执行结果就是跳到接下来的一条指令继续往下执行。

**第三步** ，往栈上 Push 了一个参数之后，跳转到 .plt 的第 0 项，然后执行两条功能指令。可以看到，这两条指令的操作数分别是
.got.plt 表中的第二和第三项。

结合 .got.plt 表中这两项的含义可以知道，第一条指令是把动态库加载时生成的 link_map 的地址压栈，第二条指令则是跳转到了动态符号解析函数
_dl_runtime_resolve()，这个函数用 596 处传入的索引值可以确定要解析哪个函数，然后结合 link_map
结构的信息，就可以查找到目标函数的地址。然后它还会把解析出的函数地址填入 .got.plt
表中与目标函数对应的项，并执行一次解析出的函数。当这个函数再次被调用的时候，因为 .got.plt
表项中已经有正确的函数地址了，所以在第一步就可以直接跳转到正确的函数地址，而不会再执行二、三步。

这就是完整的延迟绑定技术的执行过程，设计非常紧凑，运行非常高效。

**所以，共享库模块间函数调用的实现，也是用访问固定相对位置的代码，并在该位置保存变化的函数地址的方式，只是在这中间又加了一层精巧的延迟绑定逻辑。**

### 3 共享库的加载过程

位置无关代码工作原理问题解决了，接下来就要找个实施者按照这套规则做事了，下面我们就来详细讨论一下
**动态链接的程序从装载进内存到可以正常工作之间经历的每个步骤** 。

**首先，装载是由操作系统完成的** 。操作系统会按照 ELF 文件的程序头信息把指定的段映射到进程的虚拟地址空间内，并设置相应的访问权限。

  * 如果程序是静态链接的，那么加载完成之后就会跳转到 ELF 文件头指定的入口地址去执行。
  * 如果程序是动态链接的，操作系统会把动态链接器的映像也映射到进程的虚拟空间内，然后把控制权交给动态链接器。

判断程序是动态链接还是静态链接的方法是看 ELF 文件的 .interp
段，该段保存的内容类型是字符串，如果是动态链接的程序，动态链接器的全路径名称就会被保存在里面；如果是静态链接的，而且不依赖任何别的共享库，该段就会没有内容，不过这种情况现在已经很少见了，大多数程序最少也要与
C 标准库动态链接。

**接下来，动态链接器会负责加载依赖的其他共享库，并修正互相之间引用的函数和数据地址** 。

不过这里还有一个问题需要解决，就是动态链接器自身也是一个共享库，它自己的加载地址也是不能确定的，所以它需要有一点特殊，就是它自身不能再依赖其他的共享库，否则就会陷入鸡生蛋、蛋生鸡的循环里面出不来了。

动态链接器中有一段特殊的自举代码，用于完成自身的指令和数据的地址修正，自举完成之后，再去实际干活。

动态链接器是 glibc 的一部分，有兴趣的读者可以去阅读这段精巧的自修正代码，在 glibc 源码目录的 elf/rtld.c 文件里面。

自举完成之后，要顺利完成接下来的任务，动态连接器还需要知道以下这样一些信息。

  * 还有哪些依赖的共享库需要加载？
  * 哪些位置的数值需要修正？
  * 需要修正的位置引用的是哪个共享库内的内容？
  * 应该如何对这些位置做修正？

下面就来依次看看 ELF 文件如何提供这些信息。

#### 3.1 确定依赖的共享库（.dynamic）

首先， **依赖的其他共享库的信息是保存在 .dynamic 段里**
的，除了这个信息之外，这个段还索引了动态链接需要的其他段的位置和大小等信息，readelf 命令提供的 -d 选项可以查看这个段的内容：

![](https://images.gitbook.cn/5750b3f0-ce37-11e8-9819-c5f6b437e972)

其中类型为 NEEDED 的项就是其他依赖的共享库，这里我们可以看到，这个共享库还依赖 C 标准库
libc.so.6。在查找进程依赖的共享库时，动态链接器会使用广度优先的搜索顺序找出当前进程所有直接或间接依赖的共享库，并把它们都映射到进程的虚拟地址空间内。

#### 3.2 确定需要重定位的代码位置（.rela.dyn）

接下来，要知道哪些位置需要执行重定位，就要用到动态链接重定位段（.rela.dyn）了，这个段会
**记录所有需要重定位的代码地址和重定位类型，以及定位目标的符号名** ，这些信息是在编译过程由编译器填上去的。我们的示例共享库的动态链接重定位表内容如下：

    
    
    # readelf -r libshared.so
    
    Relocation section '.rela.dyn' at offset 0x458 contains 10 entries:
      Offset          Info           Type           Sym. Value    Sym. Name + Addend
    000000200df0  000000000008 R_X86_64_RELATIVE                    680
    000000200df8  000000000008 R_X86_64_RELATIVE                    640
    000000201020  000000000008 R_X86_64_RELATIVE                    201020
    000000200fc8  000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0
    000000200fd0  000200000006 R_X86_64_GLOB_DAT 0000000000000000 extern_val + 0
    000000200fd8  000500000006 R_X86_64_GLOB_DAT 0000000000201030 global_val + 0
    000000200fe0  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
    000000200fe8  000a00000006 R_X86_64_GLOB_DAT 0000000000000000 _Jv_RegisterClasses + 0
    000000200ff0  000b00000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0
    000000200ff8  000d00000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0
    
    Relocation section '.rela.plt' at offset 0x548 contains 1 entries:
      Offset          Info           Type           Sym. Value    Sym. Name + Addend
    000000201018  000900000007 R_X86_64_JUMP_SLO 0000000000000000 external + 0
    

对 so 文件来说，offset 是要修正的位置相对文件开始位置的偏移，可以看到，我们的动态库中，要正确访问变量 global_val 和
extern_val，需要分别修正位置 0x200fd8 和 0x200fd0，按照前面介绍的理论，修正位置在 .got
段，动态链接器会在此填入对应变量的真实加载地址。

需要修正的外部函数则会在 .rela.plt 段中给出，这里 external() 函数的修正地址会落在 .plt.got
段，根据前面介绍的延迟绑定的工作过程，外部函数的地址在启动时会被动态链接器设置为固定指向该函数的 .plt
表项的第二条指令，这个过程不需要解析任何符号，所以可以非常快速地完成。

#### 3.3 查找符号对应的地址（.dynsym）

接下来，动态链接器要确定外部符号的实际加载地址，这就要用到动态符号表（.dynsym）。这个表里面 **记录了每个符号在当前模块内的位置**
。我们的示例共享库的动态符号表的内容如下：

    
    
    # readelf -s libshared.so
    
    Symbol table '.dynsym' contains 15 entries:
       Num:    Value          Size Type    Bind   Vis      Ndx Name
         0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
         1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab
         2: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND extern_val
         3: 0000000000201028     0 NOTYPE  GLOBAL DEFAULT   21 _edata
         4: 0000000000000700     0 FUNC    GLOBAL DEFAULT   12 _fini
         5: 0000000000201030     4 OBJECT  GLOBAL DEFAULT   22 global_val
         6: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
         7: 0000000000201038     0 NOTYPE  GLOBAL DEFAULT   22 _end
         8: 0000000000201028     0 NOTYPE  GLOBAL DEFAULT   22 __bss_start
         9: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND external
        10: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses
        11: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
        12: 00000000000006c1    60 FUNC    GLOBAL DEFAULT   11 sharefunc
        13: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5 (2)
        14: 0000000000000560     0 FUNC    GLOBAL DEFAULT    8 _init
    

可以看到，这里记录了 global_val 在本模块 0x201030 的位置， sharefunc() 在本模块 6c1 的位置，而 extern_val
和 external() 函数，因为是外部符号，所以位置为 0，并且被标记为
UND，表示这是一个在当前模块内未定义的符号，需要动态链接器到其他模块中去查找。因为所有的共享库都是动态链接器加载进来的，所以它知道每个库的加载首地址，结合这里的偏移量，就能确定每个符号的真实地址了。

#### 3.4 关于符号搜索顺序

Linux 上的动态链接器在查找其他模块的地址时，会从可执行程序开始，用 **广度优先算法依次查找**
，也就是说，会先找可执行文件的符号表，如果没有找到，再依次查找可执行 ELF
文件直接依赖的动态库，然后这样递归地一直找下去。如果到最后也没有找到，会提示找不到依赖的动态库，运行失败。

而如果在多个模块中有相同符号的变量或函数，那么按此顺序找到的第一个符号会生效，其余的符号都会被覆盖。

其实，在我们的示例程序中有一个小细节，就是生成的代码对 global_val
的访问方式，这个变量是模块内定义的一个全局变量，可是生成的代码没有按照模块内数据访问的方式来使用它，而是与访问外部变量一样，要去动态读取 .got
内的实际加载地址，其原因就是 **符号覆盖规则** 。

虽然本模块内定义了这个变量，但是在动态链接的过程中，它可能会被更早加载的其他模块内的同名符号所取代，为了保证同一进程内，相同的符号一定会引用到同一个全局变量副本，编译器只能把模块内的全局变量与外部变量同样对待。

此外， **Linux 中的共享库预加载技术，也是利用符号覆盖规则实现的** 。Linux
中允许指定程序启动时的预加载库，指定的库会在动态链接器加载实际依赖的库之前先加载进来，进行符号搜索时也会优先搜索预加载库，所以，在预加载库中实现一些函数，可以对某些库函数进行覆盖和重写。

#### 3.5 提高符号查找效率（.hash）

符号搜索的过程需要大量的字符串比较，时间复杂度是 O(N^2)， **为了优化符号查找的效率，ELF 中引入了哈希数据段**
（.hash），用于加快查找指定符号的速度。

哈希数据段中包含 nbucket 个散列项和 nchain 个链条项，其中 nchain
与本模块的动态符号表项的数目相同，链条项的索引也能索引相同位置的动态符号，而链条项上保存的值是与当前符号具有相同哈希值的下一项的下表。听起来有点绕，还是看图吧，哈希表的组织结构和查找关系示意如下所示：

![](https://images.gitbook.cn/82442920-d2ec-11e8-8fd1-112682bcd3c0)

其中从 bucket
数组中引出的蓝线表示没有哈希冲突，可以直接索引到符号表中的一项；而紫色线表示发生了哈希冲突，它索引的不是符号表项，而是链条数组中的某一项，链条数组的下标隐含对应了符号表的下标，用紫色线链在一起的就是具有相同哈希值的符号。

对哈希表的使用方式是，先用搜索目标字符串调用哈希函数生成一个整数值 N，然后用 nbucket[N%nbucket]
取到一个哈希表项，该项中会保存有一个索引值 I，这个索引值有可能是符号表项的索引，也可能是哈希链 chain
的索引，先拿该索引值去检查对应的符号表项看是否匹配。

如果匹配，说明运气好，第一次就找到了要找的符号，如图示中的 func0 和 func1；如果找到的符号项不匹配，那么再检查
chain[chain[I]]，……，依次一直找到链尾。通常情况下，运气常有而冲突不常有，即使有冲突，冲突的数量也远少于符号的数量，所以，哈希表的引入，能极大地减少符号查找时字符串比较的次数。

#### 3.6 完成重定向

当动态链接器为所有的待重定位符号都顺利完成重定位时，动态链接器就会跳转到程序指定的入口地址，正式转交控制权，程序就可以顺利启动执行了。

### 4 共享库的版本维护

细心的 Linux 开发者可能会注意到这样一个事实，就是 **系统的共享库目录中存在大量的符号链接** ，例如 CentOS 7 的 /lib64
目录下的部分内容：

    
    
    lrwxrwxrwx. 1 root root        24 Aug 19  2017 libavahi-client.so.3 -> libavahi-client.so.3.2.9
    -rwxr-xr-x. 1 root root     69968 Nov  5  2016 libavahi-client.so.3.2.9
    lrwxrwxrwx. 1 root root        24 Aug 19  2017 libavahi-common.so.3 -> libavahi-common.so.3.5.3
    -rwxr-xr-x. 1 root root     53848 Nov  5  2016 libavahi-common.so.3.5.3
    lrwxrwxrwx. 1 root root        22 Aug 19  2017 libavahi-core.so.7 -> libavahi-core.so.7.0.2
    -rwxr-xr-x. 1 root root    220776 Nov  5  2016 libavahi-core.so.7.0.2
    lrwxrwxrwx. 1 root root        22 Aug 19  2017 libavahi-glib.so.1 -> libavahi-glib.so.1.0.2
    -rwxr-xr-x. 1 root root     15672 Nov  5  2016 libavahi-glib.so.1.0.2
    lrwxrwxrwx. 1 root root        25 Aug 19  2017 libavahi-gobject.so.0 -> libavahi-gobject.so.0.0.4
    -rwxr-xr-x. 1 root root     49672 Nov  5  2016 libavahi-gobject.so.0.0.4
    lrwxrwxrwx. 1 root root        25 Aug 19  2017 libavahi-ui-gtk3.so.0 -> libavahi-ui-gtk3.so.0.1.4
    -rwxr-xr-x. 1 root root     54000 Nov  5  2016 libavahi-ui-gtk3.so.0.1.4
    

基本上每个链接库文件都会有一个名字简化的符号链接，这是为什么呢？其实，这是 **Linux 中共享库版本管理的一个策略** 。

在 Linux 中，共享库文件的命名规则为 libname.so.x.y.z。

其中，lib 是共享库文件的固定前缀，而后面的 x、y、z 分别是主版本号、次版本号和发布版本号。

  * 主版本号不同的共享库是不能相互兼容的。
  * 如果主版本号相同，而次版本号有升级，表示这个共享库有新接口的添加，但是同时所有老的接口和行为表现都保持不变，是向后兼容的。
  * 如果主次版本号都相同，只有发布版本号不同，则表示只有 Bug 修复和性能优化，对外的接口和表现都完全相同。

创建共享库时可以通过 -soname 参数指定共享库的别名，通常使用带主版本号的库名称作为共享库的别名，如我们的例子中，可以使用下面的命令生成发布的共享库：

    
    
    gcc -fPIC -shared -soname,libshared.so.1 -o libshared.so.1.0.0 shared.c
    

这样生成的共享库的 ELF 文件中会带有 DT_SONAME 的标签。当指定一个带 SONAME 的共享库与应用进行链接时，链接器会把该 SONAME
放入生成的可执行文件的 .dynamic 段中的 NEEDED 项中，以告知动态链接器该程序需要的库的兼容版本。例如上面我们看到的 libshared.so
依赖的 C 库，就是带主版本号的形式 libc.so.6。

在系统中，以主版本号为名字的符号链接通常指向系统中存在的主版本号一致而次版本号最新的共享库文件。这就是为什么我们会看到系统的共享库目录存在那么多链接文件的原因。

但是 **这种做法仍然无法解决这样一个问题** ：假如某个程序使用了某共享库 libshared.1.2.0 中新增的一个接口，但是因为 SONAME
只记录到主版本号，所以在可执行文件中记录的 NEEDED 项仍然是 libshared.so.1，现在如果把这个程序部署到了一台只安装了
libshared.so.1.1.0 的系统上，那么就会出现程序因为动态链接器无法为这个新增的接口重定位而启动失败的错误，但是用 ldd
检查依赖项又会发现明明所有依赖的共享库都是存在的。

目前 Linux 中对上面问题的 **解决方案是为每个符号都标记版本** （Symbol
Versioning），有兴趣的读者可以深入了解一下，本课程就不再详细展开了。

### 5 总结

本节课从共享库诞生的历史背景和需要解决的问题入手，详细介绍了共享库产生时背负的使命， **位置无关代码的实现原理** ，和动态链接的程序启动时
**动态修正重定位符号的处理过程** 。

通过本节课，希望读者可以对共享库的工作机理和它的好处与缺点有更深层次的理解。

> **参考资料**
>
> GitHub 源代码网址：
>
> <https://github.com/boswelyu/GitChatLesson-
> LinuxDevInDepth/tree/master/Lesson7>

