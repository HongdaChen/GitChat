C/C++ 程序具有强大而灵活的内存操作能力，而要驾驭这种强大的能力，要求开发者具有与之匹配的内功。对内存使用不当，很容易造成非常严重的后果。

在 C/C++ 开发中，经常遇到的比较头痛的内存使用问题有内存泄漏、内存重释放和内存溢出。在本节课中，我们就来重点 **讨论 Linux 应用的内存管理**
，并在现有内存管理机制的基础上，进一步 **讨论这几种常见内存使用问题的调试功能的实现思路** ，主要包括以下几方面内容：

  * 内存管理概述
  * 开始前的思考
  * 扩展调试功能的实现思路
  * 替换库函数

### 1 内存管理概述

系统中的内存管理可以分为两层。

  * **在内核层** ：内存管理系统为系统中运行的所有进程服务统筹规划物理内存的映射和分配，并管理交换分区及处理缺页中断，等等。

  * **在应用层** ：内存管理系统则负责管理单个进程拥有的虚拟内存区，比如，用高效的数据结构把所有的堆内存区管理起来，使得进程对不同大小的内存申请和释放请求都能快速而高效地得到满足。同时还要尽量减少内存碎片，从而减少物理内存的占用总量。

**本节课将要讨论的是在应用层上的内存管理。**

然而，应用层的内存管理本身也是个非常复杂的话题。在《第13课：活用内存映射与虚拟内存，让应用更高效》一节中，我们已经了解过，动态分配的内存开辟在进程的堆区，堆区内存的来源有两部分：

  * 一部分是由 brk 系统调用分配出来的连续空间；
  * 另一部分是使用 mmap 分配出来的，它们不一定连续，系统会用链表把所有可用的内存组织起来。

目前市面上已经出现了很多优秀的应用层内存分配器，比如 glibc 采用的 ptmalloc、Google 开源的 TCMalloc（Thread-
Caching Malloc），等等。

在它们的实现中都有非常精巧的数据结构，用来追踪和维护每一块分配出去的内存，并能在应用释放该内存之后，高效地回收和合并，准备服务于后续的内存申请请求。它们的性能和稳定性已经足够好了，绝大多数的应用并不需要在这一层面上重新造一套轮子。

在文章的开头，我曾提到在 C/C++ 程序开发中，常见的内存使用问题包括内存泄露、内存重释放和内存溢出。
**本节课讨论的重点，是在现有的内存分配器的基础上，扩展内存管理器的功能，分析这三种内存问题的调试功能的实现思路。**

其实，市面上也已经有很多优秀的内存检测工具了，比如 mtrace，以及功能强大的 Valgrind 等，它们对一些常见的内存使用问题都有相应的解决方案。

但是， **在使用这些工具的时候，总是不可避免地会遇到这样那样的问题** 。比如，使用 mtrace
需要修改代码，需要频繁地在可疑的位置上增加控制代码，使用起来不够灵活；而 Valgrind 不能指定在什么时间开始收集，什么时间结束收集，还有的平台上用不了
Valgrind，等等。

而通过本节课的学习，读者 **可以获得实现自己的内存调试功能的思路**
，帮助大家在实在找不到合适的可用资源时，能够针对自身的特殊需求，自己打造一套专用的工具。

### 2 开始前的思考

在开始之前，希望读者先考虑这样一个问题：在 C 语言中，用 malloc 或 calloc 动态分配的内存，在需要释放的时候，只需要把内存块的首地址传给
free 函数，而不需要额外提供内存块长度的信息，那么 free 函数是怎么知道要释放的这块内存有多大的呢？

使用如下的测试程序，或许你能发现一些端倪：

    
    
      1 #include <stdio.h>
      2 #include <stdlib.h>
      3 
      4 int main()
      5 {
      6     char * p1 = (char *)malloc(16);
      7     char * p2 = (char *)malloc(16);
      8     for(int i = 0; i < 16; i++)
      9     {
     10         p1[i] = (i + 1);
     11         p2[i] = (i + 1);
     12     }
     13 
     14     printf("P1: %p, P2: %p\n", p1, p2);
     15     free(p1);
     16     free(p2);
     18     return 0;
     19 }
    

我们编译这个程序，并用 gdb 调试运行，在程序退出之前增加断点。这时，我们用 gdb 的 print 命令查看 p1 的地址值，并把 p1
指向的地址附近的内存都 dump 出来，看看我们动态分配的内存是如何分布的。

在 64 位的 x86 机器上，读者应该会得到类似如下所示的结果：

    
    
    Breakpoint 1, main () at memdemo.cpp:14
    14        printf("P1: %p, P2: %p\n", p1, p2);
    (gdb) p p1
    $1 = 0x602010 "\001\002\003\004\005\006\a\b\t\n\v\f\r\016\017\020"
    (gdb) p p2
    $2 = 0x602030 "\001\002\003\004\005\006\a\b\t\n\v\f\r\016\017\020"
    (gdb) x/16x 0x602000
    0x602000:    0x00000000  0x00000000  0x00000021  0x00000000
    0x602010:    0x04030201  0x08070605  0x0c0b0a09  0x100f0e0d
    0x602020:    0x00000000  0x00000000  0x00000021  0x00000000
    0x602030:    0x04030201  0x08070605  0x0c0b0a09  0x100f0e0d
    

可以看到，虽然我们连续申请了两块 16 字节的小块动态内存，但是应用得到的这两块内存并不是连续的。再仔细观察应用得到的地址的前面一部分，好像还有一点点规律。

实际上，当使用 malloc 申请 N 字节动态内存的时候，在 64 位的系统上，实际分配给应用的内存至少是 N + 8 字节，其中多出来的 8
字节，是动态内存的固定头部，该内存块的长度信息就记录在多出来的 8 字节头部里面。

在上面的输出中，可以看到我们存储的数据之前的 8 字节中的内容是 0x00000000 0x00000021。在 glibc 中，小于 128 K
的内存块被划为小块内存，在 brk 系统调用开辟出来的连续堆区内再被划分和组织。它们是以 16 字节为单位划分大小的，这里标记的内存块大小，也是以 16
字节为单位，所以，最低的四位是可以空余出来用作别的用处的。因此，在这里，标记实际分配大小的是 0x2，表示实际分配出了 2 个 16 字节块，也就是 32
字节的内存。

**这也是 free 函数不需要传递内存块长度信息的原因，因为它可以从指定的内存地址，向前读取 8 字节的头部信息，并从中获取到要释放的内存块的长度** 。

### 3 扩展调试功能的实现思路

受以上思路的启发，我们也可以试着在内存块的头部做文章。如果我们能让每一次内存申请，都先经过一个被替换的 malloc
函数，在这个替换函数里，给实际申请的内存前预留出扩展头部的空间，并在扩展头部中保存相应的信息，就能够实现我们需要的各种调试功能。

#### 3.1 定位内存泄漏

内存泄漏，就是应用没有把不再使用的堆内存还给系统，使得进程占用的虚拟内存越来越大，达到一定程度之后，会导致新的内存分配请求失败。对于需要长期稳定运行的服务器进程（比如电信级服务器），内存泄漏是个很严重的问题。

**修复内存泄漏问题的关键在于，首先要识别出泄漏的内存是在什么位置分配的。知道这块内存后，再根据它的设计初衷，检查所有使用这块内存的前后逻辑，找出到底是哪里漏掉了释放操作**
。所以，要跟踪内存泄露，我们需要追踪每块分配出去的动态内存，并记录每块内存的分配位置。

使用扩展头部的思路，这两个需求都不难实现。比如，要追踪所有分配出去的内存块，可以准备一块存储区用于登记所有分配出去的内存块，并在内存块的扩展头部里面记录该块内存的登记位置，这样就可以在内存释放时，快速定位到登记位置，并删除登记信息。同时，为了记录每块内存的分配位置，可以把内存申请者的
backtrace 信息记录在相应的扩展头里面，一般记录 6 到 8 级 backtrace 就足够了。

这样，在测试结束之后，只要遍历内存登记区，找出当前还登记在册的内存块，它们就是可能泄露的内存块。同时，通过扩展区里记录的 backtrace
信息，就可以确定分配该块内存的代码位置。工作示例图如下：

![内存泄露追踪](https://images.gitbook.cn/0ee650e0-3bc2-11e9-b5cf-51e263b64b06)

这里，当 hook_malloc 拦截到应用发起的 malloc(N) 请求时，它实际要从 glibc 申请（N+64）字节的内存，这额外申请的 64
字节就用作附加的头部，记录 backtrace
信息；然后从内存登记区找一个空闲位置，记录当前获得的内存首地址，并在附加头部记录登记用的内存地址。附加信息记录完成之后，向应用返回图中绿色部分的 N 字节。

有了这样的机制之后，还可以给应用增加一个动态控制开始和停止内存收集的命令，可以使用特殊的信号，也可以另外启动一个专门监听外部控制命令的线程，比如，使用
Socket 或者 Unix Socket 都可以。

这样就可以做到内存收集的灵活控制，比如：

  * 可以在系统启动一段时间之后，再开启内存跟踪，以排除一些全局内存的干扰；
  * 可以在结束内存收集之后，再保持进程运行一段时间，来排除掉延迟释放的内存，这样，就能大大减少需要排查的可疑内存块数量。

#### 3.2 追踪内存重释放

内存重释放指的是，对同一块内存地址多次执行释放操作，这类问题的头疼之处在于它的隐蔽性。

正常情况下，对同一块内存连续的两次释放，第一次释放会将该内存返回给 libc 库维护的空闲列表，再次对它执行释放会立即引发一个错误，使得程序生成 core
文件并退出，所以，正常情况下，这种问题很容易定位。

但是，在一个复杂的系统中，情况往往并不是这么简单。更可能发生的情况是，一块内存被分配出去之后，有多个指针（例如指针 p1 和
p2）都指向它，如果在某个时刻，它被其中的一个指针（如 p1）释放掉之后，又被分配给了别人（比如 p3），但是这时，之前的 p2
指针仍然指向它，在之后的某个时刻，就可能会被 p2 再次错误地释放。

在标准库看来，第二次释放操作并没有什么不妥，因为交给 free 函数的指针确实指向一块被分配出去的有效的内存。但是，在这之后继续使用 p3
指向的内存的逻辑，就可能会产生各种不可预测的问题。假如这块内存再被分配给 p4，那么使用 p4 的逻辑也会与 p3 产生各种干扰。

**排查这种问题的复杂之处在于，从错误操作执行算起，到真的产生问题，可能已经过去了很长的时间，而且，发生错误处的逻辑往往并不是真正造成错误的位置**
。在上面的例子中，p3 和 p4 都是无辜的，它们的逻辑可能没有任何错误，但是表现出来的问题却发生在它们身上。

**要定位这种问题，关键还是要识别出无效的释放操作，也就是要想办法让 p2 释放内存时，就报告这可能是一个错误的操作** 。如何实现呢？

**一个可能的思路是，使用内存动态偏移技术**
。我们可以让每次内存申请动作，都赋予一个与上一次不同的偏移量。这样，一块内存被释放和重新分配出去时，应用层拿到的内存地址是不完全一样的。这样，当发现有人试图以不同于最新的偏移量的地址来释放内存时，我们就报告这种错误的行为，就能发现上面的罪魁祸首
p2。在内存泄漏的工作方式基础上扩展出内存重释放报告功能，其实现思路示意图如下所示：

![内存重释放](https://images.gitbook.cn/3cf8a610-46c9-11e9-a6db-375ae78f4f5a)

这里，当 hook_free() 函数接收到一个申请释放的内存地址时，读取它的前 8
个字节，获得该块内存的登记地址。如果发现登记地址并没有落在预分配的登记区域内，或者虽然落在了登记区域内，但是从指向的登记区域读到的地址和偏移信息与实际不一致，就说明这次释放有可能是一次错误的重释放动作。

在这种实现方式下，最大的偏移位置越大，发生漏检的几率就可以越小。读者可以根据自身系统的内存资源量，选择一个合适的大小。

#### 3.3 定位内存溢出

内存溢出指的是试图修改的内存区域超出了申请时指定的内存大小，比如，申请了 N 字节的动态内存，却试图去操作第 N
字节之外的内存区，这也是一个很让人头疼的问题。而且，不同于在栈上的溢出，在堆内存上发生的溢出，通常并不会导致程序崩溃，而是会改坏别的地方的数据，造成其他位置上的代码表现出逻辑上的错误，而出现逻辑错误的代码往往是完全无辜的。

**定位这种问题的关键，同样是要让发生溢出的操作被识别出来** 。有两种思路：事后算账和当面算账。

**事后算账**
，就是在分配出去的内存的前后都留出一定长度的区域，把它们都设置为固定的某个数值，然后周期性地，或者在内存释放的时候，确定前后的标记值有没有被修改。如果发现被修改，就报告该块内存上曾经被溢出修改过，然后需要开发者自行检查使用该块内存的逻辑，查找哪里发生了溢出操作。

而 **当面算账** ，就是要把溢出操作设定为非法操作，马上把它揪出来示众。

**这种思路的一个可能实现方式，是借助 mprotect 函数** 。在应用申请 N 字节内存的时候，我们实际给它分配 N 字节外加 2
个内存页，然后我们把返回给应用层的指针向后移动，让 N 字节的结尾对齐到一个内存页的边界，并把紧跟在后面的一个内存页用 mprotect 函数
**标记为只读** 。这样，一旦发生内存后溢写操作时，就会由于产生非法内存操作而被终止，并产生 core 文件。这样，从 core
文件保存的崩溃现场，就能确切地知道在什么位置发生了溢出。

同样的方法，如果把返回的首地址对齐到某个内存页边界上，并把它前一个内存页 **设置为写保护，就可以检测到上溢操作** 。

这种实现思路下，上溢和下溢检测，每次只能选择其一。而且，当开启内存溢出检查之后，每次内存分配都会至少占用三个内存页，因此会大大增加应用总的内存占用量，所以，只适合在测试环境下使用。

这种思路的实现示意图如下：

![内存溢出检测](https://images.gitbook.cn/3e8df850-3be2-11e9-b627-9597ba5508dc)

### 4 替换库函数

在实现以上三种功能的思路中，有个重要的步骤，就是要使对动态内存的申请操作，都先经过被替换后的某个函数，glibc 中申请动态内存的函数包括
malloc、alloc 和 realloc，释放内存的函数是 free。而 C++ 的 new 和 delete 操作在底层调用的也是这几个内存操作函数。

在我们的替换函数中，当需要向操作系统申请内存时还需要调用库内原始的 malloc
等函数，只是我们会修改实际申请的内存块大小，在用户申请的空间大小上，再加上我们自己的扩展头需要的额外空间。

要实现这个效果，使用 ld 的链接控制选项是最合适的。在链接器 ld 中有一个选项 –wrap，表示当查找某个符号 symbol 时，优先解析
__wrap_symbol，解析不到再去解析 symbol。例如，如下的代码：

    
    
    //wrapdemo.c
    void *__real_malloc(size_t size);
    void *__wrap_malloc(size_t size)
    {
         printf ("in wrap_malloc, received malloc size: %d\n", size);
         return __real_malloc(size);
    }
    
    int main(int argc, char * argv[])
    {
        void * mem = malloc(32);
        memset(mem, 0, 32);
        free(mem);
        return 0;
    }
    

使用如下的命令编译：

    
    
    gcc -Wl,--wrap,malloc -o wrapdemo wrapdemo.c
    

然后执行 wrapdemo，就会发现 malloc 函数会先经过我们自己定义的 __wrap_malloc() 函数。用同样的方式，让
calloc、realloc 和 free 函数也都先经过我们自定义的 wrap 函数，就能达到我们的目的了。

### 5 总结

在本节课中，我们讨论了 **在现有内存管理器基础上，实现常见的三类内存问题的调试功能的思路** 。

如果读者手头一直没有找到适合自己产品的内存调试工具，不妨试试在此基础上自己打造一款。如果读者有更好的想法，欢迎在读者群讨论交流。

