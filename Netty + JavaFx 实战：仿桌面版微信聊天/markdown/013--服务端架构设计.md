## 一、前言

可能有些同学一听到架构会感觉到有些“高大上”，或者以为这些东西有些神秘。当然如果是刚刚接触开发没多久，或者刚工作只是参与业务需求的实现，并没有从整体看待全局。那么是有可能对这些架构的字眼有些发蒙。其实从简单来说，哪怕是你最开始练习做作业的
`CRUD`，其实它也是一种建构模式。只不过在这个架构的世界里有一个叫更适合的词，只有适合你业务的才是更好的架构。不一定非得把你仅仅是一个非常小的几十人访问的工程，非得用上分布式。也不是硬是要在十万并发的场景下直连数据库。所以更适合才是更好的架构。

那么！一个架构模型的诞生还远不止结构上的分层，还包括多技术以及相应内部业务模块的融合。例如；你的服务基础使用 Spring 还是
SpringBoot、你需要使用到 RPC 可能会选择 Dubbo、你的缓存使用 Redis、你的数据库分库分表用 MyCat、你的文件系统使用 ES
等等，以及你自己开发的一些中间件。

**好** ！接下来我们开始设计目前这个通信服务的一个控制中心的服务端架构。

## 二、架构目标

在前面我们说到更适合的架构，才是符合你当下需要最好的架构。那么怎么设计这样架构呢，基本就是要找到符合点的目标。我们之所以这样设计是为什么，那么在这个系统里有如下几点；

  1. 我们系统在服务端要有 web 页面进行管理通信用户以及服务端的控制和监控。
  2. 数据库的对象类，不要被外部污染，要有隔离性。比如说；你的数据库类暴漏给外部做展示类使用了，那么现在需要增加一个字段，而这个字段又不是你数据库存在的属性。那么这个时候就已经把数据库类污染了。
  3. 因为目前我们都是在 Java 语言下实现 Netty 通信，那么服务端与客户端都会需要使用到通信过程中的协议定义和解析。那么我们需要抽离这一层对外提供 Jar 包。
  4. 接口、业务处理、底层服务、通信交互，要有明确的区分和实现，避免造成混乱难以维护。

结合我们上面这四点的目标，你头脑中有什么模型结构体现了呢？以及相应的技术栈选择上是否有计划了？接下来我们会介绍两种架构设计的模型，一种是你非常熟悉的
`MVC`，另外一种是你可能听说过的 `DDD` 领域驱动设计。

### 1\. MVC 结构

    
    
    itstack-naive-chat-server-01
    └── src
        ├── main
        │   ├── java
        │   │   └── org.itstack.naive.chat
        │   │       ├── common
        │   │       ├── controller
        │   │       │  └── UserController.java
        │   │       ├── dao
        │   │       ├── model
        │   │       │  ├── po
        │   │       │  ├── req
        │   │       │  ├── res
        │   │       │  └── vo
        │   │       └── service
        │   │           ├── inet
        │   │           ├── socket
        │   │           └── user
        │   ├── resources
        │   └── webapp
        └── test
            └── java
                └── org.itstack.test
                    └── ApiTest.java
    

  * 这一层的职责基本基本可以简述如下；
  * common 通用层，定义一些公共的类、枚举和工具
  * controller 控制层，用于对外提供包装后的接口，当然也可以再包装一层结构，view 提供接口，controller 提供代码的具体实现
  * dao 数据库层，提供数据库的 CRUD 操作
  * model 模型层，也就是我们需要的各种类，数据库类，请求类，返回类、业务类、展现类等 = service 服务层，所有的 `controller` 操作实现，都会调用到 `service` 中的结构，同时在 `service` 中还提供了通信服务 `socket`
  * 可以说 `MVC` 这种很经典的架构模式可以说是非常通用的，也被用到了很多的场景中去。
  * 那么在你平时的开发中你的 `po` 或者 `vo` 类中是否有不断的激增，到最后已经记不住某个类做什么的了？同时这还是一种贫血模型，`model` 的功能很单一，但是提供 `get/set`，并没有跟随业务走，从而随着开发代码的不断增多，最后难以维护。

### 2\. DDD 领域驱动设计

    
    
    itstack-naive-chat-server-02
    └── src
        ├── main
        │   ├── java
        │   │   └── org.itstack.naive.chat
        │   │       ├── application
        │   │       │    ├── event
        │   │       │    │   └── ApplicationRunner.java
        │   │       │    └── service
        │   │       │        └── UserService.java    
        │   │       ├── domain
        │   │       │    ├── model
        │   │       │    │   ├── aggregates
        │   │       │    │   │   └── UserRichInfo.java
        │   │       │    │   └── vo
        │   │       │    │       ├── UserInfo.java   
        │   │       │    │       └── UserSchool.java 
        │   │       │    ├── repository
        │   │       │    │   └── IuserRepository.java
        │   │       │    └── service
        │   │       │        └── UserServiceImpl.java    
        │   │       ├── infrastructure
        │   │       │    ├── dao
        │   │       │    │   ├── impl
        │   │       │    │   │   └── UserDaoImpl.java
        │   │       │    │   └── UserDao.java    
        │   │       │    ├── po
        │   │       │    │   └── UserEntity.java 
        │   │       │    ├── repository
        │   │       │    │   ├── mysql
        │   │       │    │   │   └── UserMysqlRepository.java
        │   │       │    │   ├── redis
        │   │       │    │   │   └── UserRedisRepository.java
        │   │       │    │   └── UserRepository.java 
        │   │       │    └── util
        │   │       │        └── RdisUtil.java
        │   │       ├── interfaces
        │   │       │    ├── dto
        │   │       │    │   └── UserInfoDto.java    
        │   │       │    └── facade
        │   │       │        └── DDDController.java
        │   │       └── DDDApplication.java
        │   ├── resources    
        │   │   └── application.yml
        │   └── webapp    
        │       └── WEB-INF
        │            └── index.jsp   
        └── test
             └── java
                 └── org.itstack.demo.test
                     └── ApiTest.java
    

> DDD（Domain-Driven Design 领域驱动设计）是由 Eric Evans
> 最先提出，目的是对软件所涉及到的领域进行建模，以应对系统规模过大时引起的软件复杂性的问题。整个过程大概是这样的，开发团队和领域专家一起通过 通用语言
> (Ubiquitous Language)
> 去理解和消化领域知识，从领域知识中提取和划分为一个一个的子领域（核心子域，通用子域，支撑子域），并在子领域上建立模型，再重复以上步骤，这样周而复始，构建出一套符合当前领域的模型。

**服务架构通信模型**

![](https://vip1.loli.net/2020/03/14/D85oCBZ23XJd1gr.png)

  * 应用层{application}

  * 应用服务位于应用层。用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装。

  * 应用层的服务包括应用服务和领域事件相关服务。

  * 应用服务可对微服务内的领域服务以及微服务外的应用服务进行组合和编排，或者对基础层如文件、缓存等数据直接操作形成应用服务，对外提供粗粒度的服务。

  * 领域事件服务包括两类：领域事件的发布和订阅。通过事件总线和消息队列实现异步数据传输，实现微服务之间的解耦。

  * 领域层{domain}

  * 领域服务位于领域层，为完成领域中跨实体或值对象的操作转换而封装的服务，领域服务以与实体和值对象相同的方式参与实施过程。

  * 领域服务对同一个实体的一个或多个方法进行组合和封装，或对多个不同实体的操作进行组合或编排，对外暴露成领域服务。领域服务封装了核心的业务逻辑。实体自身的行为在实体类内部实现，向上封装成领域服务暴露。

  * 为隐藏领域层的业务逻辑实现，所有领域方法和服务等均须通过领域服务对外暴露。

  * 为实现微服务内聚合之间的解耦，原则上禁止跨聚合的领域服务调用和跨聚合的数据相互关联。

  * 基础层{infrastructrue}

  * 基础服务位于基础层。为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响。

  * 基础服务主要为仓储服务，通过依赖反转的方式为各层提供基础资源服务，领域服务和应用服务调用仓储服务接口，利用仓储实现持久化数据对象或直接访问基础资源。

  * 接口层{interfaces}

  * 接口服务位于用户接口层，用于处理用户发送的 Restful 请求和解析用户输入的配置文件等，并将信息传递给应用层。

**以上** ，是我们对 DDD 领域驱动设计的一个 Demo 案例，下面随着我们的对架构的调整添加通信模型，还会修改架构以达到更加适合我们。

## 三、架构模型

为了更合理的实现我们的架构目标，我们分别展示了 `MVC`、`DDD` 的分层方式，在结构上四层架构的 DDD
更加适合我们使用。那么这样的处理结构分层后就会如下效果；

![](https://vip1.loli.net/2020/03/14/4kf8J1wbsH5CvcD.png)

  * 首先四个基础的层级；接口层、业务层、领域层、基础层，每一个层级负责不同的内容，并且以领域设计为核心。

  * 之后是我们的通信层，也就是 Socket 服务端对业务流程的处理和数据转发服务。同时将一些数据，聊天记录等进行落库操作。

  * 最后是我们用到开发环境以及技术栈的使用。从整个图稿来看，因为不含带很重的业务和组，所以还是比较轻量级的架构模型的。

那么这样的结构就会与我们只是单纯的 DDD 模型下，通信方式有所不同。如下；

![](https://vip1.loli.net/2020/03/14/h6SNXtjv5iyBukY.png)

  * 整体来看除了添加了 `Socket` 功能外，这里并没有 `mq` 和一些定时任务处理，所以还是比较轻量级的。这主要源于我们目前只是在实现核心功能。

  * 细心看可以发现这里的数据库层、业务层，到最终对外的接口层，所有的 ** 对象类 ** 都是相互隔离不会造成污染的。这也是在设计中非常重要的点。

  * 同时这样的结构也非常有利于多人开发，各自负责自己的核心领域，不要互相影响。也不要随便的添加类字段而导致其他人原本已经完善的功能变得异常。

## 四、工程搭建

    
    
    itstack-naive-chat-server-03
    └── src
        ├── main
        │   ├── java
        │   │   └── org.itstack.naive.chat
        │   │       ├── application
        │   │       │    ├── InetService.java
        │   │       │    └── UserService.java
        │   │       ├── domain
        │   │       │    ├── user
        │   │       │    │   ├── model
        │   │       │    │   ├── repository
        │   │       │    │   └── service
        │   │       │    └── inet
        │   │       │        ├── model
        │   │       │        ├── repository
        │   │       │        └── service
        │   │       ├── infrastructure
        │   │       │    ├── common
        │   │       │    ├── dao
        │   │       │    ├── po
        │   │       │    └── repository
        │   │       ├── interfaces
        │   │       │    └── InetController.java
        │   │       ├── socket
        │   │       │    ├── MyBizHandler.java
        │   │       │    ├── MyChannelInitializer.java
        │   │       │    └── NettyServer.java
        │   │       └── Application.java
        │   ├── resources    
        │   │   └── application.yml
        │   └── webapp
        │       └── chat
        │       └── res
        │       └── index.html
        └── test
             └── java
                 └── org.itstack.demo.test
                     └── ApiTest.java
    

  * 首先从 DDD 模型的结构上来看，我们增加了 socket 通信包。而这一层主要负责数据的通信服务。
  * 整个工程来看，是一个定义好的结构的空壳子，并没有实现相应的服务功能。而后续会在这里面不断的完善逻辑代码。
  * 等到我们把数据库表设计完成后续，会在 `infrastructure` 基础层中添加数据库相关操作的代码。

## 五、总结

  * 在这章节我们介绍和讲解了服务端架构的设计，目前我的服务端壳子已经有了，后续会使用不同技术栈能力来完善服务功能。
  * 同时可以看到这一章节我们只是定义了通信为 Netty 但是还没有定义通信协议等，这些需要随着后续不断来完善。
  * 另外我们使用 DDD 模式来搭建我们的架构，主要是想让大家亲手练习下，不要总是被理论知识搞晕，对于研发来说要从先落地的东西作为一个抓手，之后在不断的深化学习。

